<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>King Bolete Environmental Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #8B4513;
        }
        
        h1 {
            color: #8B4513;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.2rem;
            font-style: italic;
        }
        
        .description {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #8B4513;
			font-size: 14px;
        }
        
        .main-container {
            display: block;
            grid-template-columns: 300px 1fr;
            gap: 25px;
        }
        
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
        
        .content-container {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .content-container {
                grid-template-columns: 1fr;
            }
        }
        
        .graph-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
        
        .graph-container:hover {
            transform: translateY(-5px);
        }

        .graph-container:has(#data-table) {
            max-height: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #data-table-container {
            overflow-y: auto;
            flex-grow: 1;
            max-height: 430px;
        }
        
        .graph-title {
            color: #8B4513;
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-align: center;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
            width: 100%;
        }

		/* Chart header and controls */
		.chart-header {
			display: flex;
			flex-direction: column;
			margin-bottom: 20px;
		}

		.chart-controls {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
			margin-top: 10px;
			align-items: center;
			justify-content: center;
		}

		.chart-selector, .axis-selectors {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.axis-selectors {
			display: flex;
			gap: 20px;
		}

		.axis-selector {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.chart-selector label, .axis-selector label {
			margin-bottom: 0;
			min-width: 80px;
			text-align: right;
			font-size: 16px;
			font-weight: 600;
		}

		.chart-selector select, .axis-selector select {
			padding: 8px 12px;
			font-size: 14px;
			border: 1px solid #ddd;
			border-radius: 4px;
			min-width: 150px;
		}

		.histogram-controls {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
			margin-top: 10px;
			flex-wrap: wrap;
		}

		.histogram-controls select,
		.histogram-controls input[type="number"] {
			padding: 8px 12px;
			font-size: 14px;
			border: 1px solid #ddd;
			border-radius: 4px;
			min-width: 50px;
			max-width: 30%;
		}

		.histogram-controls label {
			font-size: 14px;
			margin-left: 5px;
			white-space: nowrap;
		}

		#histogramChart {
			cursor: pointer;
		}
        
        .input-section {
            background-color: #fff;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
		.input-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			top: 0;
			background-color: #fff;
			z-index: 10;
		}

        .input-title {
            color: #8B4513;
            margin-bottom: 20px;
            font-size: 1.6rem;
        }
        
        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .input-field {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #8B4513;
        }
        
        button {
            background-color: #8B4513;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #6B3410;
        }
        
        .map-container {
            height: 600px;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 15px;
            border: 1px solid #ddd;
        }
        
        .info-panel {
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: none;
        }
        
        .info-panel.active {
            display: block;
        }
        
        .info-title {
            color: #8B4513;
            margin-bottom: 15px;
            font-size: 1.4rem;
            border-bottom: 2px solid #8B4513;
        }
        
        .info-content {
            line-height: 1.8;
        }
        
        .info-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .info-label {
            font-weight: 600;
            color: #555;
            display: inline-block;
            width: 275px;
            white-space: nowrap;
        }
        
        .link {
            color: #1a73e8;
            text-decoration: none;
            word-break: break-all;
        }
        
        .link:hover {
            text-decoration: underline;
        }
        
        .user-point {
            background-color: #FF6B6B !important;
            border-color: #FF3838 !important;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 15px;
            color: #8B4513;
            font-weight: 600;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 0.9rem;
        }
        
        /* NDJSON Directory Styles */
		.ndjson-directory {
			background-color: #fff;
			border-radius: 10px;
			padding: 20px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
			height: 100%;
			max-height: 325px;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
		}
        
		.directory-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
			position: sticky;
			top: 0;
			background-color: #fff;
			z-index: 10;
		}
        
        .directory-title {
            color: #8B4513;
            font-size: 1.3rem;
            font-weight: 625;
        }
        
		.directory-content {
			flex-grow: 1;
			overflow-y: auto;
		}

		.toggle-btn {
			background: none;
			border: none;
			color: #8B4513;
			font-size: 1.2rem;
			cursor: pointer;
			padding: 5px;
		}
        
        .folder {
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #eee;
        }
        
        .folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #f8f8f8;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .folder-name {
            font-weight: 600;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .folder-content {
            padding: 10px;
            background-color: #fff;
            transition: max-height 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }
        
        .folder-content.collapsed {
            max-height: 0;
            padding: 0 10px;
        }
        
        .ndjson-file {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }
        
        .ndjson-file:hover {
            background-color: #f5f5f5;
        }
        
        .file-toggle {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .file-toggle.active {
            background-color: #8B4513;
            color: white;
            border-color: #6B3410;
        }
        
        .file-name {
            flex: 1;
            font-size: 14px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-count {
            font-size: 12px;
            color: #888;
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .color-picker {
            width: 24px;
            height: 24px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
        }
        
		.settings-section {
			background-color: #fff;
			border-radius: 10px;
			padding: 20px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
			height: 100%;
			display: flex;
			flex-direction: column;
		}
        
        .settings-title {
            color: #8B4513;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .setting-group {
            flex-grow: 1;
        }
        
		.setting-row {
			display: flex;
			align-items: center;
			gap: 15px;
			margin-bottom: 15px;
		}

		.setting-label {
			min-width: 150px;
			font-weight: 600;
			color: #555;
			flex-shrink: 0;
		}

		#apply-settings {
			margin-top: auto;
		}

		/* Side-by-side container */
		.side-by-side-container {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 25px;
			margin-bottom: 25px;
		}

		@media (max-width: 1200px) {
			.side-by-side-container {
				grid-template-columns: 1fr;
			}
		}
        
        /* Styles for map controls */
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .view-options {
            display: flex;
            gap: 5px;
        }
        
        .view-options button {
            padding: 5px 10px;
            font-size: 12px;
            background: #f0f0f0;
            color: black;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .view-options button.active {
            background: #8B4513;
            color: white;
            border-color: #6B3410;
        }
        
        .slider-container {
            display: none;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            margin-top: 5px;
        }

        .slider-container label {
          display: block;
          text-align: center;
          font-weight: 600;
          margin-bottom: 6px;
        }
        
        .slider-container.active {
            display: block;
        }
        
        .slider-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        /* Custom styles for smaller noUiSlider handles */
        .noUi-handle {
            width: 12px !important;
            height: 12px !important;
            right: -6px !important;
            top: -4px !important;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        .noUi-horizontal .noUi-handle {
            width: 16px !important;
            height: 16px !important;
            right: -8px !important;
            top: -5px !important;
        }

        .noUi-handle:before, .noUi-handle:after {
            display: none !important;
        }

        .noUi-connect {
            background-color: transparent !important;
        }

        .noUi-target {
            background-color: none !important;
            border: 1px solid #ddd !important;
            box-shadow: none !important;
        }

        .noUi-tooltip {
            font-size: 10px !important;
            padding: 2px 5px !important;
            background: #8B4513 !important;
            color: white !important;
            border: none !important;
            border-radius: 3px !important;
        }

        /* Adjust the slider height */
        .noUi-horizontal {
            height: 8px !important;
        }

        /* Make sure the handle is properly positioned */
        .noUi-horizontal .noUi-handle-lower {
            right: -7px !important;
        }

        .noUi-horizontal .noUi-handle-upper {
            right: -7px !important;
        }
        
        .fullscreen-btn {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            color: black;
            padding: 5px 10px;
            border-radius: 3px;
            border: 1px solid #ddd;
            cursor: pointer;
            font-size: 12px;
        }
        
        .fullscreen-btn:hover {
            background: #f0f0f0;
        }
        
        /* Fullscreen styles */
        .map-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
        }
        
        .map-container.fullscreen .map-controls {
            top: 20px;
            right: 20px;
        }
        
        .map-container.fullscreen .fullscreen-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
        }

        /* Legend container styles */
        .legend-container {
            position: absolute;
            bottom: 50px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
            max-width: 200px;
            font-size: 12px;
        }

        .legend-container.active {
            display: block;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .legend-gradient {
            height: 20px;
            width: 100%;
            border-radius: 3px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #555;
        }

        /* Month legend grid styles */
        .month-legend-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 5px;
        }

        .month-legend-item {
            display: flex;
            align-items: center;
            padding: 2px;
            font-size: 10px;
        }

        .month-color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 4px;
            border: 1px solid rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .month-label {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 9px;
        }

		.highlighted-point {
			background-color: #FFA500 !important;
			border-color: #FFD700 !important;
			z-index: 10000 !important;
		}

		.chart-highlight {
			background-color: #FFA500 !important;
			border-color: #FFD700 !important;
			border-width: 3px !important;
			z-index: 10 !important;
		}

		#user-point-color, #highlight-color {
			width: 30px;
			height: 30px;
			border: 1px solid #ddd;
			border-radius: 4px;
			cursor: pointer;
			padding: 0;
		}

		#clear-user-points {
			background: none;
			border: 1px solid #ddd;
			border-radius: 4px;
			padding: 5px 10px;
			cursor: pointer;
			font-size: 16px;
		}

		#clear-user-points:hover {
			background-color: #f0f0f0;
		}

		.aspect-circular-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 10px;
			background: #f9f9f9;
			border-radius: 5px;
			margin-top: 5px;
		}

		.aspect-inputs {
			display: flex;
			align-items: center;
			gap: 15px;
			margin-bottom: 15px;
			width: 100%;
			justify-content: center;
		}

		.aspect-input {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.aspect-input input {
			width: 60px;
			padding: 5px;
			border: 1px solid #ddd;
			border-radius: 3px;
			text-align: center;
		}

		.aspect-circle {
			position: relative;
			width: 200px;
			height: 200px;
			border-radius: 50%;
			background: conic-gradient(
				from 0deg,
				#ff0000 0deg,
				#ffff00 90deg,
				#00ff00 180deg,
				#0000ff 270deg,
				#ff0000 360deg
			);
			border: 2px solid white;
			box-shadow: 0 2px 5px rgba(0,0,0,0.2);
		}

		/* Selected range overlay */
		.aspect-selected-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			border-radius: 50%;
			pointer-events: none;
		}

		.aspect-handle {
			position: absolute;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: #cc5d31;
			border: 2px solid white;
			cursor: pointer;
			box-shadow: 0 2px 5px rgba(0,0,0,0.3);
			transform: translate(-50%, -50%);
			z-index: 10;
		}

		.aspect-handle.start {
			background: #8B4513;
		}

		.aspect-handle.end {
			background: #cc5d31;
		}

		.aspect-center {
			position: absolute;
			top: 50%;
			left: 50%;
			width: 60%;
			height: 60%;
			background: white;
			border-radius: 50%;
			transform: translate(-50%, -50%);
			pointer-events: none;
		}

		.aspect-north {
			position: absolute;
			top: 10px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 12px;
			font-weight: bold;
			color: #333;
		}

		.aspect-compass {
			position: absolute;
			font-size: 12px;
			font-weight: bold;
			color: #333;
			pointer-events: none;
			text-shadow: 1px 1px 1px white;
		}

		/* Main compass directions */
		.aspect-compass.north { top: -20px; left: 50%; transform: translateX(-50%); }
		.aspect-compass.east { top: 50%; right: -20px; transform: translateY(-50%); }
		.aspect-compass.south { bottom: -20px; left: 50%; transform: translateX(-50%); }
		.aspect-compass.west { top: 50%; left: -20px; transform: translateY(-50%); }

		/* Intermediate directions */
		.aspect-compass.northeast { top: 10px; right: 10px; }
		.aspect-compass.southeast { bottom: 10px; right: 10px; }
		.aspect-compass.southwest { bottom: 10px; left: 10px; }
		.aspect-compass.northwest { top: 10px; left: 10px; }

		/* Degree markers */
		.aspect-degree {
			position: absolute;
			font-size: 10px;
			color: #666;
			pointer-events: none;
		}

		.aspect-degree.zero { top: 5px; left: 50%; transform: translateX(-50%); }
		.aspect-degree.ninety { top: 50%; right: 5px; transform: translateY(-50%); }
		.aspect-degree.one-eighty { bottom: 5px; left: 50%; transform: translateX(-50%); }
		.aspect-degree.two-seventy { top: 50%; left: 5px; transform: translateY(-50%); }
    </style>
</head>
<body>
    <header>
        <h1>King Bolete Environmental Analysis</h1>
        <p class="subtitle">Visualizing the relationship between elevation, soil temperature, soil moisture, and seasonal patterns</p>
    </header>
    
    <div class="description">
        <p>This interactive dashboard explores environmental factors associated with King Bolete observations using only open (non-obscured) observation data. The scatter plots below show relationships between elevation, soil temperature, soil moisture, and time of year. Click on any point to view detailed information about that observation.</p>
    </div>
    
	<div class="main-container">    
		<!-- Main content area -->
		<div>
			<!-- Side-by-side containers -->
			<div class="side-by-side-container">
				<!-- NDJSON Data Files container -->
				<div class="ndjson-directory">
					<div class="directory-header">
						<div class="directory-title">Data Files</div>
					</div>
					<div class="directory-content" id="directory-content">
						<!-- Directory content will be populated by JavaScript -->
						<div class="loading" id="directory-loading">Loading NDJSON directory...</div>
						<div id="ndjson-folder-structure"></div>
					</div>
				</div>
				
				<!-- Data Settings container -->
				<div class="settings-section">
					<h3 class="settings-title">Data Settings</h3>
					
					<div class="setting-group">
						<div class="setting-row">
							<div class="setting-label">Average Days:</div>
							<select id="average-days">
								<option value="1">1 day</option>
								<option value="3">3 days</option>
								<option value="7" selected>7 days</option>
								<option value="10">10 days</option>
								<option value="14">14 days</option>
							</select>
						</div>
						
						<div class="setting-row">
							<div class="setting-label">Soil Temp Depth:</div>
							<select id="temp-depth">
								<option value="0_to_7cm">0-7 cm</option>
								<option value="7_to_28cm" selected>7-28 cm</option>
								<option value="28_to_100cm">28-100 cm</option>
								<option value="0_to_100cm">0-100 cm</option>
							</select>
						</div>
						
						<div class="setting-row">
							<div class="setting-label">Soil Moisture Depth:</div>
							<select id="moisture-depth">
								<option value="0_to_7cm">0-7 cm</option>
								<option value="7_to_28cm" selected>7-28 cm</option>
								<option value="28_to_100cm">28-100 cm</option>
								<option value="0_to_100cm">0-100 cm</option>
							</select>
						</div>
					</div>
					
					<button id="apply-settings" style="width: 100%;">Apply Settings</button>
				</div>
			</div>
			
			<div class="input-section">
				<div class="input-header">
					<h2 class="input-title">Location Data</h2>
					<div style="display: flex; gap: 10px;">
						<button id="clear-user-points" title="Clear user points">üóëÔ∏è</button>
						<input type="color" id="user-point-color" value="#FF6B6B" title="User point color">
						<input type="color" id="highlight-color" value="#FFA500" title="Highlight color">
						<label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
							<input type="checkbox" id="disable-scroll" checked> Scroll
						</label>
					</div>
				</div>
                <p style="font-size: 18px;">Enter coordinates manually or click on the map to select a location. The system will retrieve the soil and elevation data from the Open-Meteo Historical Weather API.</p>
                
                <div class="input-group">
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label for="latitude">Latitude</label>
                        <input type="number" id="latitude" step="any" placeholder="e.g., 46.744487" value="46.744487" style="width: 100%;">
                    </div>
                    
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label for="longitude">Longitude</label>
                        <input type="number" id="longitude" step="any" placeholder="e.g., -121.812952" value="-121.812952" style="width: 100%;">
                    </div>
                    
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label for="date">Observation Date</label>
                        <input type="date" id="date" style="width: 100%;">
                    </div>
                    
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label>&nbsp;</label>
                        <button id="fetch-data" style="width: 100%;">Get Soil Temperature & Elevation</button>
                    </div>
                </div>
                
                <div class="map-container" id="map"></div>
                
                <div class="loading" id="loading">Fetching data from Open-Meteo API...</div>
            </div>
            
			<div class="content-container">
				<div class="graph-container">
					<div class="chart-header">
						<h3 class="graph-title">Data Visualization</h3>
						<div class="chart-controls">
							<div class="axis-selectors">
								<div class="axis-selector">
									<label for="y-axis">Y-Axis:</label>
									<select id="y-axis">
										<option value="elevationFt">Elevation (ft)</option>
										<option value="soilTemp">Soil Temperature (¬∞F)</option>
										<option value="soilMoisture">Soil Moisture</option>
										<option value="slopeDeg">Slope (degrees)</option>
										<option value="slopeAspectDeg">Aspect (degrees)</option>
										<option value="monthFraction">Date</option>
									</select>
								</div>
								<div class="axis-selector">
									<label for="x-axis">X-Axis:</label>
									<select id="x-axis">
										<option value="elevationFt">Elevation (ft)</option>
										<option value="soilTemp">Soil Temperature (¬∞F)</option>
										<option value="soilMoisture">Soil Moisture</option>
										<option value="slopeDeg">Slope (degrees)</option>
										<option value="slopeAspectDeg">Aspect (degrees)</option>
										<option value="monthFraction">Date</option>
									</select>
								</div>
							</div>
						</div>
					</div>
					<div class="chart-wrapper">
						<canvas id="mainChart"></canvas>
					</div>
				</div>
				
				<div class="graph-container">
					<div class="chart-header">
						<h3 class="graph-title">Distribution Histogram</h3>
						<div class="histogram-controls">
							<select id="histogram-dimension">
								<option value="elevationFt">Elevation (ft)</option>
								<option value="soilTemp">Soil Temperature (¬∞F)</option>
								<option value="soilMoisture">Soil Moisture</option>
								<option value="slopeDeg">Slope (degrees)</option>
								<option value="slopeAspectDeg">Aspect (degrees)</option>
								<option value="month">Month</option>
								<option value="yearMonth">Year-Month</option>
							</select>
							<label for="bin-count" style="font-size: 16px; margin-left: 5px;">Bins:</label>
							<input type="number" id="bin-count" min="5" max="100" value="30" style="width: 100px;">
							<label for="bin-offset" style="font-size: 16px; margin-left: 5px;">Offset:</label>
							<input type="number" id="bin-offset" min="0" max="100" value="0" style="width: 100px;">
						</div>
					</div>
					<div class="chart-wrapper">
						<canvas id="histogramChart"></canvas>
					</div>
				</div>
			</div>
            
            <div class="info-panel" id="info-panel">
                <h3 class="info-title">Observation Details</h3>
				<div class="soil-temp-chart-container" style="margin-top: 20px; display: none;" id="soil-temp-chart-container">
					<h4 style="color: #8B4513; margin-bottom: 15px;">Soil Temperature & Moisture Trend</h4>
					<div class="chart-wrapper" style="height: 200px;">
						<canvas id="soil-temp-chart"></canvas>
					</div>
				</div>
                <div class="info-content" id="info-content">
                    <!-- Details will be populated here when a point is clicked -->
                </div>
            </div>
			<div class="graph-container" style="grid-column: 1 / -1; width: 100%; margin-top: 25px;">
				<h3 class="graph-title">Data Table</h3>
				<div id="data-table-container" style="overflow-x: auto;">
					<table id="data-table" style="width: 100%; border-collapse: collapse;">
						<thead>
							<tr style="background-color: #8B4513; color: white; position: sticky; top: 0;">
								<th style="padding: 10px; text-align: center;">Dataset</th>
								<th style="padding: 10px; text-align: center;">Date</th>
								<th style="padding: 10px; text-align: center;">Elevation (ft)</th>
								<th style="padding: 10px; text-align: center;">Soil Temp (¬∞F)</th>
								<th style="padding: 10px; text-align: center;">Soil Moisture</th>
								<th style="padding: 10px; text-align: center;">Slope (deg)</th>
								<th style="padding: 10px; text-align: center;">Aspect (deg)</th>
							</tr>
						</thead>
						<tbody id="table-body">
							<!-- Data will be populated here -->
						</tbody>
					</table>
				</div>
			</div>
        </div>
    </div>
    
    <footer>
        <p>Data Sources: iNaturalist observations & Open-Meteo Historical Weather API</p>
        <p>Note: The Open-Meteo API provides soil temperature data with a spatial resolution of 9 km for recent years (IFS model) or 0.25¬∞ (~25 km) for historical data (ERA5 model).</p>
    </footer>

    <script>
        // Global variables
        let originalData = []; // Store all loaded NDJSON data
        let activeDatasets = {}; // Track active NDJSON files with their colors
        let userData = []; // User-added data points
        let allData = []; // Combined data from all sources
        let chartData = []; // Processed data for charts
        
		// Chart instances
		let mainChart, histogramChart;
        
        // Initialize map
        let map, marker, mapPoints = [];
        let currentView = 'default';
		let elevationRange = [0, 8000];
		let tempRange = [0, 100];
		let moistureRange = [0, 1];
		let slopeRange = [0, 90];
		let aspectRange = [0, 360];
		let monthRange = [1, 12];
		let highlightedPoint = null;
		let highlightedChartElements = [];
        
        // Settings
        let averageDays = 7;
        let tempDepth = '7_to_28cm';
        let moistureDepth = '7_to_28cm';

		let userPointColor = '#FF6B6B';
		let highlightColor = '#FFA500';
		let enableScroll = true;

		function clearUserPoints() {
			userData = [];
			
			// Update all charts
			if (mainChart && histogramChart) {
				updateCharts();
			}
			
			// Remove user points from map
			mapPoints.forEach((marker, index) => {
				if (marker._datasetId === 'user_data') {
					map.removeLayer(marker);
					// Don't splice while iterating - mark for removal
				}
			});
			
			// Filter out user markers
			mapPoints = mapPoints.filter(marker => marker._datasetId !== 'user_data');
			
			// Update data table
			populateDataTable();
			
			// Clear any highlights and info panel
			removeHighlights();
			document.getElementById('info-panel').classList.remove('active');
		}

		// Debouncer function
		function debounce(func, wait) {
			let timeout;
			return function executedFunction(...args) {
				const later = () => {
					clearTimeout(timeout);
					func(...args);
				};
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		}

		// Function to highlight a point across all visualizations
		function highlightPoint(point) {
			// Remove previous highlights
			removeHighlights();
			
			// Store the highlighted point
			highlightedPoint = point;
			
			// Highlight on map
			mapPoints.forEach(marker => {
				// Add null check
				if (!marker || !marker.setStyle) return;
				
				const latlng = marker.getLatLng();
				// Add null check for latlng
				if (!latlng) return;
				
				if (Math.abs(latlng.lat - point.latitude) < 0.0001 && 
					Math.abs(latlng.lng - point.longitude) < 0.0001) {
					
					// Check if this is a user point
					const isUserPoint = point.datasetId === 'user_data';
					
					if (isUserPoint) {
						// User points
						marker.setStyle({
							fillColor: userPointColor,
							color: userPointColor,
							fillOpacity: 0.9,
							weight: 3,
							radius: 7
						});
					} else {
						// Regular points
						marker.setStyle({
							fillColor: highlightColor,
							color: highlightColor,
							fillOpacity: 0.9,
							weight: 3,
							radius: 5
						});
					}
					
					marker.bringToFront();
				}
			});
			
			// Highlight on charts
			if (mainChart && mainChart.data && mainChart.data.datasets) {
				// Create a separate highlighted dataset for this point
				const observationId = point.observationUrl ? 
					point.observationUrl.split('/').pop() : 
					'User Point';
				const highlightDataset = {
					label: `Obs: ${observationId}`,
					data: [{
						x: point.x || point[getXProperty(mainChart)],
						y: point.y || point[getYProperty(mainChart)],
						...point
					}],
					backgroundColor: highlightColor,
					borderColor: highlightColor,
					borderWidth: 3,
					pointRadius: 8,
					pointHoverRadius: 10,
					order: -1,
					datasetId: 'highlighted_point'
				};
				
				// Check if highlight dataset already exists
				const existingIndex = mainChart.data.datasets.findIndex(ds => ds.datasetId === 'highlighted_point');
				if (existingIndex > -1) {
					mainChart.data.datasets[existingIndex] = highlightDataset;
				} else {
					mainChart.data.datasets.push(highlightDataset);
				}
				
				highlightedChartElements.push({
					chart: mainChart,
					datasetIndex: mainChart.data.datasets.length - 1
				});
				
				mainChart.update('none');
			}
		}

		// Function to remove all highlights
		function removeHighlights() {
			// Remove chart highlights
			highlightedChartElements.forEach(item => {
				if (item.chart && item.chart.data && item.chart.data.datasets) {
					// Remove the highlighted dataset
					const highlightIndex = item.chart.data.datasets.findIndex(ds => ds.datasetId === 'highlighted_point');
					if (highlightIndex > -1) {
						item.chart.data.datasets.splice(highlightIndex, 1);
						item.chart.update('none');
					}
				}
			});
			
			highlightedChartElements = [];
			highlightedPoint = null;
			
			// Simply update the map points to redraw them with original colors
			updateMapPoints();
		}

		// Function to save original marker styles
		function saveOriginalMarkerStyles() {
			mapPoints.forEach(marker => {
				if (!marker.options._originalFillColor) {
					marker.options._originalFillColor = marker.options.fillColor;
					marker.options._originalColor = marker.options.color;
				}
			});
		}

		// Helper function to get X property based on chart
		function getXProperty(chart) {
			if (chart === mainChart) {
				const xProp = document.getElementById('x-axis') ? document.getElementById('x-axis').value : 'soilTemp';
				return xProp;
			}
			return 'soilTemp';
		}

		// Helper function to get Y property based on chart
		function getYProperty(chart) {
			if (chart === mainChart) {
				const yProp = document.getElementById('y-axis') ? document.getElementById('y-axis').value : 'elevationFt';
				return yProp;
			}
			return 'elevationFt';
		}
        
        // Color scales
		const elevationColorScale = d3.scaleLinear()
			.domain([0, 1333, 2666, 4000, 5333, 6666, 8000])
			.range([
				'#6A0DAD', // Purple at 0 ft
				'#0000FF', // Blue at 1333 ft
				'#00FF00', // Green at 2666 ft
				'#FFA500', // Yellow at 4000 ft
				'#FFA500', // Orange at 5333 ft
				'#FF4500', // Red-Orange at 6666 ft
				'#FF0000'  // Red at 8000 ft
			]);

		const tempColorScale = d3.scaleLinear()
			.domain([45, 65])
			.range(['#0000FF', '#FF0000'])
			.interpolate(d3.interpolateHcl);

		const moistureColorScale = d3.scaleLinear()
			.domain([0.2, 0.4])
			.range(['#FFD700', '#00008B']); // Gold to Dark Blue

		// Slope degree color scale
		const slopeColorScale = d3.scaleLinear()
			.domain([0, 90])
			.range(['#00FF00', '#FF0000']) // Green to Red
			.interpolate(d3.interpolateHcl);

		// Slope aspect color scale (circular color scale for 0-360 degrees)
		const aspectColorScale = d3.scaleLinear()
			.domain([0, 90, 180, 270, 360])
			.range(['#FF0000', '#FFFF00', '#00FF00', '#0000FF', '#FF0000']); // Red->Yellow->Green->Blue->Red

        // Month colors
        const monthColors = [
            '#FF6B6B', // Jan - Deep Red
            '#FF8E53', // Feb - Orange-Red
            '#FFB347', // Mar - Orange
            '#FFD166', // Apr - Yellow-Orange
            '#A8E6CF', // May - Light Green
            '#7BC8A4', // Jun - Green
            '#4ECDC4', // Jul - Teal
            '#45B7D1', // Aug - Light Blue
            '#6C5CE7', // Sep - Purple
            '#A29BFE', // Oct - Lavender
            '#DDA0DD', // Nov - Plum
            '#FFB6C1'  // Dec - Pink
        ];
        
        // NDJSON directory structure
        const ndjsonStructure = {
            "Boletus_edulis": [
                "Washington_Boletus_edulis.ndjson",
                "Oregon_Boletus_edulis.ndjson"
            ],
            "Boletus_rex-veris": [
                "Washington_Boletus_rex-veris.ndjson",
                "Oregon_Boletus_rex-veris.ndjson"
            ]
        };
        
        // Default colors for NDJSON files
        const defaultColors = [
            '#8B4513', '#1E90FF', '#32CD32', '#FF4500', '#9370DB',
            '#FFD700', '#00CED1', '#FF69B4', '#9ACD32', '#FF6347'
        ];
        
        // Initialize NDJSON directory
		function initNdjsonDirectory() {
			const directoryContent = document.getElementById('ndjson-folder-structure');
			directoryContent.innerHTML = '';
			
			let colorIndex = 0;
			
			Object.keys(ndjsonStructure).forEach(folderName => {
				const folderDiv = document.createElement('div');
				folderDiv.className = 'folder';
				
				const folderHeader = document.createElement('div');
				folderHeader.className = 'folder-header';
				folderHeader.innerHTML = `
					<div class="folder-name">
						<i class="fas fa-folder"></i>
						${folderName}
					</div>
					<button class="toggle-btn folder-toggle">
						<i class="fas fa-chevron-down"></i> <!-- Changed to down for collapsed -->
					</button>
				`;
				
				const folderContent = document.createElement('div');
				folderContent.className = 'folder-content collapsed'; // Added 'collapsed' class by default
				
				ndjsonStructure[folderName].forEach(fileName => {
					const filePath = `ndjson/${folderName}/${fileName}`;
					const fileId = filePath.replace(/\//g, '_').replace(/\./g, '_');
					
					// Generate a color for this file
					const fileColor = defaultColors[colorIndex % defaultColors.length];
					colorIndex++;
					
					// Check if this is Washington_Boletus_edulis.ndjson to enable by default
					const isWashingtonEdulis = fileName === 'Washington_Boletus_edulis.ndjson';
					
					// Store initial state - enable Washington_Boletus_edulis.ndjson by default
					activeDatasets[fileId] = {
						active: isWashingtonEdulis, // Enable only Washington_Boletus_edulis.ndjson
						color: fileColor,
						filePath: filePath,
						fileName: fileName,
						folderName: folderName,
						data: []
					};
					
					const fileDiv = document.createElement('div');
					fileDiv.className = 'ndjson-file';
					fileDiv.dataset.fileId = fileId;
					
					// Set up toggle with checkmark if active by default
					const toggleActiveClass = isWashingtonEdulis ? 'active' : '';
					const checkmarkDisplay = isWashingtonEdulis ? 'block' : 'none';
					
					fileDiv.innerHTML = `
						<div class="file-toggle ${toggleActiveClass}" data-file-id="${fileId}">
							<i class="fas fa-check" style="font-size: 10px; display: ${checkmarkDisplay};"></i>
						</div>
						<div class="file-name" title="${fileName}">${fileName}</div>
						<div class="file-count">0</div>
						<div style="display: flex; align-items: center; gap: 5px;">
							<input type="color" class="color-picker" value="${fileColor.substring(0, 7)}" data-file-id="${fileId}" style="width: 24px; height: 24px;">
							<input type="range" class="alpha-slider" min="0" max="100" value="100" data-file-id="${fileId}" style="width: 60px;">
							<span class="alpha-percent" data-file-id="${fileId}" style="font-size: 11px; min-width: 25px;">100%</span>
						</div>
					`;
					
					folderContent.appendChild(fileDiv);
				});
				
				folderDiv.appendChild(folderHeader);
				folderDiv.appendChild(folderContent);
				directoryContent.appendChild(folderDiv);
				
				// Add toggle event for folder
				folderHeader.querySelector('.folder-toggle').addEventListener('click', function() {
					const icon = this.querySelector('i');
					folderContent.classList.toggle('collapsed');
					icon.classList.toggle('fa-chevron-up');
					icon.classList.toggle('fa-chevron-down');
				});
			});
			
			// Add event listeners for file toggles and color pickers
			document.querySelectorAll('.file-toggle').forEach(toggle => {
				toggle.addEventListener('click', function() {
					const fileId = this.dataset.fileId;
					const fileData = activeDatasets[fileId];
					
					fileData.active = !fileData.active;
					this.classList.toggle('active');
					this.querySelector('i').style.display = fileData.active ? 'block' : 'none';
					
					if (fileData.active && fileData.data.length === 0) {
						// Load the NDJSON file
						loadNdjsonFile(fileId, fileData.filePath).then(() => {
						});
					} else {
						// Just toggle visibility
						updateDataDisplay(false);
					}
				});
			});
			
			const debouncedUpdate = debounce((fileId) => {
				const colorPicker = document.querySelector(`.color-picker[data-file-id="${fileId}"]`);
				const alphaSlider = document.querySelector(`.alpha-slider[data-file-id="${fileId}"]`);
				const alphaPercent = document.querySelector(`.alpha-percent[data-file-id="${fileId}"]`);
				
				if (!colorPicker || !alphaSlider) return;
				
				const rgb = colorPicker.value;
				const alpha = parseInt(alphaSlider.value);
				const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
				
				// Update only the color in activeDatasets
				activeDatasets[fileId].color = rgb + alphaHex;
				
				if (alphaPercent) {
					alphaPercent.textContent = alpha + '%';
				}
				
				// Only update visual elements, not reprocess data
				updateDataDisplay(true); // true = visual update only
			}, 150); // 150ms debounce delay

			document.querySelectorAll('.color-picker, .alpha-slider').forEach(input => {
				input.addEventListener('input', function() {
					const fileId = this.dataset.fileId;
					debouncedUpdate(fileId);
				});
			});
			
			// Hide loading message
			document.getElementById('directory-loading').style.display = 'none';
		}
        
        // Load NDJSON file
        async function loadNdjsonFile(fileId, filePath) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filePath}: ${response.status}`);
                }
                
                const text = await response.text();
                const lines = text.trim().split('\n');
                const data = lines.map(line => JSON.parse(line));
                
                // Store the data
                activeDatasets[fileId].data = data;
                
                // Update count display
                const fileElement = document.querySelector(`.ndjson-file[data-file-id="${fileId}"]`);
                if (fileElement) {
                    fileElement.querySelector('.file-count').textContent = data.length;
                }
                
                // Update the display
                updateDataDisplay();
                
            } catch (error) {
                console.error(`Error loading NDJSON file ${filePath}:`, error);
                alert(`Error loading ${filePath}: ${error.message}`);
                
                // Deactivate the file
                activeDatasets[fileId].active = false;
                const toggle = document.querySelector(`.file-toggle[data-file-id="${fileId}"]`);
                if (toggle) {
                    toggle.classList.remove('active');
                    toggle.querySelector('i').style.display = 'none';
                }
            }
        }
        
        // Process NDJSON data based on current settings
		function processNdjsonData() {
			chartData = [];
			originalData = [];
			
			// Process each active NDJSON file
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				
				if (fileData.active && fileData.data.length > 0) {
					fileData.data.forEach(record => {
						// Calculate averages based on settings
						const daysToAverage = Math.min(averageDays, record.dates.length);
						const startIdx = record.dates.length - daysToAverage;
						
						// Get soil temperature data for selected depth
						const tempData = record.soil_temperature[tempDepth];
						const avgTemp = tempData && tempData.length > 0 ?
							tempData.slice(startIdx).reduce((sum, val) => sum + val, 0) / daysToAverage :
							null;
						
						// Get soil moisture data for selected depth
						const moistureData = record.soil_moisture[moistureDepth];
						const avgMoisture = moistureData && moistureData.length > 0 ?
							moistureData.slice(startIdx).reduce((sum, val) => sum + val, 0) / daysToAverage :
							null;
						
						// Parse date
						const date = new Date(record.date_used);
						const month = date.getMonth() + 1;
						const monthDay = date.getDate();
						const monthFraction = month + (monthDay / 31);
						
						// Create data point
						const dataPoint = {
							datasetId: fileId,
							datasetName: fileData.fileName,
							datasetColor: fileData.color,
							observationUrl: record.observation_url,
							date: record.date_used,
							coordinates: record.coordinates,
							elevationFt: record.aws_elevation_ft || record.elevation_ft, // Use aws_elevation_ft if available
							soilTemp: avgTemp,
							soilMoisture: avgMoisture,
							month: month,
							monthName: date.toLocaleString('default', { month: 'short' }),
							monthDay: monthDay,
							monthFraction: monthFraction,
							yearMonth: date.getFullYear() + '-' + String(month).padStart(2, '0'),
							latitude: parseFloat(record.coordinates.split(',')[0]),
							longitude: parseFloat(record.coordinates.split(',')[1]),
							slopeDeg: record.slope_deg, // Add slope degree
							slopeAspectDeg: record.slope_aspect_deg, // Add slope aspect
							rawData: record
						};
						
						chartData.push(dataPoint);
						originalData.push(dataPoint);
					});
				}
			});
			
			// Combine with user data
			allData = [...originalData, ...userData];
		}
        
        // Update all charts and map with current data
		function updateDataDisplay(updateVisualsOnlyFlag = false) {
			if (!updateVisualsOnlyFlag) {
				// Only process data if needed (when loading new files or changing settings)
				processNdjsonData();
				populateDataTable(); // Only needed when data changes
				updateCharts(); // Full chart update with new data
				updateHistogram(); // Update histogram with new data
				// Create map points with fresh data
				updateMapPoints(); // This will create the initial markers
			} else {
				// Just update colors/visuals
				updateChartColors();
				updateVisualsOnly(); // This will update histogram colors too
				// Only update map point colors if markers already exist
				if (mapPoints.length > 0) {
					updateMapPointColors();
				}
			}
		}
        
        // Initialize map
        function initMap() {
            map = L.map('map').setView([46.744487, -121.812952], 6);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            // Add click event to map (but not on controls)
			map.on('click', function(e) {
				const clickedElement = e.originalEvent.target;
                const isControl = clickedElement.closest('.map-controls') || 
                                 clickedElement.closest('.noUi-handle') ||
                                 clickedElement.closest('.fullscreen-btn');
                
                if (!isControl) {
                    document.getElementById('latitude').value = e.latlng.lat.toFixed(6);
                    document.getElementById('longitude').value = e.latlng.lng.toFixed(6);
                    
                    if (marker) {
                        map.removeLayer(marker);
                    }
                    marker = L.marker(e.latlng).addTo(map);
                }
            });
            
            // Create map controls
            const mapControls = L.control({position: 'topright'});
            mapControls.onAdd = function() {
                const div = L.DomUtil.create('div', 'map-controls');
                
                L.DomEvent.disableClickPropagation(div);
                
                // View options - updated to include soil moisture
				div.innerHTML = `
					<div class="view-options">
						<button class="active" data-view="default">Default</button>
						<button data-view="elevation">Elevation</button>
						<button data-view="temp">Soil Temp</button>
						<button data-view="moisture">Soil Moisture</button>
						<button data-view="slope">Slope</button>
						<button data-view="aspect">Aspect</button>
						<button data-view="month">Month</button>
					</div>
					<div id="elevation-slider" class="slider-container">
						<label>Elevation Range (ft)</label>
						<div id="elevation-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="elevation-min">0</span>
							<span>-</span>
							<span id="elevation-max">8000</span>
						</div>
					</div>
					<div id="temp-slider" class="slider-container">
						<label>Soil Temp Range (¬∞F)</label>
						<div id="temp-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="temp-min">30</span>
							<span>-</span>
							<span id="temp-max">70</span>
						</div>
					</div>
					<div id="moisture-slider" class="slider-container">
						<label>Soil Moisture Range</label>
						<div id="moisture-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="moisture-min">0</span>
							<span>-</span>
							<span id="moisture-max">0.5</span>
						</div>
					</div>
					<!-- Regular slope slider -->
					<div id="slope-slider" class="slider-container">
						<label>Slope Range (degrees)</label>
						<div id="slope-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="slope-min">0</span>
							<span>-</span>
							<span id="slope-max">90</span>
						</div>
					</div>
					<!-- Circular aspect slider -->
					<div id="aspect-slider" class="slider-container">
						<label>Aspect Range (degrees)</label>
						<div class="aspect-circular-container">
							<div class="aspect-inputs">
								<div class="aspect-input">
									<label>Start:</label>
									<input type="number" id="aspect-start" min="0" max="360" step="1" value="0">
									<span>¬∞</span>
								</div>
								<span>to</span>
								<div class="aspect-input">
									<label>End:</label>
									<input type="number" id="aspect-end" min="0" max="360" step="1" value="359">
									<span>¬∞</span>
								</div>
							</div>
							<div class="aspect-circle" id="aspect-circle">
								<div class="aspect-center"></div>
								
								<!-- Main compass directions -->
								<div class="aspect-compass north">N</div>
								<div class="aspect-compass east">E</div>
								<div class="aspect-compass south">S</div>
								<div class="aspect-compass west">W</div>
								
								<!-- Intermediate directions -->
								<div class="aspect-compass northeast">NE</div>
								<div class="aspect-compass southeast">SE</div>
								<div class="aspect-compass southwest">SW</div>
								<div class="aspect-compass northwest">NW</div>
								
								<!-- Degree markers -->
								<div class="aspect-degree zero">0¬∞</div>
								<div class="aspect-degree ninety">90¬∞</div>
								<div class="aspect-degree one-eighty">180¬∞</div>
								<div class="aspect-degree two-seventy">270¬∞</div>
								
								<!-- Selected range overlay -->
								<div class="aspect-selected-overlay" id="aspect-selected-overlay"></div>
								
								<!-- Handles -->
								<div class="aspect-handle start" id="aspect-handle-start"></div>
								<div class="aspect-handle end" id="aspect-handle-end"></div>
							</div>
						</div>
					</div>
					<div id="month-slider" class="slider-container">
						<label>Month Range</label>
						<div id="month-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="month-min">Jan</span>
							<span>-</span>
							<span id="month-max">Dec</span>
						</div>
					</div>
				`;
                
                // Fullscreen button
                const fullscreenBtn = L.DomUtil.create('button', 'fullscreen-btn', map.getContainer());
                fullscreenBtn.textContent = 'Fullscreen';
                L.DomEvent.on(fullscreenBtn, 'click', toggleFullscreen);
                L.DomEvent.disableClickPropagation(fullscreenBtn);
                
                // View option click handlers
                div.querySelectorAll('.view-options button').forEach(btn => {
					btn.addEventListener('click', function() {
						div.querySelectorAll('.view-options button').forEach(b => b.classList.remove('active'));
						this.classList.add('active');
						currentView = this.dataset.view;
						
						// Update slider backgrounds when view changes
						updateAllSliderBackgrounds();
						
						updateMapPoints();
					});
                });
                
                return div;
            };
            
            mapControls.addTo(map);
            
            // Initialize sliders
			setTimeout(() => {
				window.elevationSlider = createRangeSlider('elevation-slider-range', 0, 8000, [0, 8000], 100);
				window.tempSlider = createRangeSlider('temp-slider-range', 30, 70, [30, 70], 1);
				window.moistureSlider = createRangeSlider('moisture-slider-range', 0, 0.5, [0, 0.5], 0.01);
				window.slopeSlider = createRangeSlider('slope-slider-range', 0, 90, [0, 90], 1);
				window.monthSlider = createRangeSlider('month-slider-range', 1, 365, [1, 365], 1);
				
				// Initialize circular aspect slider
				initCircularAspectSlider();
				
				// Set initial gradient backgrounds
				updateSliderBackground(window.elevationSlider, 'elevation');
				updateSliderBackground(window.tempSlider, 'temp');
				updateSliderBackground(window.moistureSlider, 'moisture');
				updateSliderBackground(window.slopeSlider, 'slope');
				updateSliderBackground(window.monthSlider, 'month');
				
				// Existing slider update handlers...
				window.elevationSlider.on('update', function(values) {
					elevationRange = values.map(v => parseFloat(v));
					document.getElementById('elevation-min').textContent = Math.round(values[0]);
					document.getElementById('elevation-max').textContent = Math.round(values[1]);
					updateMapPoints();
				});
				
				window.tempSlider.on('update', function(values) {
					tempRange = values.map(v => parseFloat(v));
					document.getElementById('temp-min').textContent = Math.round(values[0]);
					document.getElementById('temp-max').textContent = Math.round(values[1]);
					updateMapPoints();
				});
				
				window.moistureSlider.on('update', function(values) {
					moistureRange = values.map(v => parseFloat(v));
					document.getElementById('moisture-min').textContent = parseFloat(values[0]).toFixed(2);
					document.getElementById('moisture-max').textContent = parseFloat(values[1]).toFixed(2);
					updateMapPoints();
				});
				
				window.slopeSlider.on('update', function(values) {
					slopeRange = values.map(v => parseFloat(v));
					document.getElementById('slope-min').textContent = Math.round(values[0]);
					document.getElementById('slope-max').textContent = Math.round(values[1]);
					updateMapPoints();
				});
				
				window.monthSlider.on('update', function(values) {
					monthRange = values.map(v => Math.round(parseFloat(v)));
					updateMonthLabels();
					updateMapPoints();
				});
				
				updateMonthLabels();
				updateMapPoints();
				
			}, 100);
        }

		function initCircularAspectSlider() {
			const circle = document.getElementById('aspect-circle');
			const startHandle = document.getElementById('aspect-handle-start');
			const endHandle = document.getElementById('aspect-handle-end');
			const startInput = document.getElementById('aspect-start');
			const endInput = document.getElementById('aspect-end');
			const selectedOverlay = document.getElementById('aspect-selected-overlay');
			
			if (!circle || !startHandle || !endHandle || !startInput || !endInput || !selectedOverlay) return;
			
			const radius = 100; // Half of 200px
			const centerX = 100;
			const centerY = 100;
			
			function updateHandlePosition(handle, angle) {
				const radians = (angle - 90) * (Math.PI / 180); // -90 to make 0¬∞ at top
				const x = centerX + radius * Math.cos(radians);
				const y = centerY + radius * Math.sin(radians);
				handle.style.left = x + 'px';
				handle.style.top = y + 'px';
			}
			
			function updateFromInputs() {
				let startAngle = parseFloat(startInput.value) || 0;
				let endAngle = parseFloat(endInput.value) || 360;
				
				// Normalize angles to 0-360
				startAngle = ((startAngle % 360) + 360) % 360;
				endAngle = ((endAngle % 360) + 360) % 360;
				
				// Update handle positions
				updateHandlePosition(startHandle, startAngle);
				updateHandlePosition(endHandle, endAngle);
				
				// Update aspect range
				aspectRange = [startAngle, endAngle];
				
				// Update the selected range visualization
				updateSelectedRange(startAngle, endAngle);
				
				// Update map points
				updateMapPoints();
			}
			
			function updateSelectedRange(start, end) {
				// Create a conic gradient for the selected range
				let gradientStops = '';
				
				if (end > start) {
					// Normal range (no wrap)
					gradientStops = `
						transparent 0deg,
						transparent ${start}deg,
						rgba(139, 69, 19, 0.3) ${start}deg,
						rgba(139, 69, 19, 0.3) ${end}deg,
						transparent ${end}deg,
						transparent 360deg
					`;
				} else {
					// Wrapped range (e.g., 300¬∞ to 60¬∞)
					gradientStops = `
						rgba(139, 69, 19, 0.3) 0deg,
						rgba(139, 69, 19, 0.3) ${end}deg,
						transparent ${end}deg,
						transparent ${start}deg,
						rgba(139, 69, 19, 0.3) ${start}deg,
						rgba(139, 69, 19, 0.3) 360deg
					`;
				}
				
				selectedOverlay.style.background = `conic-gradient(${gradientStops})`;
				
				// Add a border to the selected section
				selectedOverlay.style.border = '2px solid #8B4513';
				selectedOverlay.style.boxSizing = 'border-box';
			}
			
			function getAngleFromPosition(x, y) {
				const dx = x - centerX;
				const dy = y - centerY;
				let angle = Math.atan2(dy, dx) * (180 / Math.PI);
				angle = (angle + 90 + 360) % 360; // Rotate so 0¬∞ is at top
				return Math.round(angle);
			}
			
			function setupHandleDrag(handle, isStartHandle) {
				let isDragging = false;
				
				handle.addEventListener('mousedown', function(e) {
					e.stopPropagation();
					e.preventDefault();
					isDragging = true;
					document.addEventListener('mousemove', onMouseMove);
					document.addEventListener('mouseup', onMouseUp);
				});
				
				handle.addEventListener('touchstart', function(e) {
					e.stopPropagation();
					e.preventDefault();
					isDragging = true;
					document.addEventListener('touchmove', onTouchMove);
					document.addEventListener('touchend', onTouchEnd);
				});
				
				function onMouseMove(e) {
					if (!isDragging) return;
					
					const rect = circle.getBoundingClientRect();
					const x = e.clientX - rect.left;
					const y = e.clientY - rect.top;
					
					const angle = getAngleFromPosition(x, y);
					
					if (isStartHandle) {
						startInput.value = angle;
					} else {
						endInput.value = angle;
					}
					
					updateFromInputs();
				}
				
				function onTouchMove(e) {
					if (!isDragging || !e.touches[0]) return;
					
					const rect = circle.getBoundingClientRect();
					const x = e.touches[0].clientX - rect.left;
					const y = e.touches[0].clientY - rect.top;
					
					const angle = getAngleFromPosition(x, y);
					
					if (isStartHandle) {
						startInput.value = angle;
					} else {
						endInput.value = angle;
					}
					
					updateFromInputs();
				}
				
				function onMouseUp() {
					isDragging = false;
					document.removeEventListener('mousemove', onMouseMove);
					document.removeEventListener('mouseup', onMouseUp);
				}
				
				function onTouchEnd() {
					isDragging = false;
					document.removeEventListener('touchmove', onTouchMove);
					document.removeEventListener('touchend', onTouchEnd);
				}
			}
			
			// Initialize the base gradient (this should NOT change when handles move)
			function initBaseGradient() {
				// This creates a FIXED gradient that doesn't shift
				circle.style.background = `
					conic-gradient(
						from 0deg,
						#ff0000 0deg,
						#ffff00 90deg,
						#00ff00 180deg,
						#0000ff 270deg,
						#ff0000 360deg
					)
				`;
			}
			
			// Initialize everything
			initBaseGradient();
			updateFromInputs();
			
			// Setup drag for handles
			setupHandleDrag(startHandle, true);
			setupHandleDrag(endHandle, false);
			
			// Update on input changes
			startInput.addEventListener('change', updateFromInputs);
			endInput.addEventListener('change', updateFromInputs);
			startInput.addEventListener('input', updateFromInputs);
			endInput.addEventListener('input', updateFromInputs);
			
			// Add keyboard controls
			startInput.addEventListener('keydown', function(e) {
				if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
					e.preventDefault();
					const step = e.key === 'ArrowUp' ? 1 : -1;
					startInput.value = ((parseFloat(startInput.value) || 0) + step + 360) % 360;
					updateFromInputs();
				}
			});
			
			endInput.addEventListener('keydown', function(e) {
				if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
					e.preventDefault();
					const step = e.key === 'ArrowUp' ? 1 : -1;
					endInput.value = ((parseFloat(endInput.value) || 0) + step + 360) % 360;
					updateFromInputs();
				}
			});
		}

	// Helper function to update aspect circle handles
	function updateAspectCircleHandles(startAngle, endAngle) {
		const startHandle = document.getElementById('aspect-handle-start');
		const endHandle = document.getElementById('aspect-handle-end');
		const selectedOverlay = document.getElementById('aspect-selected-overlay');
		const circle = document.getElementById('aspect-circle');
		
		if (!startHandle || !endHandle || !selectedOverlay || !circle) return;
		
		const radius = 100;
		const centerX = 100;
		const centerY = 100;
		
		// Update handle positions
		function updateHandlePosition(handle, angle) {
			const radians = (angle - 90) * (Math.PI / 180);
			const x = centerX + radius * Math.cos(radians);
			const y = centerY + radius * Math.sin(radians);
			handle.style.left = x + 'px';
			handle.style.top = y + 'px';
		}
		
		updateHandlePosition(startHandle, startAngle);
		updateHandlePosition(endHandle, endAngle);
		
		// Update selected range visualization
		let gradientStops = '';
		
		if (endAngle > startAngle) {
			// Normal range (no wrap)
			gradientStops = `
				transparent 0deg,
				transparent ${startAngle}deg,
				rgba(139, 69, 19, 0.3) ${startAngle}deg,
				rgba(139, 69, 19, 0.3) ${endAngle}deg,
				transparent ${endAngle}deg,
				transparent 360deg
			`;
		} else {
			// Wrapped range (e.g., 300¬∞ to 60¬∞)
			gradientStops = `
				rgba(139, 69, 19, 0.3) 0deg,
				rgba(139, 69, 19, 0.3) ${endAngle}deg,
				transparent ${endAngle}deg,
				transparent ${startAngle}deg,
				rgba(139, 69, 19, 0.3) ${startAngle}deg,
				rgba(139, 69, 19, 0.3) 360deg
			`;
		}
		
		selectedOverlay.style.background = `conic-gradient(${gradientStops})`;
		selectedOverlay.style.border = '2px solid #8B4513';
		selectedOverlay.style.boxSizing = 'border-box';
		
		// Update global aspect range
		aspectRange = [startAngle, endAngle];
	}

		function updateAllSliderBackgrounds() {
			if (window.elevationSlider) updateSliderBackground(window.elevationSlider, 
				currentView === 'elevation' ? 'elevation' : 'default');
			if (window.tempSlider) updateSliderBackground(window.tempSlider, 
				currentView === 'temp' ? 'temp' : 'default');
			if (window.moistureSlider) updateSliderBackground(window.moistureSlider, 
				currentView === 'moisture' ? 'moisture' : 'default');
			if (window.slopeSlider) updateSliderBackground(window.slopeSlider, 
				currentView === 'slope' ? 'slope' : 'default');
			// Note: aspect slider doesn't use updateSliderBackground as it's circular
			if (window.monthSlider) updateSliderBackground(window.monthSlider, 
				currentView === 'month' ? 'month' : 'default');
		}
        
		function updateSliderBackground(slider, viewType) {
			const sliderElement = slider.target;
			const baseElement = sliderElement.querySelector('.noUi-base');
			
			if (!baseElement) return;
			
			switch(viewType) {
				case 'elevation':
					baseElement.style.background = 'linear-gradient(to right, #6A0DAD, #0000FF, #00FF00, #FFA500, #FFA500, #FF0000)';
					break;
				case 'temp':
					baseElement.style.background = 'linear-gradient(to right, #0000FF, #FF0000)';
					break;
				case 'moisture':
					baseElement.style.background = 'linear-gradient(to right, #FFD700, #00008B)';
					break;
				case 'slope':
					baseElement.style.background = 'linear-gradient(to right, #00FF00, #FF0000)';
					break;
				case 'aspect':
					baseElement.style.background = 'linear-gradient(to right, #FF0000, #FFFF00, #00FF00, #0000FF, #FF0000)';
					break;
				case 'month':
					// Create gradient that cycles through 12 months across 365 days
					const monthColors = [
						'#FF6B6B', '#FF8E53', '#FFB347', '#FFD166', // Jan-Apr
						'#A8E6CF', '#7BC8A4', '#4ECDC4', '#45B7D1', // May-Aug
						'#6C5CE7', '#A29BFE', '#DDA0DD', '#FFB6C1'  // Sep-Dec
					];
					
					// Create 12 color stops for the 12 months
					let gradientStops = '';
					for (let i = 0; i < 12; i++) {
						const position = (i / 12) * 100;
						gradientStops += `${monthColors[i]} ${position}%, `;
					}
					// Add the last color again at 100%
					gradientStops += `${monthColors[0]} 100%`;
					
					baseElement.style.background = `linear-gradient(to right, ${gradientStops})`;
					break;
				default:
					baseElement.style.background = '#f0f0f0';
			}
		}

        // Create range slider with two handles
		function createRangeSlider(id, min, max, values, step) {
			const slider = noUiSlider.create(document.getElementById(id), {
				start: values,
				connect: true,
				step: step,
				range: {
					'min': min,
					'max': max
				},
				behaviour: 'drag',
				tooltips: true,
				format: {
					to: function(value) {
						// Ensure value is a number before calling toFixed
						const numValue = typeof value === 'string' ? parseFloat(value) : value;
						return step < 1 ? numValue.toFixed(2) : Math.round(numValue);
					},
					from: function(value) {
						return Number(value);
					}
				}
			});
			return slider;
		}
        
		function updateMonthLabels() {
			const minDayElem = document.getElementById('month-min');
			const maxDayElem = document.getElementById('month-max');
			
			if (minDayElem && maxDayElem) {
				// Convert day number to month/day format
				const getMonthDay = (dayNum) => {
					// Days per month (non-leap year)
					const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
					const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
					
					let dayCount = dayNum;
					let month = 0;
					
					// Find which month this day falls in
					while (dayCount > daysInMonth[month]) {
						dayCount -= daysInMonth[month];
						month++;
						if (month >= 12) {
							month = 11; // Shouldn't happen with 1-365 range
							dayCount = daysInMonth[11];
							break;
						}
					}
					
					return `${monthNames[month]} ${Math.round(dayCount)}`;
				};
				
				minDayElem.textContent = getMonthDay(monthRange[0]);
				maxDayElem.textContent = getMonthDay(monthRange[1]);
			}
		}
        
		function updateMapPoints() {			
			// Clear existing points
			mapPoints.forEach(point => map.removeLayer(point));
			mapPoints = [];
			
			if (!currentView) {
				currentView = 'default';
			}
			
			// Show/hide sliders based on current view
			const elevationSlider = document.getElementById('elevation-slider');
			const tempSlider = document.getElementById('temp-slider');
			const moistureSlider = document.getElementById('moisture-slider');
			const slopeSlider = document.getElementById('slope-slider');
			const aspectSlider = document.getElementById('aspect-slider');
			const monthSlider = document.getElementById('month-slider');

			if (elevationSlider) elevationSlider.classList.toggle('active', currentView === 'elevation');
			if (tempSlider) tempSlider.classList.toggle('active', currentView === 'temp');
			if (moistureSlider) moistureSlider.classList.toggle('active', currentView === 'moisture');
			if (slopeSlider) slopeSlider.classList.toggle('active', currentView === 'slope');
			if (aspectSlider) aspectSlider.classList.toggle('active', currentView === 'aspect');
			if (monthSlider) monthSlider.classList.toggle('active', currentView === 'month');

			// Get current slider values when switching views
			if (currentView === 'elevation' && window.elevationSlider) {
				const values = window.elevationSlider.get();
				elevationRange = values.map(v => parseFloat(v));
			} else if (currentView === 'temp' && window.tempSlider) {
				const values = window.tempSlider.get();
				tempRange = values.map(v => parseFloat(v));
			} else if (currentView === 'moisture' && window.moistureSlider) {
				const values = window.moistureSlider.get();
				moistureRange = values.map(v => parseFloat(v));
			} else if (currentView === 'slope' && window.slopeSlider) {
				const values = window.slopeSlider.get();
				slopeRange = values.map(v => parseFloat(v));
			} else if (currentView === 'month' && window.monthSlider) {
				const values = window.monthSlider.get();
				monthRange = values.map(v => Math.round(parseFloat(v)));
				updateMonthLabels();
			}
			
			// If not in a filtered view, use default ranges
			if (currentView !== 'elevation') elevationRange = [0, 8000];
			if (currentView !== 'temp') tempRange = [30, 70];
			if (currentView !== 'moisture') moistureRange = [0, 0.5];
			if (currentView !== 'month') monthRange = [1, 12];
			
			// Plot points from all active datasets
			chartData.forEach(point => {
				// Filter based on ranges
				const inElevationRange = point.elevationFt >= elevationRange[0] && 
									  point.elevationFt <= elevationRange[1];
				const inTempRange = point.soilTemp !== null && 
								 point.soilTemp >= tempRange[0] && 
								 point.soilTemp <= tempRange[1];
				const inMoistureRange = point.soilMoisture !== null && 
									 point.soilMoisture >= moistureRange[0] && 
									 point.soilMoisture <= moistureRange[1];
				const inSlopeRange = point.slopeDeg !== null && 
								  point.slopeDeg !== undefined &&
								  point.slopeDeg >= slopeRange[0] && 
								  point.slopeDeg <= slopeRange[1];
				let inAspectRange = true;

				if (currentView === 'aspect') {
					const aspect = point.slopeAspectDeg;
					if (aspect !== null && aspect !== undefined) {
						const [start, end] = aspectRange;
						
						// Handle the wrap-around case
						if (end >= start) {
							// Normal range (e.g., 0¬∞ to 180¬∞)
							inAspectRange = aspect >= start && aspect <= end;
						} else {
							// Wrapped range (e.g., 300¬∞ to 60¬∞)
							inAspectRange = aspect >= start || aspect <= end;
						}
					} else {
						inAspectRange = false; // No aspect data
					}
				}

				let inMonthRange = true;
				if (currentView === 'month') {
					inMonthRange = isPointInDayRange(point, monthRange[0], monthRange[1]);
				}

				if (!inElevationRange || !inTempRange || !inMoistureRange || !inSlopeRange || !inAspectRange || !inMonthRange) return;
				
				// Get alpha/opacity from activeDatasets
				const datasetInfo = activeDatasets[point.datasetId];
				let opacity = 0.8; // default
				
				if (datasetInfo) {
					// Extract alpha from color string (if present)
					const color = datasetInfo.color;
					if (color.length === 9) { // #RRGGBBAA format
						const alphaHex = color.substring(7, 9);
						opacity = parseInt(alphaHex, 16) / 255;
					}
				}
				
				// Set color based on current view
				let color, fillColor;
				
				switch(currentView) {
					case 'elevation':
						color = elevationColorScale(point.elevationFt);
						fillColor = color;
						break;
					case 'temp':
						color = tempColorScale(point.soilTemp);
						fillColor = color;
						break;
					case 'moisture':
						color = moistureColorScale(point.soilMoisture);
						fillColor = color;
						break;
					case 'slope':
						color = slopeColorScale(point.slopeDeg);
						fillColor = color;
						break;
					case 'aspect':
						if (point.slopeAspectDeg !== null && point.slopeAspectDeg !== undefined) {
							// Normalize aspect to 0-360
							const normalizedAspect = ((point.slopeAspectDeg % 360) + 360) % 360;
							color = aspectColorScale(normalizedAspect);
							fillColor = color;
						} else {
							// No aspect data - use gray
							color = '#cccccc';
							fillColor = color;
						}
						break;
					case 'month':
						// Calculate day of year (1-365) from month and day
						const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
						let dayOfYear = 0;
						
						// Sum days from previous months
						for (let m = 0; m < point.month - 1; m++) {
							dayOfYear += daysInMonth[m];
						}
						
						// Add days in current month
						dayOfYear += point.monthDay;
						
						// Clamp to 1-365 range
						dayOfYear = Math.max(1, Math.min(365, dayOfYear));
						
						// Get position in year (0-1)
						const yearFraction = (dayOfYear - 1) / 364;
						
						// Get color from month gradient based on position
						const monthGradientColors = [
							'#FF6B6B', '#FF8E53', '#FFB347', '#FFD166', // Jan-Apr
							'#A8E6CF', '#7BC8A4', '#4ECDC4', '#45B7D1', // May-Aug
							'#6C5CE7', '#A29BFE', '#DDA0DD', '#FFB6C1'  // Sep-Dec
						];
						
						// Interpolate between month colors
						const gradientPos = yearFraction * 11; // 0-11 for 12 colors
						const colorIndex = Math.floor(gradientPos);
						const colorFraction = gradientPos - colorIndex;
						
						if (colorIndex < 11) {
							// Interpolate between two colors
							const startColor = monthGradientColors[colorIndex];
							const endColor = monthGradientColors[colorIndex + 1];
							color = interpolateColor(startColor, endColor, colorFraction);
						} else {
							color = monthGradientColors[11];
						}
						
						fillColor = color;
						break;
					default:
						// Use dataset color in default view
						color = datasetInfo ? datasetInfo.color : point.datasetColor;
						fillColor = color;
				}
				
				// Check if this is the currently highlighted point
				const isHighlighted = highlightedPoint && 
									  highlightedPoint.latitude === point.latitude && 
									  highlightedPoint.longitude === point.longitude;
				
				if (isHighlighted) {
					// Highlighted point - use highlight color with full opacity
					const marker = L.circleMarker([point.latitude, point.longitude], {
						radius: point.datasetId === 'user_data' ? 7 : 5,
						color: highlightColor,
						fillColor: highlightColor,
						fillOpacity: 0.9,
						weight: 3
					}).addTo(map);
					
					marker.on('click', () => {
						highlightPoint(point);
						showPointInfo(point);
					});
					mapPoints.push(marker);
				} else {
					// Regular point - use calculated color and opacity
					const marker = L.circleMarker([point.latitude, point.longitude], {
						radius: point.datasetId === 'user_data' ? 5 : 3,
						color: fillColor,
						fillColor: fillColor,
						fillOpacity: opacity, // Use the calculated opacity
						opacity: opacity,
						weight: point.datasetId === 'user_data' ? 2 : 0
					}).addTo(map);
					
					// Store dataset info for reference
					marker._datasetId = point.datasetId;
					
					marker.on('click', () => {
						highlightPoint(point);
						showPointInfo(point);
					});
					mapPoints.push(marker);
				}
			});
			
			// Plot user-added points
			if (userData.length > 0) {
				userData.forEach(point => {
					// Filter based on ranges
					const inElevationRange = point.elevationFt >= elevationRange[0] && 
										  point.elevationFt <= elevationRange[1];
					const inTempRange = point.soilTemp !== null && 
									 point.soilTemp >= tempRange[0] && 
									 point.soilTemp <= tempRange[1];
					const inMoistureRange = point.soilMoisture !== null && 
										 point.soilMoisture >= moistureRange[0] && 
										 point.soilMoisture <= moistureRange[1];
					let inMonthRange = true; // Default to true for non-month views
					if (currentView === 'month') {
						inMonthRange = isPointInDayRange(point, monthRange[0], monthRange[1]);
					}
					
					if (!inElevationRange || !inTempRange || !inMoistureRange || !inMonthRange) return;
					
					if (point.datasetId === 'user_data') {
						// User points
						const isHighlighted = highlightedPoint && 
											  highlightedPoint.latitude === point.latitude && 
											  highlightedPoint.longitude === point.longitude;
						
						if (isHighlighted) {
							// Highlighted user point
							const marker = L.circleMarker([point.latitude, point.longitude], {
								radius: 7,
								color: userPointColor,
								fillColor: userPointColor,
								fillOpacity: 0.9,
								weight: 3
							}).addTo(map);
							
							marker._datasetId = 'user_data';
							marker._isHighlighted = true;
							
							marker.on('click', (e) => {
								L.DomEvent.stopPropagation(e);
								highlightPoint(point);
								showPointInfo(point);
							});
							
							mapPoints.push(marker);
						} else {
							// Regular user point
							const marker = L.circleMarker([point.latitude, point.longitude], {
								radius: 5,
								color: userPointColor,
								fillColor: userPointColor,
								fillOpacity: 0.8,
								weight: 2,
								className: 'user-point-marker'
							}).addTo(map);
							
							marker._datasetId = 'user_data';
							marker._isHighlighted = false;
							
							marker.on('click', (e) => {
								L.DomEvent.stopPropagation(e);
								highlightPoint(point);
								showPointInfo(point);
							});
							
							mapPoints.push(marker);
						}
					}
				});
			}
		}

		function aspectToCompass(degrees) {
			const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
							   'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
			const index = Math.round((degrees % 360) / 22.5);
			return directions[index % 16];
		}

		function isPointInDayRange(point, startDay, endDay) {
			// Convert point's month/day to day of year
			const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
			let pointDayOfYear = 0;
			
			// Sum days from previous months
			for (let m = 0; m < point.month - 1; m++) {
				pointDayOfYear += daysInMonth[m];
			}
			
			// Add days in current month
			pointDayOfYear += point.monthDay;
			
			// Clamp to valid range
			pointDayOfYear = Math.max(1, Math.min(365, pointDayOfYear));
			
			// Check if point is within the day range
			return pointDayOfYear >= startDay && pointDayOfYear <= endDay;
		}

		function interpolateColor(color1, color2, factor) {
			// Convert hex to RGB
			const hexToRgb = (hex) => {
				const r = parseInt(hex.slice(1, 3), 16);
				const g = parseInt(hex.slice(3, 5), 16);
				const b = parseInt(hex.slice(5, 7), 16);
				return {r, g, b};
			};
			
			// RGB to hex
			const rgbToHex = (r, g, b) => {
				return '#' + [r, g, b].map(x => {
					const hex = Math.round(x).toString(16);
					return hex.length === 1 ? '0' + hex : hex;
				}).join('');
			};
			
			const rgb1 = hexToRgb(color1);
			const rgb2 = hexToRgb(color2);
			
			const r = rgb1.r + factor * (rgb2.r - rgb1.r);
			const g = rgb1.g + factor * (rgb2.g - rgb1.g);
			const b = rgb1.b + factor * (rgb2.b - rgb1.b);
			
			return rgbToHex(r, g, b);
		}
        
        function toggleFullscreen() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.fullscreenElement) {
                mapContainer.classList.add('fullscreen');
                if (mapContainer.requestFullscreen) {
                    mapContainer.requestFullscreen();
                }
                map.invalidateSize();
            } else {
                exitFullscreen();
            }
        }

        function exitFullscreen() {
            const mapContainer = document.querySelector('.map-container');
            
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            mapContainer.classList.remove('fullscreen');
            map.invalidateSize();
        }

        document.addEventListener('fullscreenchange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.fullscreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });

        document.addEventListener('webkitfullscreenchange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.webkitFullscreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });

        document.addEventListener('mozfullscreenchange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.mozFullScreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });

        document.addEventListener('MSFullscreenChange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.msFullscreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });
        
        // Initialize charts
		function initCharts() {
			const mainCtx = document.getElementById('mainChart').getContext('2d');
			const histogramCtx = document.getElementById('histogramChart').getContext('2d');
			
			// Main chart configuration
			mainChart = new Chart(mainCtx, {
				type: 'scatter',
				data: {
					datasets: []
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					elements: {
						point: {
							radius: 3,
							hoverRadius: 5,
							hitRadius: 10
						}
					},
					onClick: (evt, elements) => {
						if (elements.length > 0) {
							const element = elements[0];
							const datasetIndex = element.datasetIndex;
							const index = element.index;
							
							// Get the chart instance
							const chart = evt.chart;
							const dataset = chart.data.datasets[datasetIndex];
							
							if (dataset && dataset.data[index]) {
								// Get the original data point (not just x/y properties)
								const dataPoint = dataset.data[index];
								
								// Find the corresponding point in allData using the original properties
								// Look for a point with matching coordinates and date
								const originalPoint = allData.find(p => 
									p.latitude === dataPoint.latitude && 
									p.longitude === dataPoint.longitude &&
									p.date === dataPoint.date
								);
								
								if (originalPoint) {
									highlightPoint(originalPoint);
									showPointInfo(originalPoint);
								}
							}
						}
					},
					plugins: {
						legend: {
							display: true,
							position: 'top',
							align: 'center',
							labels: {
								boxWidth: 12,
								padding: 15,
								font: {
									size: 12,
									family: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
								},
								usePointStyle: true,
								pointStyle: 'circle',
								color: '#333'
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const dataPoint = context.dataset.data[context.dataIndex];
									const tooltipLines = [
										`Dataset: ${dataPoint.datasetName || 'User Data'}`,
										`Date: ${dataPoint.date || 'N/A'}`,
										`Elevation: ${dataPoint.elevationFt} ft`,
										`Soil Temp: ${dataPoint.soilTemp ? dataPoint.soilTemp.toFixed(1) : 'N/A'} ¬∞F`,
										`Soil Moisture: ${dataPoint.soilMoisture ? dataPoint.soilMoisture.toFixed(3) : 'N/A'}`
									];
									
									// Add slope if available
									if (dataPoint.slopeDeg !== null && dataPoint.slopeDeg !== undefined) {
										tooltipLines.push(`Slope: ${dataPoint.slopeDeg.toFixed(1)}¬∞`);
									}
									
									// Add aspect if available (with compass direction)
									if (dataPoint.slopeAspectDeg !== null && dataPoint.slopeAspectDeg !== undefined) {
										const compassDir = aspectToCompass(dataPoint.slopeAspectDeg);
										tooltipLines.push(`Aspect: ${dataPoint.slopeAspectDeg.toFixed(1)}¬∞ (${compassDir})`);
									}
									
									return tooltipLines;
								}
							}
						}
					},
					scales: {
						x: {
							title: {
								display: true,
								text: 'X-Axis',
								font: {
									weight: 'bold'
								}
							},
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						},
						y: {
							title: {
								display: true,
								text: 'Y-Axis',
								font: {
									weight: 'bold'
								}
							},
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						}
					}
				}
			});
			
			// Histogram chart configuration
			histogramChart = new Chart(histogramCtx, {
				type: 'bar',
				data: {
					labels: [],
					datasets: []
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					onClick: (evt, elements) => {
						if (elements.length > 0) {
							const element = elements[0];
							const chart = evt.chart;
							const dimension = document.getElementById('histogram-dimension').value;
							
							// Get the bin label
							const label = chart.data.labels[element.index];
							
							// For slope and aspect, ensure we have the full range
							if (dimension === 'slopeDeg' || dimension === 'slopeAspectDeg') {
								// Get the tooltip for better context
								const tooltip = chart.tooltip;
								if (tooltip && tooltip.dataPoints && tooltip.dataPoints.length > 0) {
									// Try to get the title from tooltip
									if (tooltip.title && tooltip.title.length > 0) {
										switchToMapViewFromHistogram(dimension, tooltip.title[0]);
									} else {
										// Use the label
										switchToMapViewFromHistogram(dimension, label);
									}
								} else {
									// Fallback
									switchToMapViewFromHistogram(dimension, label);
								}
							} else {
								// Original logic for other dimensions
								const tooltip = chart.tooltip;
								if (tooltip && tooltip.dataPoints && tooltip.dataPoints.length > 0) {
									const tooltipTitle = tooltip.title && tooltip.title.length > 0 
										? tooltip.title[0] 
										: null;
									
									if (tooltipTitle) {
										switchToMapViewFromHistogram(dimension, tooltipTitle);
									} else {
										switchToMapViewFromHistogram(dimension, label);
									}
								} else {
									switchToMapViewFromHistogram(dimension, label);
								}
							}
						}
					},
					plugins: {
						legend: {
							display: true,
							position: 'top'
						},
						tooltip: {
							mode: 'index',
							intersect: false,
							callbacks: {
								label: function(context) {
									const label = context.dataset.label || '';
									const value = context.parsed.y;
									const total = context.chart.data.datasets
										.map(ds => ds.data[context.dataIndex])
										.reduce((a, b) => a + b, 0);
									const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
									return `${label}: ${value} (${percentage}%)`;
								}
							}
						}
					},
					scales: {
						x: {
							stacked: true,
							title: {
								display: true,
								text: 'Value',
								font: {
									weight: 'bold'
								}
							},
							grid: {
								display: false
							}
						},
						y: {
							stacked: true,
							title: {
								display: true,
								text: 'Count',
								font: {
									weight: 'bold'
								}
							},
							beginAtZero: true,
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						}
					}
				}
			});
			
			// Set up chart type change listener
			document.getElementById('x-axis').addEventListener('change', updateMainChart);
			document.getElementById('y-axis').addEventListener('change', updateMainChart);
			
			// Set up histogram dimension change listener
			document.getElementById('histogram-dimension').addEventListener('change', updateHistogram);
			document.getElementById('bin-count').addEventListener('change', updateHistogram);
			document.getElementById('bin-offset').addEventListener('change', updateHistogram);
			
			// Set initial state
			setDefaultAxes();
		}

		function switchToMapViewFromHistogram(dimension, label) {
			// Map histogram dimensions to map views
			const dimensionToView = {
				'elevationFt': 'elevation',
				'soilTemp': 'temp',
				'soilMoisture': 'moisture',
				'slopeDeg': 'slope',
				'slopeAspectDeg': 'aspect',
				'month': 'month',
				'yearMonth': 'month'
			};
			
			const view = dimensionToView[dimension];
			if (!view) return;
			
			// Activate the corresponding view button
			const viewButtons = document.querySelectorAll('.view-options button');
			viewButtons.forEach(btn => {
				btn.classList.remove('active');
				if (btn.dataset.view === view) {
					btn.classList.add('active');
				}
			});
			
			// Set current view
			currentView = view;

			// Update all slider backgrounds for the new view
			updateAllSliderBackgrounds();
			
			// Parse the label to get range values
			let rangeValues = parseLabelToRange(dimension, label);
			
			if (rangeValues) {
				// Update the corresponding slider
				updateSliderFromRange(dimension, rangeValues);
			}
			
			// Update map points with new view
			updateMapPoints();
			
			// Scroll to map if enabled
			if (enableScroll) {
				document.getElementById('map').scrollIntoView({ behavior: 'smooth' });
			}
		}

		function parseLabelToRange(dimension, label) {
			// Parse histogram bin label to extract range values
			// Example labels: "1000 - 2000 ft", "Jan", "45 - 50 ¬∞F", "0.10 - 0.15"
			
			if (dimension === 'month') {
				// The label parameter contains the tooltip title, which is "Month - Week X"
				// Parse it to get month and week
				const match = label.match(/^(\w{3})\s*-\s*Week\s*(\d+)$/i);
				
				if (match) {
					const monthName = match[1];
					const weekNumber = parseInt(match[2]);
					
					const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
					const monthIndex = monthNames.indexOf(monthName);
					
					if (monthIndex !== -1 && weekNumber >= 1 && weekNumber <= 5) {
						// Convert month and week to day range
						const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
						let startDay = 1;
						
						// Sum days from previous months
						for (let m = 0; m < monthIndex; m++) {
							startDay += daysInMonth[m];
						}
						
						// Add days from previous weeks in this month
						startDay += (weekNumber - 1) * 7;
						
						// End day is start day + 6 (or end of month)
						const daysInThisMonth = daysInMonth[monthIndex];
						const remainingDays = daysInThisMonth - ((weekNumber - 1) * 7);
						const weekDays = Math.min(7, remainingDays);
						const endDay = startDay + weekDays - 1;
						
						return [startDay, endDay];
					}
				}
				
				// Fallback: If we can't parse week info, use the whole month
				const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
								   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
				const monthIndex = monthNames.indexOf(label);
				
				if (monthIndex !== -1) {
					// When clicking on a month label, show the full month
					const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
					let startDay = 1;
					
					// Sum days from previous months
					for (let m = 0; m < monthIndex; m++) {
						startDay += daysInMonth[m];
					}
					
					const endDay = startDay + daysInMonth[monthIndex] - 1;
					return [startDay, endDay];
				}
			} else if (dimension === 'yearMonth') {
				// Handle year-month labels like "2023-01"
				const [year, month] = label.split('-').map(Number);
				if (month) {
					return [month, month]; // Single month range
				}
			} else if (dimension === 'slopeDeg' || dimension === 'slopeAspectDeg') {
				// Handle slope and aspect dimensions
				// Labels might be: "0 - 10", "10 - 20", "30 - 40 degrees", etc.
				
				// Remove any units or extra text
				const cleanLabel = label.replace(/degrees|¬∞|deg/gi, '').trim();
				
				// Try to extract numeric range
				const rangeMatch = cleanLabel.match(/([\d\.]+)\s*-\s*([\d\.]+)/);
				if (rangeMatch) {
					let min = parseFloat(rangeMatch[1]);
					let max = parseFloat(rangeMatch[2]);
					
					// For aspect, ensure values are within 0-360
					if (dimension === 'slopeAspectDeg') {
						min = ((min % 360) + 360) % 360;
						max = ((max % 360) + 360) % 360;
						
						// For aspect, we might want to handle the circular nature
						// For simplicity, just return the range as is
						// The map filtering logic will handle wrap-around
					}
					
					return [min, max];
				}
				
				// If no range found, try to parse single value
				const singleMatch = cleanLabel.match(/^([\d\.]+)$/);
				if (singleMatch) {
					let value = parseFloat(singleMatch[1]);
					
					if (dimension === 'slopeAspectDeg') {
						value = ((value % 360) + 360) % 360;
					}
					
					// Create a small range around the single value
					if (dimension === 'slopeDeg') {
						return [Math.max(0, value - 5), Math.min(90, value + 5)];
					} else {
						// For aspect, create a 20-degree range
						const range = 10;
						return [
							((value - range) % 360 + 360) % 360,
							((value + range) % 360 + 360) % 360
						];
					}
				}
			} else {
				// Handle numeric ranges for other dimensions
				const rangeMatch = label.match(/([\d\.]+)\s*-\s*([\d\.]+)/);
				if (rangeMatch) {
					let min = parseFloat(rangeMatch[1]);
					let max = parseFloat(rangeMatch[2]);
					
					// Adjust for ft vs elevation values
					if (dimension === 'elevationFt' && label.includes('ft')) {
						// Already in correct units
					}
					
					return [min, max];
				}
			}
			
			return null;
		}

		function updateSliderFromRange(dimension, rangeValues) {
			const [minValue, maxValue] = rangeValues;
			
			// Show the corresponding slider container
			const sliderContainers = {
				'elevationFt': 'elevation-slider',
				'soilTemp': 'temp-slider',
				'soilMoisture': 'moisture-slider',
				'slopeDeg': 'slope-slider',
				'slopeAspectDeg': 'aspect-slider',
				'month': 'month-slider',
				'yearMonth': 'month-slider'
			};
			
			const sliderId = sliderContainers[dimension];
			if (!sliderId) return;
			
			// Activate the slider container
			const allSliders = ['elevation-slider', 'temp-slider', 'moisture-slider', 
							   'slope-slider', 'aspect-slider', 'month-slider']; // UPDATED
			allSliders.forEach(id => {
				const el = document.getElementById(id);
				if (el) el.classList.remove('active');
			});
			
			const targetSlider = document.getElementById(sliderId);
			if (targetSlider) {
				targetSlider.classList.add('active');
			}
			
			// Update the slider values
			switch(dimension) {
				case 'elevationFt':
					if (window.elevationSlider) {
						window.elevationSlider.set([minValue, maxValue]);
						elevationRange = [minValue, maxValue];
					}
					break;
				case 'soilTemp':
					if (window.tempSlider) {
						window.tempSlider.set([minValue, maxValue]);
						tempRange = [minValue, maxValue];
					}
					break;
				case 'soilMoisture':
					if (window.moistureSlider) {
						window.moistureSlider.set([minValue, maxValue]);
						moistureRange = [minValue, maxValue];
					}
					break;
				case 'slopeDeg':
					if (window.slopeSlider) {
						// Ensure values are within 0-90
						const clampedMin = Math.max(0, Math.min(90, minValue));
						const clampedMax = Math.max(0, Math.min(90, maxValue));
						window.slopeSlider.set([clampedMin, clampedMax]);
						slopeRange = [clampedMin, clampedMax];
					}
					break;
				case 'slopeAspectDeg':
					// For the circular aspect slider, update the input fields
					const startInput = document.getElementById('aspect-start');
					const endInput = document.getElementById('aspect-end');
					
					if (startInput && endInput) {
						// Normalize to 0-360
						const normalizedMin = ((minValue % 360) + 360) % 360;
						const normalizedMax = ((maxValue % 360) + 360) % 360;
						
						startInput.value = Math.round(normalizedMin);
						endInput.value = Math.round(normalizedMax);
						
						// Update the handles manually
						updateAspectCircleHandles(normalizedMin, normalizedMax);
					}
					break;
				case 'month':
				case 'yearMonth':
					if (window.monthSlider) {
						window.monthSlider.set([minValue, maxValue]);
						monthRange = [minValue, maxValue];
						updateMonthLabels();
					}
					break;
			}
		}

		// Set default axis selections
		function setDefaultAxes() {
			document.getElementById('x-axis').value = 'soilTemp';
			document.getElementById('y-axis').value = 'elevationFt';
			updateMainChart();
		}

		// Update main chart based on selections
		function updateMainChart() {
			const xProp = document.getElementById('x-axis').value;
			const yProp = document.getElementById('y-axis').value;
			
			// Update axis labels based on selection
			const axisLabels = {
				'soilTemp': 'Soil Temperature (¬∞F)',
				'soilMoisture': 'Soil Moisture',
				'monthFraction': 'Month',
				'elevationFt': 'Elevation (ft)',
				'slopeDeg': 'Slope (degrees)',
				'slopeAspectDeg': 'Aspect (degrees)'
			};
			
			mainChart.options.scales.x.title.text = axisLabels[xProp] || 'X-Axis';
			mainChart.options.scales.y.title.text = axisLabels[yProp] || 'Y-Axis';
			
			// Special handling for month axis
			if (xProp === 'monthFraction') {
				mainChart.options.scales.x.ticks = {
					callback: function(value) {
						const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
						const monthIndex = Math.floor(value) - 1;
						if (monthIndex >= 0 && monthIndex < 12) {
							return months[monthIndex];
						}
						return '';
					},
					stepSize: 1,
					autoSkip: false,
					maxRotation: 45,
					minRotation: 0,
					padding: 5
				};
				mainChart.options.scales.x.min = 1;
				mainChart.options.scales.x.max = 13;
			} else if (xProp === 'elevationFt') {
				// Set elevation max to 8000
				mainChart.options.scales.x.max = 8000;
				mainChart.options.scales.x.ticks = {};
				mainChart.options.scales.x.min = 0;
			} else {
				mainChart.options.scales.x.ticks = {};
				mainChart.options.scales.x.min = undefined;
				mainChart.options.scales.x.max = undefined;
			}

			if (yProp === 'monthFraction') {
				mainChart.options.scales.y.ticks = {
					callback: function(value) {
						const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
						const monthIndex = Math.floor(value) - 1;
						if (monthIndex >= 0 && monthIndex < 12) {
							return months[monthIndex];
						}
						return '';
					},
					stepSize: 1
				};
				mainChart.options.scales.y.min = 1;
				mainChart.options.scales.y.max = 13;
			} else if (yProp === 'elevationFt') {
				// Set elevation max to 8000
				mainChart.options.scales.y.max = 8000;
				mainChart.options.scales.y.ticks = {};
				mainChart.options.scales.y.min = 0;
			} else {
				mainChart.options.scales.y.ticks = {};
				mainChart.options.scales.y.min = undefined;
				mainChart.options.scales.y.max = undefined;
			}
			
			// Update chart data
			updateChartData(xProp, yProp);
			updateChartColors();
		}

		// Update chart data
		function updateChartData(xProp, yProp) {
			// Group data by dataset
			const datasetsMap = {};
			
			chartData.forEach(point => {
				if (!datasetsMap[point.datasetId]) {
					datasetsMap[point.datasetId] = {
						label: point.datasetName,
						data: [],
						backgroundColor: point.datasetColor,
						borderColor: point.datasetColor,
						borderWidth: 1,
						pointRadius: 3,
						pointHoverRadius: 4,
						datasetId: point.datasetId
					};
				}
				
				datasetsMap[point.datasetId].data.push(point);
			});
			
			// Convert to array
			const datasets = Object.values(datasetsMap);
			
			// Add user data if exists
			if (userData.length > 0) {
				datasets.push({
					label: 'Your Added Point',
					data: userData,
					backgroundColor: userPointColor,
					borderColor: userPointColor,
					borderWidth: 3,
					pointRadius: 8,
					pointHoverRadius: 10,
					order: 0,
					datasetId: 'user_data'
				});
			}
			
			// Add highlighted point dataset if exists
			if (highlightedPoint) {
				const highlightDataset = {
					label: `Obs: ${highlightedPoint.observationUrl ? highlightedPoint.observationUrl.split('/').pop() : 'User Point'}`,
					data: [{
						x: highlightedPoint[xProp],
						y: highlightedPoint[yProp],
						...highlightedPoint
					}],
					backgroundColor: highlightColor,
					borderColor: highlightColor,
					borderWidth: 3,
					pointRadius: 8,
					pointHoverRadius: 10,
					order: -1,
					datasetId: 'highlighted_point'
				};
				
				datasets.push(highlightDataset);
			}
			
			// Prepare datasets with filtered data
			mainChart.data.datasets = datasets.map(dataset => {
				// Skip highlighted dataset - it already has the right data
				if (dataset.datasetId === 'highlighted_point') {
					return dataset;
				}
				
				const filteredData = dataset.data
					.filter(point => point[xProp] !== null && point[yProp] !== null)
					.map(point => ({
						x: point[xProp],
						y: point[yProp],
						...point // Include all point properties
					}));
				
				return {
					...dataset,
					data: filteredData,
					pointRadius: dataset.datasetId === 'user_data' ? 8 : 3,
					pointHoverRadius: dataset.datasetId === 'user_data' ? 10 : 5,
					order: dataset.datasetId === 'user_data' ? 0 : 1
				};
			});
			
			mainChart.update();
		}

		// Helper function to get week number in a month (1-5)
		function getWeekInMonth(date) {
			const month = date.getMonth();
			const year = date.getFullYear();
			const day = date.getDate();
			
			// First day of the month
			const firstDay = new Date(year, month, 1);
			const firstDayOfWeek = firstDay.getDay(); // 0 = Sunday
			
			// Calculate which week of the month (1-5)
			return Math.ceil((day + firstDayOfWeek) / 7);
		}

		// Update histogram
		function updateHistogram() {
			const dimension = document.getElementById('histogram-dimension').value;
			const binCount = parseInt(document.getElementById('bin-count').value) || 15;
			const binOffset = parseInt(document.getElementById('bin-offset').value) || 0;

			// Reset x-axis ticks if not month dimension
			if (dimension !== 'month') {
				histogramChart.options.scales.x.ticks = {};
				histogramChart.options.plugins.tooltip.callbacks = {
					label: function(context) {
						const label = context.dataset.label || '';
						const value = context.parsed.y;
						const total = context.chart.data.datasets
							.map(ds => ds.data[context.dataIndex])
							.reduce((a, b) => a + b, 0);
						const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
						return `${label}: ${value} (${percentage}%)`;
					}
				};
			}
			
			// Get all active datasets
			const activeDatasetIds = Object.keys(activeDatasets).filter(id => activeDatasets[id].active);
			
			// Special handling for month and yearMonth dimensions
			if (dimension === 'month') {
				// For months split into weeks, create 60 bins (12 months √ó 5 weeks)
				const weekBins = Array(60).fill(0);
				const datasetsData = {};
				
				// Initialize data structure for each dataset
				activeDatasetIds.forEach(id => {
					datasetsData[id] = Array(60).fill(0);
				});
				
				// Count values per dataset per week
				allData.forEach(point => {
					if (point.date) {
						try {
							const date = new Date(point.date);
							const month = date.getMonth(); // 0-11
							const week = getWeekInMonth(date); // 1-5
							
							// Calculate bin index: (month * 5) + (week - 1)
							const binIndex = (month * 5) + (week - 1);
							
							if (binIndex >= 0 && binIndex < 60) {
								weekBins[binIndex]++;
								if (point.datasetId && datasetsData[point.datasetId]) {
									datasetsData[point.datasetId][binIndex]++;
								}
							}
						} catch (e) {
							console.error('Error parsing date:', point.date, e);
						}
					}
				});
				
				// Create month labels (one per month, not per week)
				const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
								   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
				const monthLabels = monthNames;
				
				// Apply offset
				let finalWeekLabels = [];
				let finalDatasetsData = {};

				// Create detailed week labels for tooltips
				for (let month = 0; month < 12; month++) {
					for (let week = 1; week <= 5; week++) {
						finalWeekLabels.push(`Week ${week}`);
					}
				}

				// Apply offset to the data (skip first N weeks)
				const startIndex = binOffset * 5; // Convert months to weeks (5 weeks per month)
				const totalWeeks = 60;

				activeDatasetIds.forEach(id => {
					// Get the weekly data
					const weeklyData = datasetsData[id] || Array(60).fill(0);
					
					// Apply offset by slicing the data
					const slicedData = weeklyData.slice(startIndex);
					
					// Store the sliced data
					finalDatasetsData[id] = slicedData;
				});

				// Apply same offset to labels
				const slicedWeekLabels = finalWeekLabels.slice(startIndex);

				// Update histogram with sliced data
				histogramChart.data.labels = slicedWeekLabels;
				histogramChart.data.datasets = [];

				// Create datasets for chart
				activeDatasetIds.forEach(id => {
					const datasetInfo = activeDatasets[id];
					histogramChart.data.datasets.push({
						label: datasetInfo.fileName,
						data: finalDatasetsData[id] || Array(slicedWeekLabels.length).fill(0),
						backgroundColor: datasetInfo.color,
						borderColor: datasetInfo.color,
						borderWidth: 1
					});
				});

				// Customize x-axis to show month names instead of week numbers
				histogramChart.options.scales.x.ticks = {
					callback: function(value, index, ticks) {
						// Calculate the original week index (accounting for offset)
						const originalIndex = index + startIndex;
						// Group every 5 weeks into a month
						const monthIndex = Math.floor(originalIndex / 5);
						const weekInMonth = originalIndex % 5;
						
						// Show month name in the middle week (week 3) of each month
						if (weekInMonth === 2) { // Week 3 (0-indexed: 0=W1, 1=W2, 2=W3, 3=W4, 4=W5)
							return monthNames[monthIndex] || '';
						}
						
						// Add a small tick mark at the start of each month (optional)
						if (weekInMonth === 0) {
							// You can return a small character or just empty string
							return '|';
						}
						
						return ''; // Don't show week numbers on x-axis
					},
					autoSkip: false,
					maxRotation: 0,
					padding: 10,
					// Add minor ticks between weeks
					minor: {
						enabled: true
					}
				};

				// Add grid lines between months for better visualization
				histogramChart.options.scales.x.grid = {
					...histogramChart.options.scales.x.grid,
					color: function(context) {
						// Calculate the original week index (accounting for offset)
						const originalIndex = context.index + startIndex;
						const weekInMonth = originalIndex % 5;
						
						// Draw a thicker line at the start of each month (between months)
						if (weekInMonth === 0 && context.index > 0) {
							return 'rgba(0, 0, 0, 0.3)'; // Darker line between months
						}
						
						// Draw medium line between weeks
						return 'rgba(0, 0, 0, 0.1)'; // Lighter line between weeks
					},
					lineWidth: function(context) {
						// Calculate the original week index (accounting for offset)
						const originalIndex = context.index + startIndex;
						const weekInMonth = originalIndex % 5;
						
						// Thicker line at month boundaries
						if (weekInMonth === 0 && context.index > 0) {
							return 2;
						}
						
						// Normal line between weeks
						return 1;
					}
				};
				
				// Customize tooltip to show week number
				histogramChart.options.plugins.tooltip.callbacks = {
					...histogramChart.options.plugins.tooltip.callbacks,
					title: function(context) {
						// Get the index of the hovered bar (accounting for offset)
						const index = context[0].dataIndex + startIndex;
						const monthIndex = Math.floor(index / 5);
						const weekNumber = (index % 5) + 1;
						return `${monthNames[monthIndex]} - Week ${weekNumber}`;
					},
					label: function(context) {
						const label = context.dataset.label || '';
						const value = context.parsed.y;
						const total = context.chart.data.datasets
							.map(ds => ds.data[context.dataIndex])
							.reduce((a, b) => a + b, 0);
						const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
						return `${label}: ${value} (${percentage}%)`;
					}
				};
				
			} else if (dimension === 'yearMonth') {
				// For year-month, group by unique values
				const uniqueValues = [...new Set(allData
					.filter(point => point[dimension] !== null && point[dimension] !== undefined)
					.map(point => point[dimension]))].sort();
				
				const datasetsData = {};
				
				// Initialize data structure for each dataset
				activeDatasetIds.forEach(id => {
					datasetsData[id] = Array(uniqueValues.length).fill(0);
				});
				
				// Count values per dataset
				allData.forEach(point => {
					if (point[dimension] !== null && point[dimension] !== undefined) {
						const valueIndex = uniqueValues.indexOf(point[dimension]);
						if (valueIndex !== -1) {
							if (point.datasetId && datasetsData[point.datasetId]) {
								datasetsData[point.datasetId][valueIndex]++;
							}
						}
					}
				});
				
				// Apply offset
				let finalLabels = uniqueValues;
				let finalDatasetsData = datasetsData;
				if (binOffset > 0) {
					finalLabels = uniqueValues.slice(binOffset);
					Object.keys(datasetsData).forEach(id => {
						finalDatasetsData[id] = datasetsData[id].slice(binOffset);
					});
				}
				
				// Create datasets for chart
				const datasets = [];
				activeDatasetIds.forEach(id => {
					const datasetInfo = activeDatasets[id];
					datasets.push({
						label: datasetInfo.fileName,
						data: finalDatasetsData[id] || Array(finalLabels.length).fill(0),
						backgroundColor: datasetInfo.color,
						borderColor: datasetInfo.color,
						borderWidth: 1
					});
				});
				
				// Update histogram
				histogramChart.data.labels = finalLabels;
				histogramChart.data.datasets = datasets;
				
			} else {
				// For numeric dimensions, create bins
				const values = allData
					.filter(point => point[dimension] !== null && point[dimension] !== undefined)
					.map(point => point[dimension]);
				
				if (values.length === 0) {
					histogramChart.data.labels = ['No data'];
					histogramChart.data.datasets = [];
					histogramChart.update();
					return;
				}
				
				const min = Math.min(...values);
				const max = Math.max(...values);
				const binSize = (max - min) / binCount;
				
				const datasetsData = {};
				
				// Initialize data structure for each dataset
				activeDatasetIds.forEach(id => {
					datasetsData[id] = Array(binCount).fill(0);
				});
				
				// Count values per dataset per bin
				allData.forEach(point => {
					if (point[dimension] !== null && point[dimension] !== undefined) {
						let binIndex = Math.floor((point[dimension] - min) / binSize);
						if (binIndex === binCount) binIndex = binCount - 1; // Handle edge case
						
						if (point.datasetId && datasetsData[point.datasetId]) {
							datasetsData[point.datasetId][binIndex]++;
						}
					}
				});
				
				// Create labels for bins with better formatting
				const labels = [];
				for (let i = 0; i < binCount; i++) {
					const binStart = min + (i * binSize);
					const binEnd = min + ((i + 1) * binSize);
					
					// Format based on dimension type
					if (dimension === 'elevationFt') {
						// Round to nearest 100 for clean numbers
						const roundedStart = Math.round(binStart / 100) * 100;
						const roundedEnd = Math.round(binEnd / 100) * 100;
						labels.push(`${roundedStart} - ${roundedEnd} ft`);
					} else if (dimension === 'soilTemp') {
						labels.push(`${Math.round(binStart)} - ${Math.round(binEnd)} ¬∞F`);
					} else if (dimension === 'soilMoisture') {
						labels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`);
					} else if (dimension === 'slopeDeg') {
						// Slope: Show rounded values and categorize
						const start = Math.round(binStart);
						const end = Math.round(binEnd);
						let slopeCategory = '';
						
						if (end <= 10) slopeCategory = ' (Gentle)';
						else if (end <= 20) slopeCategory = ' (Moderate)';
						else if (end <= 30) slopeCategory = ' (Steep)';
						else slopeCategory = ' (Very Steep)';
						
						labels.push(`${start} - ${end}¬∞${slopeCategory}`);
					} else if (dimension === 'slopeAspectDeg') {
						// Aspect: Show degrees and compass direction
						const start = Math.round(binStart);
						const end = Math.round(binEnd);
						
						// Convert to compass direction for the middle of the range
						const midPoint = (start + end) / 2;
						const compassDir = aspectToCompass(midPoint);
						
						labels.push(`${start} - ${end}¬∞ (${compassDir})`);
					} else {
						labels.push(`${binStart.toFixed(1)} - ${binEnd.toFixed(1)}`);
					}
				}
				
				// Apply offset
				let finalLabels = labels;
				let finalDatasetsData = datasetsData;
				if (binOffset > 0) {
					finalLabels = labels.slice(binOffset);
					Object.keys(datasetsData).forEach(id => {
						finalDatasetsData[id] = datasetsData[id].slice(binOffset);
					});
				}
				
				// Create datasets for chart
				const datasets = [];
				activeDatasetIds.forEach(id => {
					const datasetInfo = activeDatasets[id];
					datasets.push({
						label: datasetInfo.fileName,
						data: finalDatasetsData[id] || Array(finalLabels.length).fill(0),
						backgroundColor: datasetInfo.color,
						borderColor: datasetInfo.color,
						borderWidth: 1
					});
				});
				
				// Update histogram
				histogramChart.data.labels = finalLabels;
				histogramChart.data.datasets = datasets;
			}
			
			// Update axis label
			const dimensionLabels = {
				'elevationFt': 'Elevation (ft)',
				'soilTemp': 'Soil Temperature (¬∞F)',
				'soilMoisture': 'Soil Moisture',
				'slopeDeg': 'Slope (degrees)',
				'slopeAspectDeg': 'Aspect (degrees)',
				'month': 'Month',
				'yearMonth': 'Year-Month'
			};
			
			histogramChart.options.scales.x.title.text = dimensionLabels[dimension] || 'Value';
			histogramChart.update();
		}
        
		function updateVisualsOnly() {
			// Save current highlight state
			const currentHighlight = highlightedPoint;
			
			// Update main chart colors
			updateChartColors();
			
			// Update histogram colors
			if (histogramChart && histogramChart.data && histogramChart.data.datasets) {
				let needsUpdate = false;
				
				histogramChart.data.datasets.forEach(dataset => {
					// Find the corresponding dataset in activeDatasets
					const datasetId = Object.keys(activeDatasets).find(id => 
						activeDatasets[id].fileName === dataset.label
					);
					
					if (datasetId && activeDatasets[datasetId]) {
						const newColor = activeDatasets[datasetId].color;
						// Only update if color changed
						if (dataset.backgroundColor !== newColor) {
							dataset.backgroundColor = newColor;
							dataset.borderColor = newColor;
							needsUpdate = true;
						}
					}
				});
				
				// Only update if colors changed
				if (needsUpdate) {
					histogramChart.update();
				}
			}
			
			// Update map point colors if markers exist
			if (mapPoints.length > 0) {
				updateMapPointColors();
			}
			
			// Restore highlight if there was one
			if (currentHighlight) {
				setTimeout(() => {
					highlightPoint(currentHighlight);
				}, 50);
			}
		}

		function updateChartColors() {
			// Update main chart colors
			if (mainChart && mainChart.data && mainChart.data.datasets) {
				mainChart.data.datasets.forEach(dataset => {
					// Skip if no data or no datasetId
					if (!dataset.data || dataset.data.length === 0) return;
					
					// Skip highlighted datasets
					if (dataset.datasetId === 'highlighted_point') return;
					
					// Get the datasetId from the first data point
					const firstPoint = dataset.data[0];
					if (!firstPoint) return;
					
					if (firstPoint.datasetId === 'user_data') {
						// User data
						dataset.backgroundColor = userPointColor;
						dataset.borderColor = userPointColor;
					} else if (firstPoint.datasetId && activeDatasets[firstPoint.datasetId]) {
						// NDJSON dataset
						dataset.backgroundColor = activeDatasets[firstPoint.datasetId].color;
						dataset.borderColor = activeDatasets[firstPoint.datasetId].color;
					}
				});
				
				mainChart.update('none');
			}
		}

		function updateMapPointColors() {
			// If no markers exist yet, return early
			if (mapPoints.length === 0) return;
			
			// Save current highlight state
			const currentHighlight = highlightedPoint;
			
			// First, remove all highlights temporarily
			removeHighlights();
			
			// If we're in a view mode, completely redraw map points with correct colors
			if (currentView && currentView !== 'default') {
				updateMapPoints(); // This will recreate all points with correct view-based colors
			} else {
				// In default mode, update existing markers with new colors
				mapPoints.forEach(marker => {
					const datasetId = marker._datasetId;
					
					// Handle user data points
					if (datasetId === 'user_data') {
						marker.setStyle({
							color: userPointColor,
							fillColor: userPointColor,
							fillOpacity: 0.8,
							weight: 2,
							radius: 5
						});
						return;
					}
					
					if (datasetId && activeDatasets[datasetId]) {
						const datasetInfo = activeDatasets[datasetId];
						const color = datasetInfo.color;
						
						// Extract alpha from color string
						let fillOpacity = 0.8; // default
						if (color.length === 9) { // #RRGGBBAA format
							const alphaHex = color.substring(7, 9);
							fillOpacity = parseInt(alphaHex, 16) / 255;
						}
						
						marker.setStyle({
							color: color,
							fillColor: color,
							fillOpacity: fillOpacity,
							weight: 0,
							radius: 3
						});
					} else {
						// Try to find the marker's corresponding data point
						const latlng = marker.getLatLng();
						
						// Look for user data points that match this marker's location
						const userPoint = userData.find(point => 
							Math.abs(point.latitude - latlng.lat) < 0.0001 && 
							Math.abs(point.longitude - latlng.lng) < 0.0001
						);
						
						if (userPoint) {
							// This is a user point
							marker.setStyle({
								color: userPointColor,
								fillColor: userPointColor,
								fillOpacity: 0.8,
								weight: 2,
								radius: 5
							});
							// Update the datasetId for future reference
							marker._datasetId = 'user_data';
						}
					}
				});
			}
			
			// Re-apply highlight if there was one
			if (currentHighlight) {
				// Use a small delay to ensure markers are recreated
				setTimeout(() => {
					highlightPoint(currentHighlight);
				}, 100);
			}
		}

        // Update charts with current data
		function updateCharts() {
			// Get current axis selections
			const xProp = document.getElementById('x-axis').value;
			const yProp = document.getElementById('y-axis').value;
			
			updateChartData(xProp, yProp);
			updateHistogram();
		}
        
        // Populate data table
        function populateDataTable() {
            const tableBody = document.getElementById('table-body');
            tableBody.innerHTML = '';
            
            allData.forEach(point => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #eee';
                row.style.cursor = 'pointer';
                
                row.onclick = function() {
                    showPointInfo(point);
                };
                
                // Highlight user-added data
                if (userData.includes(point)) {
                    row.style.backgroundColor = '#FFF5F5';
                }
                
				row.innerHTML = `
					<td style="padding: 10px; text-align: center;">${point.datasetName || 'User Data'}</td>
					<td style="padding: 10px; text-align: center;">${point.date}</td>
					<td style="padding: 10px; text-align: center;">${point.elevationFt}</td>
					<td style="padding: 10px; text-align: center;">${point.soilTemp ? point.soilTemp.toFixed(1) : 'N/A'}</td>
					<td style="padding: 10px; text-align: center;">${point.soilMoisture ? point.soilMoisture.toFixed(3) : 'N/A'}</td>
					<td style="padding: 10px; text-align: center;">${point.slopeDeg ? point.slopeDeg.toFixed(1) : 'N/A'}</td>
					<td style="padding: 10px; text-align: center;">${point.slopeAspectDeg ? point.slopeAspectDeg.toFixed(1) : 'N/A'}</td>
				`;
                
                tableBody.appendChild(row);
            });
        }
        
        // Show point information in the info panel
		async function showPointInfo(point) {
			highlightPoint(point);
			const infoPanel = document.getElementById('info-panel');
			const infoContent = document.getElementById('info-content');
			const soilTempChartContainer = document.getElementById('soil-temp-chart-container');
			
			const observationLink = point.observationUrl || '#';
			const apiUrl = point.rawData ? point.rawData.open_meteo_api_url : point.openMeteoApiUrl || '#';
			const docsUrl = point.rawData ? point.rawData.open_meteo_docs_url : point.openMeteoDocsUrl || '#';
			
			const slopeHTML =
				point.slopeDeg != null
					? `
					<div class="info-item">
						<span class="info-label">Slope:</span> ${point.slopeDeg.toFixed(1)}¬∞
					</div>`
					: '';

			const aspectHTML =
				point.slopeAspectDeg != null
					? `
					<div class="info-item">
						<span class="info-label">Aspect:</span>
						${point.slopeAspectDeg.toFixed(1)}¬∞ (${aspectToCompass(point.slopeAspectDeg)})
					</div>`
					: '';

			infoContent.innerHTML = `
				<div class="info-item">
					<span class="info-label">Dataset:</span> ${point.datasetName || 'User Data'}
				</div>
				<div class="info-item">
					<span class="info-label">Date:</span> ${point.date || 'N/A'}
				</div>
				<div class="info-item">
					<span class="info-label">Coordinates:</span> ${point.coordinates}
				</div>
				<div class="info-item">
					<span class="info-label">Elevation:</span> ${point.elevationFt} ft
				</div>
				<div class="info-item">
					<span class="info-label">Avg Soil Temp (${averageDays} days):</span>
					${point.soilTemp ? point.soilTemp.toFixed(1) : 'N/A'} ¬∞F (${tempDepth})
				</div>
				<div class="info-item">
					<span class="info-label">Avg Soil Moisture (${averageDays} days):</span>
					${point.soilMoisture ? point.soilMoisture.toFixed(3) : 'N/A'} (${moistureDepth})
				</div>
				${slopeHTML}
				${aspectHTML}
				<div class="info-item">
					<span class="info-label">Observation Link:</span>
					<a href="${observationLink}" target="_blank" class="link">${observationLink}</a>
				</div>
				<div class="info-item">
					<span class="info-label">Open-Meteo Docs:</span>
					<a href="${docsUrl}" target="_blank" class="link">
						https://open-meteo.com/docs...
					</a>
				</div>
			`;
			
			infoPanel.classList.add('active');

			// Display soil temperature and moisture chart from NDJSON data if available
			if (point.rawData && point.rawData.dates && point.rawData.soil_temperature && point.rawData.soil_moisture) {
				displaySoilTempMoistureChart(point.rawData, point);
			} else if (apiUrl && apiUrl !== '#') {
				// Fall back to API for user-added points
				try {
					const response = await fetch(apiUrl);
					if (response.ok) {
						const data = await response.json();
						displaySoilTempMoistureChart(data, point);
					}
				} catch (error) {
					console.error('Error fetching soil temperature data:', error);
				}
			}
			
			if (enableScroll) {
				infoPanel.scrollIntoView({ behavior: 'smooth' });
			}
		}
        
        // Create the soil temperature and moisture chart from NDJSON data
		function displaySoilTempMoistureChart(data, point) {
			const ctx = document.getElementById('soil-temp-chart').getContext('2d');
			const soilTempChartContainer = document.getElementById('soil-temp-chart-container');
			
			// Update the chart title to show the current average days
			const chartTitle = soilTempChartContainer.querySelector('h4');
			if (chartTitle) {
				chartTitle.textContent = `Soil Temperature & Moisture Trend (Last ${averageDays} Days)`;
			}
			
			if (window.soilTempChart) {
				window.soilTempChart.destroy();
			}
			
			let dates, temps, moistures;
			
			// Check if this is NDJSON data (has dates array) or API data (has daily.time)
			if (data.dates && data.soil_temperature && data.soil_moisture) {
				// NDJSON data structure
				dates = data.dates;
				
				// Get temperature data for the selected depth
				switch(tempDepth) {
					case '0_to_7cm':
						temps = data.soil_temperature['0_to_7cm'];
						break;
					case '7_to_28cm':
						temps = data.soil_temperature['7_to_28cm'];
						break;
					case '28_to_100cm':
						temps = data.soil_temperature['28_to_100cm'];
						break;
					case '0_to_100cm':
						temps = data.soil_temperature['0_to_100cm'];
						break;
					default:
						temps = data.soil_temperature['7_to_28cm'];
				}
				
				// Get moisture data for the selected depth
				switch(moistureDepth) {
					case '0_to_7cm':
						moistures = data.soil_moisture['0_to_7cm'];
						break;
					case '7_to_28cm':
						moistures = data.soil_moisture['7_to_28cm'];
						break;
					case '28_to_100cm':
						moistures = data.soil_moisture['28_to_100cm'];
						break;
					case '0_to_100cm':
						moistures = data.soil_moisture['0_to_100cm'];
						break;
					default:
						moistures = data.soil_moisture['7_to_28cm'];
				}
				
			} else if (data.daily) {
				// API data structure
				dates = data.daily.time;
				
				// Get temperature data for the selected depth
				switch(tempDepth) {
					case '0_to_7cm':
						temps = data.daily.soil_temperature_0_to_7cm_mean;
						break;
					case '7_to_28cm':
						temps = data.daily.soil_temperature_7_to_28cm_mean;
						break;
					case '28_to_100cm':
						temps = data.daily.soil_temperature_28_to_100cm_mean;
						break;
					case '0_to_100cm':
						temps = data.daily.soil_temperature_0_to_100cm_mean;
						break;
					default:
						temps = data.daily.soil_temperature_7_to_28cm_mean;
				}
				
				// Get moisture data for the selected depth
				switch(moistureDepth) {
					case '0_to_7cm':
						moistures = data.daily.soil_moisture_0_to_7cm_mean;
						break;
					case '7_to_28cm':
						moistures = data.daily.soil_moisture_7_to_28cm_mean;
						break;
					case '28_to_100cm':
						moistures = data.daily.soil_moisture_28_to_100cm_mean;
						break;
					case '0_to_100cm':
						moistures = data.daily.soil_moisture_0_to_100cm_mean;
						break;
					default:
						moistures = data.daily.soil_moisture_7_to_28cm_mean;
				}
			} else {
				console.error('Unknown data structure:', data);
				return;
			}
			
			// LIMIT DATA TO ONLY THE LAST averageDays
			const daysToShow = Math.min(averageDays, dates.length);
			const startIdx = dates.length - daysToShow;
			
			// Slice the arrays to only show the specified number of days
			dates = dates.slice(startIdx);
			temps = temps.slice(startIdx);
			moistures = moistures.slice(startIdx);
			
			// Format dates
			const formattedDates = dates.map(dateStr => {
				const d = new Date(dateStr);
				return `${d.getMonth() + 1}/${d.getDate()}`;
			});
			
			// Calculate averages based on the sliced data
			const avgTemp = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
			const avgMoisture = moistures.reduce((sum, moisture) => sum + moisture, 0) / moistures.length;
			
			// Make sure container is visible before creating chart
			soilTempChartContainer.style.display = 'block';
			
			// Create chart with two Y-axes
			window.soilTempChart = new Chart(ctx, {
				type: 'line',
				data: {
					labels: formattedDates,
					datasets: [
						{
							label: `Soil Temperature (${tempDepth}) ¬∞F`,
							data: temps,
							borderColor: '#8B4513',
							backgroundColor: 'rgba(139, 69, 19, 0.1)',
							borderWidth: 2,
							fill: true,
							tension: 0.3,
							yAxisID: 'y-temp'
						},
						{
							label: `Soil Moisture (${moistureDepth})`,
							data: moistures,
							borderColor: '#1E90FF',
							backgroundColor: 'rgba(30, 144, 255, 0.1)',
							borderWidth: 2,
							fill: true,
							tension: 0.3,
							yAxisID: 'y-moisture'
						},
						{
							label: 'Avg Temp',
							data: temps.map(() => avgTemp),
							borderColor: '#8B4513',
							borderWidth: 1,
							borderDash: [5, 5],
							fill: false,
							pointRadius: 0,
							yAxisID: 'y-temp'
						},
						{
							label: 'Avg Moisture',
							data: moistures.map(() => avgMoisture),
							borderColor: '#1E90FF',
							borderWidth: 1,
							borderDash: [5, 5],
							fill: false,
							pointRadius: 0,
							yAxisID: 'y-moisture'
						}
					]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							display: true,
							position: 'top',
							labels: {
								boxWidth: 12,
								padding: 10,
								font: {
									size: 11
								}
							}
						},
						tooltip: {
							mode: 'index',
							intersect: false,
							callbacks: {
								label: function(context) {
									let label = context.dataset.label || '';
									if (label) {
										label += ': ';
									}
									if (context.dataset.label.includes('Temperature')) {
										label += context.parsed.y.toFixed(1) + '¬∞F';
									} else if (context.dataset.label.includes('Moisture')) {
										label += context.parsed.y.toFixed(3);
									} else {
										label += context.parsed.y.toFixed(2);
									}
									return label;
								}
							}
						}
					},
					scales: {
						x: {
							title: {
								display: true,
								text: `Date`
							},
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						},
						'y-temp': {
							type: 'linear',
							display: true,
							position: 'left',
							title: {
								display: true,
								text: 'Temperature (¬∞F)',
								color: '#8B4513'
							},
							ticks: {
								color: '#8B4513'
							},
							grid: {
								drawOnChartArea: false
							}
						},
						'y-moisture': {
							type: 'linear',
							display: true,
							position: 'right',
							title: {
								display: true,
								text: 'Soil Moisture',
								color: '#1E90FF'
							},
							ticks: {
								color: '#1E90FF'
							},
							grid: {
								drawOnChartArea: false
							}
						}
					}
				}
			});
			
			// Force chart to update after a tiny delay to ensure container is visible
			setTimeout(() => {
				if (window.soilTempChart) {
					window.soilTempChart.update();
				}
			}, 50);
		}
        
        // Fetch data from Open-Meteo API for user-added points
        async function fetchOpenMeteoData(latitude, longitude, date) {
			removeHighlights();
            const loadingDiv = document.getElementById('loading');
            loadingDiv.style.display = 'block';
            
            try {
                const observationDate = new Date(date);
                const startDate = new Date(observationDate);
                startDate.setDate(observationDate.getDate() - averageDays);
                
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = observationDate.toISOString().split('T')[0];
                
                const apiUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${latitude}&longitude=${longitude}&start_date=${startDateStr}&end_date=${endDateStr}&daily=soil_temperature_0_to_7cm_mean,soil_temperature_7_to_28cm_mean,soil_temperature_28_to_100cm_mean,soil_temperature_0_to_100cm_mean,soil_moisture_0_to_7cm_mean,soil_moisture_7_to_28cm_mean,soil_moisture_28_to_100cm_mean,soil_moisture_0_to_100cm_mean&timezone=America%2FLos_Angeles&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`;
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Calculate averages for all depths
                const depthAverages = {};
                
                // Temperature averages
                ['0_to_7cm', '7_to_28cm', '28_to_100cm', '0_to_100cm'].forEach(depth => {
                    const key = `soil_temperature_${depth}_mean`;
                    if (data.daily[key]) {
                        const temps = data.daily[key];
                        depthAverages[`temp_${depth}`] = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
                    }
                });
                
                // Moisture averages
                ['0_to_7cm', '7_to_28cm', '28_to_100cm', '0_to_100cm'].forEach(depth => {
                    const key = `soil_moisture_${depth}_mean`;
                    if (data.daily[key]) {
                        const moistures = data.daily[key];
                        depthAverages[`moisture_${depth}`] = moistures.reduce((sum, moisture) => sum + moisture, 0) / moistures.length;
                    }
                });
                
                // Get elevation
                const elevation = data.elevation;
                const elevationFt = elevation * 3.28084;
                
                // Extract date components
                const dayOfMonth = observationDate.getDate();
                const monthFraction = observationDate.getMonth() + (dayOfMonth / 31);
                
                // Create new data point
                const newPoint = {
                    datasetId: 'user_data',
                    datasetName: 'User Data',
                    datasetColor: userPointColor,
                    observationUrl: '#',
                    date: endDateStr,
                    coordinates: `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`,
                    elevationFt: Math.round(elevationFt),
                    soilTemp: depthAverages[`temp_${tempDepth}`],
                    soilMoisture: depthAverages[`moisture_${moistureDepth}`],
                    month: observationDate.getMonth() + 1,
                    monthName: observationDate.toLocaleString('default', { month: 'short' }),
                    monthDay: dayOfMonth,
                    monthFraction: monthFraction,
                    yearMonth: observationDate.getFullYear() + '-' + 
                                String(observationDate.getMonth() + 1).padStart(2, '0'),
                    latitude: latitude,
                    longitude: longitude,
                    openMeteoApiUrl: apiUrl,
                    openMeteoDocsUrl: apiUrl.replace('archive-api.open-meteo.com/v1/archive', 'open-meteo.com/en/docs/historical-weather-api'),
                    depthAverages: depthAverages
                };
                
                // Clear previous user data and add new point
                userData = [newPoint];
                allData = [...originalData, ...userData];
                
				updateCharts(); // Just update charts with current data
				updateChartColors();
				populateDataTable(); // Update table

				// Update map points to include the new user point
				updateMapPoints();
                
                // Show info for the new point
                showPointInfo(newPoint);
				removeHighlights();
                
            } catch (error) {
                console.error('Error fetching Open-Meteo data:', error);
                alert(`Error fetching data: ${error.message}\n\nNote: The Open-Meteo API may not have data for the selected date range or location. Try a different date or coordinates.`);
            } finally {
                loadingDiv.style.display = 'none';
            }
        }
        
        // Initialize the application
		document.addEventListener('DOMContentLoaded', async function() {
			try {
				// Initialize NDJSON directory
				initNdjsonDirectory();
				
				// Initialize the rest of the application
				initMap();
				initCharts();

				// Set default chart type
				setTimeout(() => {
					setDefaultAxes();
					updateHistogram();
				}, 100);
				
				// Load Washington_Boletus_edulis.ndjson automatically since it's enabled by default
				setTimeout(() => {
					// Find the Washington_Boletus_edulis.ndjson file
					const washingtonEdulisId = Object.keys(activeDatasets).find(key => 
						activeDatasets[key].fileName === 'Washington_Boletus_edulis.ndjson'
					);
					
					if (washingtonEdulisId && activeDatasets[washingtonEdulisId].active) {
						loadNdjsonFile(washingtonEdulisId, activeDatasets[washingtonEdulisId].filePath).then(() => {
							// After loading data, create the map points
							updateMapPoints();
						});
					}
				}, 500); // Small delay to ensure everything is initialized
				
				// Add event listener for the fetch data button
				document.getElementById('fetch-data').addEventListener('click', function() {
					const latitude = parseFloat(document.getElementById('latitude').value);
					const longitude = parseFloat(document.getElementById('longitude').value);
					const date = document.getElementById('date').value;
					
					if (isNaN(latitude) || isNaN(longitude)) {
						alert('Please enter valid latitude and longitude values.');
						return;
					}
					
					if (!date) {
						alert('Please select a date.');
						return;
					}
					
					fetchOpenMeteoData(latitude, longitude, date);
				});
				
				// Add event listener for Enter key in input fields
				document.getElementById('latitude').addEventListener('keypress', function(e) {
					if (e.key === 'Enter') {
						document.getElementById('fetch-data').click();
					}
				});
				
				document.getElementById('longitude').addEventListener('keypress', function(e) {
					if (e.key === 'Enter') {
						document.getElementById('fetch-data').click();
					}
				});

				document.getElementById('user-point-color').addEventListener('change', function(e) {
					userPointColor = e.target.value;
					if (userData.length > 0) {
						userData[0].datasetColor = userPointColor;
						// Pass true to preserve highlights
						updateVisualsOnly();
						
						// Also update the user data array
						userData.forEach(point => {
							point.datasetColor = userPointColor;
						});
					}
				});
				
				document.getElementById('highlight-color').addEventListener('change', function(e) {
					highlightColor = e.target.value;
					// Re-apply highlight if there's a highlighted point
					if (highlightedPoint) {
						const tempPoint = highlightedPoint;
						removeHighlights();
						highlightPoint(tempPoint);
					}
				});
				
				document.getElementById('clear-user-points').addEventListener('click', clearUserPoints);
				
				document.getElementById('disable-scroll').addEventListener('change', function(e) {
					enableScroll = e.target.checked;
				});
				
				// Set default date to current date
				const today = new Date();
				const todayFormatted = today.toISOString().split('T')[0];
				document.getElementById('date').value = todayFormatted;
				
				// Apply settings button
				document.getElementById('apply-settings').addEventListener('click', function() {
					averageDays = parseInt(document.getElementById('average-days').value);
					tempDepth = document.getElementById('temp-depth').value;
					moistureDepth = document.getElementById('moisture-depth').value;
					updateDataDisplay(false); // false = full reprocessing needed
				});
				
				// Initialize with default settings
				setTimeout(() => {
					if (typeof updateMapPoints === 'function') {
						updateMapPoints();
					}
				}, 200);
				
			} catch (error) {
				console.error('Error initializing application:', error);
				alert('Error initializing application. Please check the console for details.');
			}
		});
    </script>
</body>
</html>
