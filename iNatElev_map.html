<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Map of iNaturalist Observations" />
<title>Map of iNaturalist Observations</title>
<style>
   body { height:100vh; width:100vw; margin:0px; font:10pt Sans-Serif;}
   #mapid { height:100vh; width:100vw; position:absolute; top:0vh; left:0vw; background:darkgray; }
   #info { padding:15px; }
   h1 { margin-top:0px; }
   a { text-decoration:none; }
   
   /* Search Controls */
   .search-controls {
      position: absolute;
      top: 10px;
      left: 50px;
      z-index: 1000;
      background: white;
      padding: 30px 10px 10px 10px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      max-width: 300px;
      min-width: 250px;
      transition: all 0.3s ease;
   }
   
   .search-controls.minimized {
      max-width: 20px;
      min-width: 20px;
      height: 20px;
      overflow: hidden;
      padding: 5px 5px 5px 5px;
   }
   
   .search-controls.minimized *:not(.close-btn) {
      display: none !important;
   }
   
   .primary-filters {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
   }
   
   .ac-chooser {
      position: relative;
      flex: 1;
   }
   
   .ac-chooser input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
   }
   
   /* Autocomplete styling */
   .ui-autocomplete {
      position: absolute;
      z-index: 1002;
      max-height: 300px;
      overflow-y: auto;
      overflow-x: hidden;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      width: 100%;
   }
   
   .ui-menu-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
   }
   
   .ui-menu-item:hover {
      background-color: #f5f5f5;
   }
   
   .ui-menu-item.active {
      background-color: #e9e9e9;
   }
   
   .ac-result {
      display: flex;
      align-items: center;
      gap: 10px;
   }
   
   .ac-thumb {
      width: 40px;
      height: 40px;
      flex-shrink: 0;
   }
   
   .ac-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 3px;
   }
   
   .ac-label {
      flex: 1;
   }
   
   .ac-label .title {
      font-weight: bold;
      display: block;
   }
   
   .ac-label .subtitle {
      font-size: 11px;
      color: #666;
      font-style: italic;
   }
   
   .ac-view {
      font-size: 11px;
      color: #4caf50;
      text-decoration: none;
      white-space: nowrap;
   }
   
   .ac-view:hover {
      text-decoration: underline;
   }
   
   .searchclear {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      color: #999;
      font-size: 16px;
   }
   
   .searchclear:hover {
      color: #333;
   }
   
   .filter-container {
      margin-top: 10px;
   }
   
   .filter-btn {
      width: 100%;
      padding: 8px;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
   }
   
   .filter-btn:hover {
      background: #e9e9e9;
   }
   
   .filter-content {
      display: none;
      position: absolute;
      top: 0;
      left: 280px;
      margin-top: 0px;
      max-height: 500px;
      overflow-y: auto;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      width: 600px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
      z-index: 1001;
   }
   
   .filter-content.show {
      display: block;
   }
   
   .filter-group {
      margin-bottom: 15px;
   }
   
   .sectionlabel {
      font-weight: bold;
      margin-bottom: 8px;
      display: block;
      font-size: 12px;
      color: #333;
   }
   
   .checkbox, .radio {
      margin-bottom: 6px;
      font-size: 12px;
      display: flex;
      align-items: center;
   }
   
   .checkbox input, .radio input {
      margin-right: 6px;
   }
   
   .form-control {
      padding: 6px;
      font-size: 12px;
      margin-bottom: 5px;
      width: 100%;
      box-sizing: border-box;
   }
   
   .btn {
      padding: 6px 12px;
      font-size: 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f5f5f5;
      cursor: pointer;
   }
   
   .btn:hover {
      background: #e9e9e9;
   }
   
   .btn-primary {
      background: #4caf50;
      color: white;
      border-color: #4caf50;
   }
   
   .btn-primary:hover {
      background: #45a049;
   }
   
   .row {
      display: flex;
      flex-wrap: wrap;
      margin: 0 -5px;
   }
   
   .col-xs-3, .col-xs-4, .col-xs-6, .col-xs-12 {
      padding: 0 5px;
      box-sizing: border-box;
   }
   
   .col-xs-3 { width: 25%; }
   .col-xs-4 { width: 33.33%; }
   .col-xs-6 { width: 50%; }
   .col-xs-12 { width: 100%; }
   
   .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
   }
   
   .filters-dates {
      font-size: 12px;
   }
   
   .filters-dates input, .filters-dates select {
      margin-top: 5px;
      margin-bottom: 5px;
      width: 100%;
   }
   
   .month-checkboxes {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin-top: 5px;
   }
   
   .month-checkbox {
      display: flex;
      align-items: center;
   }
   
   .month-checkbox label {
      display: flex;
      align-items: center;
      font-size: 11px;
      cursor: pointer;
   }
   
   .month-checkbox input {
      margin-right: 4px;
   }
   
   #more-filters {
      margin-top: 10px;
      border-top: 1px solid #eee;
      padding-top: 10px;
   }
   
   .close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #666;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      z-index: 1002;
   }
   
   .close-btn:hover {
      background: #f5f5f5;
      color: #333;
   }
   
   .close-btn.minimize {
      width: 20px;
      height: 20px;

      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;

      line-height: 1;   /* prevents vertical font offset */
   }
	  
   .btn-group .btn.active {
      background-color: #4caf50 !important;
      color: white !important;
      border-color: #4caf50 !important;
   }

   /* Elevation Histogram Panel */
   .elevation-histogram {
      position: absolute;
      top: 235px;
      left: 50px;
      width: 238px;
      height: 360px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 16px;
      z-index: 1000;
      overflow: hidden;
      border: 1px solid #e0e0e0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   }
   
   .elevation-histogram.minimized {
      left: 5px;
      width: 0px;
      height: 0px;
      border-radius: 6px;
   }
   
   .elevation-histogram.minimized .histogram-content,
   .elevation-histogram.minimized .histogram-title {
      display: none;
   }
   
   .histogram-header {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 16px;
   }
   
   .histogram-title {
      margin: 0;
      font-size: 15px;
      font-weight: 600;
      color: #2c3e50;
      letter-spacing: -0.2px;
   }
   
   .histogram-controls {
      display: flex;
      gap: 4px;
   }
   
   .histogram-controls button {
      background: none;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #7f8c8d;
      transition: all 0.2s ease;
      font-size: 16px;
   }
   
   .histogram-controls button:hover {
      background: #f8f9fa;
      color: #2c3e50;
   }
   
   .histogram-container {
      width: 100%;
      height: 200px;
      display: flex;
      flex-direction: row;
      position: relative;
      background: #f8f9fa;
      border-radius: 6px;
      padding: 12px 0 0 0px;
   }
   
   .histogram-y-axis {
      width: 8px;
      height: 200px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
      padding-right: 8px;
   }
   
   .y-axis-line {
      position: absolute;
      right: 0;
      width: 1px;
      height: 100%;
      background: linear-gradient(to bottom, transparent, #dee2e6, transparent);
   }
   
   .histogram-y-label {
      font-size: 10px;
      color: #6c757d;
      text-align: right;
      padding: 2px 0;
      position: relative;
      z-index: 1;
      background: #f8f9fa;
      padding-right: 4px;
   }
   
   .histogram-chart {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
   }
   
   .chart-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
   }
   
   .grid-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(to right, transparent, #e9ecef 20px, #e9ecef calc(100% - 20px), transparent);
   }
   
   .histogram-row {
      display: flex;
      align-items: center;
      width: 100%;
      height: 9%; /* 11 rows total */
      position: relative;
      z-index: 2;
   }
   
   .histogram-bar {
      height: 70%;
      background: linear-gradient(90deg, #3498db, #2980b9);
      border-radius: 4px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      min-width: 4px;
      box-shadow: 0 2px 4px rgba(52, 152, 219, 0.2);
      z-index: 1000;
   }
   
   .histogram-bar:hover {
      transform: scaleY(1.05);
      box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
   }
   
   .histogram-bar.empty {
      background: #e9ecef;
      box-shadow: none;
   }
   
   .histogram-bar.empty:hover {
      transform: none;
      box-shadow: none;
      cursor: default;
   }
   
   .bar-count {
      position: absolute;
      right: -12px;
      top: 50%;
      transform: translateY(-60%);
      font-size: 10px;
      font-weight: 600;
      color: #2c3e50;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
   }
   
   .histogram-bar:hover .bar-count {
      opacity: 1;
   }
   
   .histogram-x-axis {
      width: 100%;
      height: 24px;
      font-size: 11px;
      color: #6c757d;
      text-align: center;
      margin-top: 4px;
      padding-left: 8px; /* Match Y-axis width */
   }
   
   .histogram-x-labels {
      display: flex;
      justify-content: space-between;
      width: 100%;
   }
   
   .histogram-stats {
      margin-top: 0px;
      padding: 6px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 6px;
      border: 1px solid #dee2e6;
   }
   
   .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
   }
   
   .stat-item {
      text-align: center;
   }
   
   .stat-label {
      font-size: 8px;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
   }
   
   .stat-value {
      font-size: 14px;
      font-weight: 600;
      color: #2c3e50;
   }
   
   .stat-unit {
      font-size: 12px;
      color: #95a5a6;
      margin-left: 2px;
   }
   
   /* Loading indicator */
   .loading-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #6c757d;
   }
   
   .loading-spinner {
      width: 40px;
      height: 40px;
      position: relative;
      margin-bottom: 16px;
      flex-shrink: 0;
   }
   
   .loading-spinner:before {
      content: '';
      box-sizing: border-box;
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid #e9ecef;
      border-top-color: #3498db;
      animation: spin 1s linear infinite;
   }
   
   @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
   }
   
   .loading-text {
      font-size: 13px;
      text-align: center;
      max-width: 90%;
      margin-bottom: 8px;
   }
   
   .loading-progress {
      width: 80%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      overflow: hidden;
      flex-shrink: 0;
   }
   
   .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2980b9);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 3px;
   }
   
   /* Empty state */
   .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #6c757d;
      text-align: center;
      padding: 40px 20px;
   }
   
   .empty-state-icon {
      font-size: 40px;
      margin-bottom: 16px;
      opacity: 0.3;
   }
   
   .empty-state-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #495057;
   }
   
   .empty-state-subtitle {
      font-size: 12px;
      line-height: 1.4;
      color: #868e96;
      max-width: 80%;
   }
   
   /* Responsive adjustments */
   @media (max-width: 768px) {
      .elevation-histogram {
         width: 280px;
         height: 480px;
      }
   }

	/* Elevation histogram toggle */
	#elevation-histogram-toggle label {
		font-size: 12px !important;
	}

	#elevation-histogram-toggle input[type="checkbox"] {
		margin-right: 6px;
	}

	.checkbox-label {
	  display: flex;
	  align-items: center;
	  font-size: 10px;
	}

	/* Elevation Histogram Loading State */
	.elevation-histogram.loading {
		height: 220px !important; /* Smaller height when loading */
		transition: height 0.3s ease;
	}

	.elevation-histogram.loading .histogram-content {
		height: calc(100% - 50px);
		overflow: hidden;
	}

	.elevation-histogram.loading .loading-indicator {
		padding: 0px 0;
	}

	.elevation-histogram.loading .histogram-container,
	.elevation-histogram.loading .histogram-stats,
	.elevation-histogram.loading .histogram-x-axis {
		display: none !important;
	}

	/* Observation List Panel */
	.observation-list-panel {
		position: absolute;
		top: 80px;
		right: 10px;
		width: 320px;
		max-height: 80vh;
		background: white;
		border-radius: 8px;
		box-shadow: 0 4px 20px rgba(0,0,0,0.15);
		z-index: 1000;
		overflow: hidden;
		display: flex;
		flex-direction: column;
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
	}

	.observation-list-panel.minimized {
		top: 80px;
		height: 20px;
		max-height: 20px;
		width: 20px;
		background: white;
		padding: 8px;
	}

	.observation-list-panel.minimized .observation-list-header {
		background: transparent;
		padding: 0;
		height: 100%;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.observation-list-panel.minimized .observation-list-header h3,
	.observation-list-panel.minimized .observation-list-controls button:first-child,
	.observation-list-panel.minimized .observation-list-footer {
		display: none;
	}

	.observation-list-panel.minimized .observation-list-controls button:last-child {
		color: #666;
	}

	.observation-list-panel.minimized .observation-list-controls {
		margin: 0;
	}

	.observation-list-header {
		padding: 12px 16px;
		background: linear-gradient(135deg, #2c3e50 0%, #4a6491 100%);
		color: white;
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-shrink: 0;
	}

	.observation-list-header h3 {
		margin: 0;
		font-size: 14px;
		font-weight: 600;
	}

	.observation-list-controls {
		display: flex;
		gap: 8px;
	}

	.observation-list-controls button {
		background: rgba(255, 255, 255, 0.2);
		border: none;
		width: 24px;
		height: 24px;
		border-radius: 4px;
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		color: white;
		font-size: 14px;
		transition: all 0.2s ease;
	}

	.observation-list-controls button:hover {
		background: rgba(255, 255, 255, 0.3);
	}

	.observation-list-content {
		flex: 1;
		overflow-y: auto;
		padding: 0;
		background: #f8f9fa;
	}

	.observation-list-items {
		min-height: 200px;
		max-height: 60vh;
		overflow-y: auto;
	}

	.observation-list-footer {
		padding: 12px 16px;
		border-top: 1px solid #e9ecef;
		background: white;
		display: flex;
		justify-content: center;
		flex-shrink: 0;
	}

	.load-more-btn {
		padding: 8px 16px;
		background: #3498db;
		color: white;
		border: none;
		border-radius: 4px;
		cursor: pointer;
		font-size: 12px;
		font-weight: 500;
		transition: all 0.2s ease;
	}

	.load-more-btn:hover {
		background: #2980b9;
	}

	.load-more-btn:disabled {
		background: #bdc3c7;
		cursor: not-allowed;
	}

	.observation-item {
		padding: 12px;
		border-bottom: 1px solid #eee;
		display: flex;
		align-items: center;
		cursor: pointer;
		transition: all 0.2s ease;
		background: white;
	}

	.observation-item:hover {
		background: #f8f9fa;
	}

	.observation-item.selected {
		background: #e3f2fd;
		border-left: 3px solid #2196f3;
	}

	.observation-item-photo {
		width: 50px;
		height: 50px;
		flex-shrink: 0;
		margin-right: 12px;
		border-radius: 4px;
		overflow: hidden;
	}

	.observation-item-photo img {
		width: 100%;
		height: 100%;
		object-fit: cover;
	}

	.observation-item-photo.no-photo {
		background: #e9ecef;
		display: flex;
		align-items: center;
		justify-content: center;
		color: #6c757d;
		font-size: 10px;
	}

	.observation-item-details {
		flex: 1;
		min-width: 0;
	}

	.observation-item-name {
		font-weight: 600;
		font-size: 13px;
		color: #2c3e50;
		margin-bottom: 2px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.observation-item-elevation {
		font-size: 11px;
		color: #4caf50;
		font-weight: 500;
		margin-bottom: 2px;
	}

	.observation-item-meta {
		font-size: 10px;
		color: #6c757d;
		display: flex;
		flex-wrap: wrap;
		gap: 4px;
	}

	.observation-item-meta span {
		display: inline-block;
	}

	.no-observations {
		padding: 40px 20px;
		text-align: center;
		color: #6c757d;
		font-size: 13px;
	}

	/* Ensure elevation histogram doesn't overlap with observation list */
	.elevation-histogram {
		z-index: 999; /* One less than observation list */
	}

	/* Observation List Loading States */
	.observation-list-panel.loading .observation-list-items {
		opacity: 0.5;
	}

	.observation-list-panel.loading .load-more-btn {
		position: relative;
	}

	.observation-list-panel.loading .load-more-btn:after {
		content: '';
		position: absolute;
		right: 10px;
		top: 50%;
		transform: translateY(-50%);
		width: 16px;
		height: 16px;
		border: 2px solid #ffffff;
		border-top: 2px solid transparent;
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	/* Smooth scrolling for new items */
	.observation-list-items {
		scroll-behavior: smooth;
	}

	/* Highlight animation for new items */
	@keyframes highlightNewItem {
		0% { background-color: #e3f2fd; }
		100% { background-color: white; }
	}

	.observation-item.new {
		animation: highlightNewItem 2s ease-out;
	}

	/* Monthly View Styles */
	.month-cluster {
		/* Smaller cluster icons */
		transform: translate(-50%, -50%);
	}

	.month-legend {
		background: white;
		border-radius: 5px;
		padding: 10px;
		box-shadow: 0 2px 10px rgba(0,0,0,0.1);
		font-size: 12px;
		max-width: 180px;
	}

	.month-legend-item {
		display: flex;
		align-items: center;
		margin-bottom: 2px;
		font-size: 10px;
	}

	.month-legend-color {
		width: 12px;
		height: 12px;
		border-radius: 50%;
		margin-right: 5px;
		border: 1px solid #ddd;
	}

	/* Smaller cluster icons */
	.leaflet-marker-icon.leaflet-cluster-animated {
		width: 30px !important;
		height: 30px !important;
		margin-left: -15px !important;
		margin-top: -15px !important;
	}

	.leaflet-cluster-animated .leaflet-marker-icon, 
	.leaflet-cluster-animated .leaflet-marker-shadow {
		-webkit-transition: -webkit-transform 0.3s ease-out, opacity 0.3s ease-in;
		-moz-transition: -moz-transform 0.3s ease-out, opacity 0.3s ease-in;
		-o-transition: -o-transform 0.3s ease-out, opacity 0.3s ease-in;
		transition: transform 0.3s ease-out, opacity 0.3s ease-in;
	}

	@keyframes spin {
		0% { transform: rotate(0deg); }
		100% { transform: rotate(360deg); }
	}

	.monthly-loading-spinner {
		width: 30px;
		height: 30px;
		border: 3px solid #f3f3f3;
		border-top: 3px solid #4caf50;
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	/* Monthly legend styles */
	.month-legend {
		background: white;
		border-radius: 5px;
		padding: 10px;
		box-shadow: 0 2px 10px rgba(0,0,0,0.1);
		font-size: 12px;
		max-width: 180px;
		transition: all 0.3s ease;
	}

	.month-legend.loading {
		min-height: 120px;
		display: flex;
		flex-direction: column;
		justify-content: center;
	}

	.month-legend-error {
		border-left: 3px solid #d32f2f;
	}

	.month-legend-error .error-icon {
		color: #d32f2f;
		font-size: 20px;
		text-align: center;
		margin-bottom: 5px;
	}

	.month-legend-complete {
		border-left: 3px solid #4caf50;
	}
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script>
// debug grid example from https://leafletjs.com/examples/extending/extending-2-layers.html
L.GridLayer.DebugCoords = L.GridLayer.extend({
   createTile: function (coords) {
      var tile = document.createElement('div');
      tile.innerHTML = [coords.x, coords.y, coords.z].join(', ');
      tile.style.outline = '1px solid red';
      return tile;
   }
});
L.gridLayer.debugCoords = function(opts) {
   return new L.GridLayer.DebugCoords(opts);
};
// this allows a style filter to be applied to a basemap tile layer
L.TileLayer.StyleFilter = L.TileLayer.extend({
   intialize: function (url, options) {
      L.TileLayer.prototype.initialize.call(this, url, options);
   },
   styleFilter: function () {
      var filters = this.options.filter || '';
      return filters;
   },
   _initContainer: function () {
      var tile = L.TileLayer.prototype._initContainer.call(this);
      this._container.style.filter = this.styleFilter();
   },
});
L.tileLayer.styleFilter = function (url, options) {
   return new L.TileLayer.StyleFilter(url, options);
};
// this provides a way to get some USGS map images as tiles, as an alternative to WMS
// primary use case is when the WMS Server doesn't respond very quickly
// but this can also be used for other reasons, such as custom styling of the tiles
L.TileLayer.USGS = L.TileLayer.extend({
   intialize: function (url, options) {
      L.TileLayer.prototype.initialize.call(this, url, options);
   },
   getTileUrl: function (coords) {
      var data = {
         //r: Browser.retina ? '@2x' : '',
         //s: this._getSubdomain(coords),
         x: coords.x,
         y: coords.y,
         z: this._getZoomForUrl()
      };
      let mMax = 20037508.3428;
      let mTile = 2*mMax/(Math.pow(2,data.z));
      let bb = [
         data.x*mTile-mMax,
         -(data.y+1)*mTile+mMax,
         (data.x+1)*mTile-mMax,
         -data.y*mTile+mMax,
      ];
      data['p'] = `&f=image&bboxSR=102100&imageSR=102100&size=${this._tileSize.x},${this._tileSize.y}&bbox=${bb[0]},${bb[1]},${bb[2]},${bb[3]}`;
      if (this.options.renderingRule) { data['p'] += `&renderingRule=%7B"rasterFunction"%3A"${this.options.renderingRule}"%7D`; };
      return this._url + data.p;
      //return Util.template(this._url, Util.extend(data, this.options));
   },
   styleFilter: function () {
      var filters = this.options.filter || '';
      return filters;
   },
   _initContainer: function () {
      var tile = L.TileLayer.prototype._initContainer.call(this);
      this._container.style.filter = this.styleFilter();
   },
});
L.tileLayer.usgs = function (url, options) {
   return new L.TileLayer.USGS(url, options);
};
/*
https://github.com/mapbox/corslite
BSD 2-Clause License
Copyright (c) 2017, Mapbox
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function corslite(url, callback, cors) {
    var sent = false;
    if (typeof window.XMLHttpRequest === 'undefined') {
        return callback(Error('Browser not supported'));
    }
    if (typeof cors === 'undefined') {
        var m = url.match(/^\s*https?:\/\/[^\/]*/);
        cors = m && (m[0] !== location.protocol + '//' + location.hostname +
                (location.port ? ':' + location.port : ''));
    }
    var x = new window.XMLHttpRequest();
    function isSuccessful(status) {
        return status >= 200 && status < 300 || status === 304;
    }
    if (cors && !('withCredentials' in x)) {
        // IE8-9
        x = new window.XDomainRequest();
        // Ensure callback is never called synchronously, i.e., before
        // x.send() returns (this has been observed in the wild).
        // See https://github.com/mapbox/mapbox.js/issues/472
        var original = callback;
        callback = function() {
            if (sent) {
                original.apply(this, arguments);
            } else {
                var that = this, args = arguments;
                setTimeout(function() {
                    original.apply(that, args);
                }, 0);
            }
        }
    }
    function loaded() {
        if (
            // XDomainRequest
            x.status === undefined ||
            // modern browsers
            isSuccessful(x.status)) callback.call(x, null, x);
        else callback.call(x, x, null);
    }
    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`
    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).
    if ('onload' in x) {
        x.onload = loaded;
    } else {
        x.onreadystatechange = function readystate() {
            if (x.readyState === 4) {
                loaded();
            }
        };
    }
    // Call the callback with the XMLHttpRequest object as an error and prevent
    // it from ever being called again by reassigning it to `noop`
    x.onerror = function error(evt) {
        // XDomainRequest provides no evt parameter
        callback.call(this, evt || true, null);
        callback = function() { };
    };
    // IE9 must have onprogress be set to a unique function.
    x.onprogress = function() { };
    x.ontimeout = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };
    x.onabort = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };
    // GET is the only supported HTTP Verb by XDomainRequest and is the
    // only one supported here.
    x.open('GET', url, true);
    // Send the request. Sending data is not supported.
    x.send(null);
    sent = true;
    return x;
}
if (typeof module !== 'undefined') module.exports = corslite;
/*
https://github.com/consbio/Leaflet.UTFGrid/blob/master/L.UTFGrid.js
Copyright (c) 2015 - 2017, Conservation Biology Institute
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
//heavily modified from: https://raw.githubusercontent.com/danzel/Leaflet.utfgrid/leaflet-master/src/leaflet.utfgrid.js
//depends on corslite
L.UTFGrid = L.TileLayer.extend({
	options: {
		resolution: 4,
		pointerCursor: true,
        mouseInterval: 66  // Delay for mousemove events
	},
	_mouseOn: null,
    _mouseOnTile: null,
    _tileCharCode: null, // '<tileKey>:<charCode>' or null
    _cache: null, // {<tileKey>: <utfgrid>}
    _idIndex: null, // {<featureID>: {<tileKey1>: true, ...<tileKeyN>: true} }
    _throttleMove: null, // holds throttled mousemove handler
    //_throttleConnectEventHandlers: null, // holds throttled connection setup function
    _updateCursor: function(){ }, //no-op, overridden below
	onAdd: function (map) {
        this._cache = {};
        this._idIndex = {};
        L.TileLayer.prototype.onAdd.call(this, map);
        this._throttleMove = L.Util.throttle(this._move, this.options.mouseInterval, this);
        if (this.options.pointerCursor) {
            this._updateCursor = function(cursor) { this._container.style.cursor = cursor; }
        }
        map.on('boxzoomstart', this._disconnectMapEventHandlers, this);
        // have to throttle or we get an immediate click event on boxzoomend
        map.on('boxzoomend', this._throttleConnectEventHandlers, this);
        this._connectMapEventHandlers();
	},
	onRemove: function () {
		var map = this._map;
        map.off('boxzoomstart', this._disconnectMapEventHandlers, this);
        map.off('boxzoomend', this._throttleConnectEventHandlers, this);
        this._disconnectMapEventHandlers();
		this._updateCursor('');
        L.TileLayer.prototype.onRemove.call(this, map);
	},
    createTile: function(coords) {
        this._loadTile(coords);
        return document.createElement('div');  // empty DOM node, required because this overrides L.TileLayer
	},
    setUrl: function(url, noRedraw) {
        this._cache = {};
        return L.TileLayer.prototype.setUrl.call(this, url, noRedraw);
    },
    _connectMapEventHandlers: function(){
        this._map.on('click', this._onClick, this);
        this._map.on('mousemove', this._throttleMove, this);
    },
    _disconnectMapEventHandlers: function(){
        this._map.off('click', this._onClick, this);
		this._map.off('mousemove', this._throttleMove, this);
    },
    _throttleConnectEventHandlers: function() {
        setTimeout(this._connectMapEventHandlers.bind(this), 100);
    },
    _update: function (center, zoom) {
        L.TileLayer.prototype._update.call(this, center, zoom);
    },
    _loadTile: function (coords) {
        var url = this.getTileUrl(coords);
		var key = this._tileCoordsToKey(coords);
		var self = this;
        if (this._cache[key]) { return }
        corslite(url, function(err, response){
            if (err) {
                self.fire('error', {error: err});
                return;
            }
            var data = JSON.parse(response.responseText);
            self._cache[key] = data;
            L.Util.bind(self._handleTileLoad, self)(key, data);
        }, true);
	},
    _handleTileLoad: function(key, data) {
        // extension point
    },
	_onClick: function (e) {
		this.fire('click', this._objectForEvent(e));
	},
	_move: function (e) {
        if (e.latlng == null){ return }
		var on = this._objectForEvent(e);
        if (on._tileCharCode !== this._tileCharCode) {
			if (this._mouseOn) {
				this.fire('mouseout', {
                    latlng: e.latlng,
                    data: this._mouseOn,
                    _tile: this._mouseOnTile,
                    _tileCharCode: this._tileCharCode
                });
				this._updateCursor('');
			}
			if (on.data) {
				this.fire('mouseover', on);
				this._updateCursor('pointer');
			}
			this._mouseOn = on.data;
            this._mouseOnTile = on._tile;
            this._tileCharCode = on._tileCharCode;
		} else if (on.data) {
			this.fire('mousemove', on);
		}
	},
	_objectForEvent: function (e) {
	    if (!e.latlng) return;  // keyboard <ENTER> events also pass through as click events but don't have latlng
        var map = this._map,
		    point = map.project(e.latlng),
		    tileSize = this.options.tileSize,
		    resolution = this.options.resolution,
		    x = Math.floor(point.x / tileSize),
		    y = Math.floor(point.y / tileSize),
		    gridX = Math.floor((point.x - (x * tileSize)) / resolution),
		    gridY = Math.floor((point.y - (y * tileSize)) / resolution),
			max = map.options.crs.scale(map.getZoom()) / tileSize;
        x = (x + max) % max;
        y = (y + max) % max;
        var tileKey = this._tileCoordsToKey({z: map.getZoom(), x: x, y: y});
		var data = this._cache[tileKey];
		if (!data) {
			return {
                latlng: e.latlng,
                data: null,
                _tile: null,
                _tileCharCode: null
            };
		}
        var charCode = data.grid[gridY].charCodeAt(gridX);
		var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];
		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}
		return {
            latlng: e.latlng,
            data: result,
            id: (result)? result.id: null,
            _tile: tileKey,
            _tileCharCode: tileKey + ':' + charCode
        };
	},
    _dataForCharCode: function (tileKey, charCode) {
        var data = this._cache[tileKey];
        var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];
		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}
        return result;
    },
	_utfDecode: function (c) {
		if (c >= 93) {
			c--;
		}
		if (c >= 35) {
			c--;
		}
		return c - 32;
	},
    _utfEncode: function (c) {
        //reverse of above, returns charCode for c
        //derived from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js#L37
        var charCode = c + 32;
        if (charCode >= 34) {
            charCode ++;
        }
        if (charCode >= 92) {
            charCode ++;
        }
        return charCode;
    }
});
L.utfGrid = function (url, options) {
	return new L.UTFGrid(url, options);
};
L.UTFGridCanvas = L.UTFGrid.extend({
	options: {
        idField: 'ID',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
        buildIndex: true,  // requires above field to be set properly
        fillColor: 'black',
	    shadowBlur: 0,  // Number of pixels for blur effect
        shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
        debug: false  // if true, show tile borders and tile keys
    },
    _adjacentTiles: null,
    onAdd: function (map) {
        this._adjacentTiles = [];
        L.UTFGrid.prototype.onAdd.call(this, map);
	},
    createTile: function(coords) {
        this._loadTile(coords);
        var tile = document.createElement('canvas');
        tile.width = tile.height = this.options.tileSize;
        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), this._tileCoordsToKey(coords));
        }
        return tile;
	},
    _connectMapEventHandlers: function(){
        L.UTFGrid.prototype._connectMapEventHandlers.call(this);
        this.on('mouseover', this._handleMouseOver, this);
        this.on('mouseout', this._handleMouseOut, this);
    },
    _disconnectMapEventHandlers: function(){
        L.UTFGrid.prototype._disconnectMapEventHandlers.call(this);
        this.off('mouseover', this._handleMouseOver, this);
        this.off('mouseout', this._handleMouseOut, this);
    },
    _handleMouseOver: function (e) {
        if (e._tile == null || e._tileCharCode == null){ return }
        this._clearAdjacentTiles();
        // currently over this tile:
        var curTile = e._tile;
        this._drawTile(curTile, parseInt(e._tileCharCode.split(':')[3]));
        if (e.data && this._idIndex) {
            // draw adjacent tiles
            var id = e.data[this.options.idField];
            var zoomLevel = curTile.split(':')[2];
            if (!(id && this._idIndex[id] && this._idIndex[id][zoomLevel])) { return }
            var idx = this._idIndex[id][zoomLevel];
            for (var tileKey in idx) {
                //TODO: screen out any tiles that are not currently visible?
                if (tileKey !== curTile) {
                    this._drawTile(tileKey, idx[tileKey]);
                    this._adjacentTiles.push(tileKey);
                }
            }
        }
    },
    _handleMouseOut: function (e) {
        this._resetTile(e._tile);
        this._clearAdjacentTiles();
    },
    _clearAdjacentTiles: function() {
        // clear out any adjacent tiles that were drawn
        if (this._adjacentTiles) {
            for (var i = 0; i < this._adjacentTiles.length; i++) {
                this._resetTile(this._adjacentTiles[i]);
            }
            this._adjacentTiles = [];
        }
    },
    _handleTileLoad: function(tileKey, data) {
        // build index: {<id: {zoomLevel: {tileKey: tileCharCode} } }
        if (this.options.buildIndex) {
            var id, props, idx;
            var idField = this.options.idField;
            var zoomLevel = tileKey.split(':')[2];
            for (var i = 0; i < data.keys.length; i++) {
                props = data.data[data.keys[i]];
                if (props) {
                    id = props[idField];
                    if (id) {
                        if (this._idIndex[id] == null) {
                            this._idIndex[id] = {};
                        }
                        idx = this._idIndex[id];
                        if (idx[zoomLevel] == null) {
                            idx[zoomLevel] = {};
                        }
                        idx[zoomLevel][tileKey] = this._utfEncode(i);
                    }
                }
            }
        }
    },
    _drawTile: function(tileKey, charCode) {
        // for a given tile, find all pixels that match character and repaint
        // TODO: request animation frame?
        if (this._tiles[tileKey] == null){ return }
        var canvas = this._tiles[tileKey].el;
        var ctx = canvas.getContext('2d');
        this._resetTile(tileKey);
        var grid = this._cache[tileKey].grid;
        ctx.fillStyle = this.options.fillColor;
        var dim = this.options.tileSize / this.options.resolution;
        // TODO: order of traversal here may be backwards?  Do y then x?  (are data column major or row major?)
        //modified slightly from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js
        for (var x = 0; x < dim; x++) {
            for (var y = 0; y < dim; y++) {
                if (grid[y].charCodeAt(x) === charCode) {
                    var sweep = 1;
                    while (y < 63 && grid[y + 1].charCodeAt(x) === charCode) {
                        y++;
                        sweep++;
                    }
                    ctx.fillRect(x * 4, (y * 4) - ((sweep - 1) * 4), 4, 4 * sweep);
                }
            }
        }
        if (this.options.shadowBlur) {
            this._addShadow(canvas, ctx);
        }
	
    },
    _resetTile: function(tileKey) {
        // clear the canvas
        if (this._tiles[tileKey] == null){ return }
        var tile = this._tiles[tileKey].el;
        tile.width = this.options.tileSize;  // hard reset of canvas
        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), tileKey);
        }
    },
    _drawDefaultTile: function(ctx, tileKey) {
        // if this.options.debug, add tileKey text and borders
        ctx.fillStyle = 'black';
        ctx.fillText(tileKey, 20, 20);
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(255, 0);
        ctx.lineTo(255, 255);
        ctx.lineTo(0, 255);
        ctx.closePath();
        ctx.stroke();
    },
    _addShadow: function(canvas, ctx) {
        ctx.shadowBlur = this.options.shadowBlur;
        ctx.shadowColor = this.options.shadowColor || this.options.fillColor;
        //Blur effect copied from glower - https://github.com/cutting-room-floor/glower/blob/mb-pages/src/glower.js#L108
        ctx.globalAlpha = 0.7;
        ctx.globalCompositeOperation = 'lighter';
        var a = 1;
        ctx.drawImage(canvas, -a, -a);
        ctx.drawImage(canvas, a, a);
        ctx.drawImage(canvas, 0, -a);
        ctx.drawImage(canvas, -a, 0);
        ctx.globalAlpha = 1;
    }
});
L.utfGridCanvas = function (url, options) {
	return new L.UTFGridCanvas(url, options);
};
// iNaturalist UTFGrid Compare
function freplacexyz(url,x,y,z) {
   url = url.replace('{x}',x);
   url = url.replace('{y}',y);
   url = url.replace('{z}',z);
   return url;
};
function fgetutfgrid(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
//      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};
L.GridLayer.UTFGridCompare = L.GridLayer.extend({
   createTile: function (coords, done) {
      var tile = document.createElement('canvas');
      var tileSize = this.getTileSize();
      tile.width = tileSize.x;
      tile.height = tileSize.y;
      var cellsPerTile = {x:64,y:64};
      var cellSize = {x:tileSize.x/cellsPerTile.x,y:tileSize.y/cellsPerTile.y};
      var ctx = tile.getContext('2d');
      // default marker setups
      var dmarker = {type:'relative',offset:{x:0,y:0},size:0.75,opacity:0.5};
      var marker = null;
      if (this.options.marker) {
         marker = this.options.marker;
         marker.type = marker.type || dmarker.type;
         marker.size = marker.size || dmarker.size;
         marker.offset = marker.offset || dmarker.offset;
         marker.opacity = marker.opacity || dmarker.opacity;
      }
      else { marker = dmarker };
      var offset = marker.offset;
      // get UTFgrids
      url0 = this.options.urlcompare;
      url1 = this.options.url;
      var prom0 = fgetutfgrid(freplacexyz(url0,coords.x,coords.y,coords.z));
      var prom1 = fgetutfgrid(freplacexyz(url1,coords.x,coords.y,coords.z));
      Promise.all([prom0,prom1]).then(function(utfgrid) {
         //draw markers on the tile canvas
         //note that this code was originally written to assume a 64x64 UTFgrid.
         //although the UTFgrid is still 64x64, the associated "grid tile" is actually only 32x32.
         //theoretically, a 2x2 set of cells from the UTFgrid should correspond to a single cell from the "grid tile"; however, that is not actually the case (see https://forum.inaturalist.org/t/open-test-of-map-tile-improvements/7833/88).
         //so this code attempts to mimic a 32x32 "grid tile" by using the bottom-right cell from each 2x2 set of UTFgrid cells. 
         //for (cx=0;cx<cellsPerTile.x;cx++) {
         for (cx=0;cx<cellsPerTile.x/2;cx++) {
            //for (cy=0;cy<cellsPerTile.y;cy++) {
            for (cy=0;cy<cellsPerTile.y/2;cy++) {
               //var cell = {x:cx,y:cy};
               var cell = {x:cx*2+1,y:cy*2+1};
               //for details about decoding the UTFgrid, see https://github.com/mapbox/utfgrid-spec/blob/master/1.2/utfgrid.md
               var d = [];
               for (u=0;u<utfgrid.length;u++) {
                  var i = utfgrid[u].grid[cell.y].charCodeAt(cell.x);
                  i = i-((i>=93)?34:(i>=35)?33:32);
                  d.push(utfgrid[u].data[utfgrid[u].keys[i]]);
               };
               for (j=0;j<d.length;j++) { d[j] = d[j] ? d[j].cellCount||0 : 0; } // set d = cellCount (set to 0 if undefined)
               var markerColor = 0; // default to black
               ctx.beginPath();
               var circleRadius = cellSize.x*marker.size;
               ctx.arc(cell.x*cellSize.x+offset.x,cell.y*cellSize.y+offset.y,circleRadius,0,2*Math.PI,false);
               if ( d[0]<=0 ) { markerColor = 'rgba(128,128,128,0.00)'; } // no color
               // else if ( d[1]<=0 ) { markerColor = `rgba(0,0,255,${marker.opacity})`; } // blue
               else {
                  var f = d[1]/d[0];
                  f = (f<=0)?1:(f>=1)?0:1-f;
                  markerColor = `hsla(${(f*240)},100%,50%,${marker.opacity})`; // high (1.0) is red, low (0.0) is blue
                  ctx.fillStyle = markerColor;
                  ctx.fill();
               };
               ctx.strokeStyle = markerColor;
               ctx.stroke();
            };
         };
      });  
      // asynchronous call
      setTimeout(function() {
         done(null, tile);
      }, 1000);
      return tile;
   }
});
L.gridLayer.utfGridCompare = function (options) {
   return new L.GridLayer.UTFGridCompare(options);
};
</script>
</head>
<body>
<div class="search-controls">
   <button class="close-btn minimize" onclick="toggleSearchControls()" title="Minimize">−</button>
   <div class="primary-filters">
      <div class="ac-chooser">
         <input type="text" id="taxon_name" placeholder="Species" onkeyup="handleTaxonSearch(event)" onfocus="handleTaxonSearch(event)">
         <span class="searchclear" onclick="clearTaxonSearch()" style="display: none;">×</span>
      </div>
      <div class="ac-chooser">
         <input type="text" id="place_name" placeholder="Location" onkeyup="handlePlaceSearch(event)" onfocus="handlePlaceSearch(event)">
         <span class="searchclear" onclick="clearPlaceSearch()" style="display: none;">×</span>
         <input type="hidden" id="place_id">
      </div>
      <button class="btn btn-primary" onclick="applySearch()">Search</button>
   </div>
   
   <div class="filter-container">
      <button class="filter-btn" onclick="toggleFilters(event)">
         <span><i>☰</i> Filters</span>
      </button>
      
      <div class="filter-content" id="filter-dropdown">
         <div class="row">
            <div class="col-xs-3">
               <label class="sectionlabel">Show</label>
               <div class="filter-group">
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-wild" onchange="toggleFilter('captive', 'false', this)"> Wild</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-captive" onchange="toggleFilter('captive', 'true', this)"> Captive</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-verifiable" onchange="toggleFilter('verifiable', 'true', this)"> Verifiable</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-research" onchange="toggleFilter('quality_grade', 'research', this)"> Research Grade</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-needsid" onchange="toggleFilter('quality_grade', 'needs_id', this)"> Needs ID</label>
                  </div>
               </div>
            </div>
            
            <div class="col-xs-3">
               <label class="sectionlabel">Categories</label>
               <div class="btn-group">
                  <button class="btn" onclick="toggleIconicTaxon('Aves')">Birds</button>
                  <button class="btn" onclick="toggleIconicTaxon('Plantae')">Plants</button>
                  <button class="btn" onclick="toggleIconicTaxon('Insecta')">Insects</button>
                  <button class="btn" onclick="toggleIconicTaxon('Mammalia')">Mammals</button>
                  <button class="btn" onclick="toggleIconicTaxon('Fungi')">Fungi</button>
                  <button class="btn" onclick="toggleIconicTaxon('Amphibia')">Amphibians</button>
                  <button class="btn" onclick="toggleIconicTaxon('Reptilia')">Reptiles</button>
                  <button class="btn" onclick="toggleIconicTaxon('Mollusca')">Mollusks</button>
               </div>
            </div>
            
            <div class="col-xs-3">
               <label class="sectionlabel">View Type</label>
               <div class="filter-group">
                  <div class="radio">
                     <label><input type="radio" name="view" value="default" onchange="toggleView(this.value)"> Default Map</label>
                  </div>
					<div class="radio">
						<label><input type="radio" name="view" value="elevation" onchange="toggleView(this.value)"> Elevation View</label>
					</div>

					<div class="checkbox" id="elevation-histogram-toggle" style="display: none; margin-top: 5px; margin-left: 20px;">
						<label class="checkbox-label">
							<input type="checkbox" id="enable-histogram" onchange="toggleHistogramSearch()">
							<span style="font-size: 10px;">Elevation histogram</span>
						</label>
					</div>
					<div id="accuracy-slider-container" style="display: none; margin-top: 10px; margin-left: 20px;">
						<div style="display: flex; justify-content: space-between; align-items: center;">
							<label style="font-size: 10px; color: #666;">Accuracy Tolerance:</label>
							<span id="zoom-level-display" style="font-size: 10px; color: #4caf50; font-weight: bold;">12</span>
						</div>
						<input type="range" id="accuracy-tolerance-slider" min="0" max="15" value="12" 
							   style="width: 100%; margin-top: 5px;"
							   oninput="updateZoomLevelDisplay(this.value)">
						<div style="display: flex; justify-content: space-between; font-size: 9px; color: #888; margin-top: 2px;">
							<span>Low Detail</span>
							<span>High Detail</span>
						</div>
						<div style="font-size: 8px; color: #999; margin-top: 5px;">
							Higher detail = slower loading
						</div>
					</div>
                  <div class="radio">
                     <label><input type="radio" name="view" value="heatmap" onchange="toggleView(this.value)"> Heatmap View</label>
                  </div>
                  <div class="radio">
                     <label><input type="radio" name="view" value="subsetratio" onchange="toggleView(this.value)"> Subset Ratio View</label>
                  </div>
					<div class="radio">
						<label><input type="radio" name="view" value="monthly" onchange="toggleView(this.value)"> Monthly View</label>
					</div>
               </div>
               
               <div id="subsetratio-params" style="display:none; margin-top:10px;">
                  <label class="sectionlabel">Compare Exclude Param</label>
                  <input type="text" class="form-control" id="compare-exclude-param" placeholder="e.g., quality_grade" onchange="updateFilter('compare_exclude_param', this.value, true)">
                  <small style="color: #666; font-size: 10px;">Parameter to exclude for superset comparison</small>
               </div>
            </div>
            
            <div class="col-xs-3">
               <label class="sectionlabel">Date Observed</label>
               <div class="filters-dates">
                  <select class="form-control" id="date-type" onchange="handleDateTypeChange()">
                     <option value="any">Any</option>
                     <option value="exact">Exact Date</option>
                     <option value="range">Range</option>
                     <option value="month">Months</option>
                  </select>
                  
                  <input type="date" id="exact-date" class="form-control" style="display:none; margin-top:5px;">
                  
                  <div id="date-range" style="display:none; margin-top:5px;">
                     <input type="date" class="form-control" id="date-start" placeholder="Start date">
                     <input type="date" class="form-control" id="date-end" placeholder="End date">
                  </div>
                  
                  <div id="date-month" style="display:none; margin-top:5px;">
                     <div class="month-checkboxes">
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="1"> Jan</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="2"> Feb</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="3"> Mar</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="4"> Apr</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="5"> May</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="6"> Jun</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="7"> Jul</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="8"> Aug</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="9"> Sep</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="10"> Oct</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="11"> Nov</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="12"> Dec</label>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         
         <div class="row" style="margin-top: 15px;">
            <div class="col-xs-12">
               <button class="btn btn-primary" onclick="applyAllFilters()">Update Search</button>
               <button class="btn" onclick="resetAllFilters()">Reset Filters</button>
            </div>
         </div>
      </div>
   </div>
</div>
<script>
// Simple filter management
let filters = new Map();
let selectedPlaceId = null;
let isFiltersVisible = false;

function toggleSearchControls() {
   const controls = document.querySelector('.search-controls');
   const btn = document.querySelector('.close-btn.minimize');
   
   if (controls.classList.contains('minimized')) {
      // Restore from minimized state
      controls.classList.remove('minimized');
      btn.innerHTML = '−';
      btn.title = "Minimize";
   } else {
      // Minimize - also hide filters if open
      controls.classList.add('minimized');
      hideFilters();
      btn.innerHTML = '🔎︎';
      btn.title = "Restore";
   }
}

function toggleFilters(event) {
   if (event) event.stopPropagation();
   
   const filterContent = document.getElementById('filter-dropdown');
   if (isFiltersVisible) {
      hideFilters();
   } else {
      showFilters();
   }
}

function updateCategoryButtons() {
   const iconicTaxa = filters.get('iconic_taxa');
   const categoryButtons = document.querySelectorAll('.btn-group .btn');
   
   categoryButtons.forEach(button => {
      // Get the taxon from the button's onclick attribute
      const match = button.getAttribute('onclick').match(/toggleIconicTaxon\('([^']+)'\)/);
      if (match) {
         const taxon = match[1];
         if (iconicTaxa && iconicTaxa.split(',').includes(taxon)) {
            button.style.backgroundColor = '#4caf50';
            button.style.color = 'white';
            button.style.borderColor = '#4caf50';
         } else {
            button.style.backgroundColor = '';
            button.style.color = '';
            button.style.borderColor = '#ddd';
         }
      }
   });
}

let histogramStarted = false;

function showFilters() {
    const filterContent = document.getElementById('filter-dropdown');
    filterContent.style.display = 'block';
    isFiltersVisible = true;
    initializeFilterValues();
    
    // Close filters when clicking outside
    setTimeout(() => {
        document.addEventListener('click', closeFiltersOnClickOutside);
    }, 10);
}

function hideFilters() {
   const filterContent = document.getElementById('filter-dropdown');
   filterContent.style.display = 'none';
   isFiltersVisible = false;
   document.removeEventListener('click', closeFiltersOnClickOutside);
}

function closeFiltersOnClickOutside(event) {
   const filterContent = document.getElementById('filter-dropdown');
   const filterBtn = document.querySelector('.filter-btn');
   
   if (!filterContent.contains(event.target) && !filterBtn.contains(event.target)) {
      hideFilters();
   }
}

// Store selected place ID when autocomplete item is clicked
function storePlaceId(placeId) {
   selectedPlaceId = placeId;
   document.getElementById('place_id').value = placeId;
}

// Simple filter toggle function
function toggleFilter(param, value, checkbox) {
   if (checkbox.checked) {
      filters.set(param, value);
   } else {
      filters.delete(param);
   }
}

function updateFilter(param, value, isActive) {
   if (isActive && value) {
      filters.set(param, value);
   } else {
      filters.delete(param);
   }
}

function toggleView(view) {
    filters.set('view', view);
    
    // Show/hide subsetratio params
    const subsetParams = document.getElementById('subsetratio-params');
    if (view === 'subsetratio') {
        subsetParams.style.display = 'block';
    } else {
        subsetParams.style.display = 'none';
        filters.delete('compare_exclude_param');
    }
    
    // Show/hide elevation histogram toggle
    const histogramToggle = document.getElementById('elevation-histogram-toggle');
    if (view === 'elevation') {
        histogramToggle.style.display = 'block';
        // Reset histogram state when switching to elevation view
        histogramSearchEnabled = false;
        elevationSearchConfirmed = false;
        document.getElementById('enable-histogram').checked = false;
    } else {
        histogramToggle.style.display = 'none';
        // Hide histogram if visible
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
    }
    
    // Clear monthly view if switching away from it
    if (view !== 'monthly') {
        clearMonthlyView();
    }
}

// Monthly View Variables
let monthlyMarkers = {};
let monthlyClusters = {};
let monthlyObservationData = [];

// Function to initialize monthly view (only called on page load if monthly view is active)
function initMonthlyView() {
    // Only initialize if we're in monthly view
    const currentView = new URLSearchParams(window.location.search).get('view');
    if (currentView === 'monthly') {
        console.log('Initializing monthly view...');
        fetchMonthlyObservations();
    }
}

// Function to fetch observations for monthly view
async function fetchMonthlyObservations() {
    try {
        console.log('Fetching observations for monthly view...');
        
        // Add loading legend
        addMonthlyLegend(true);
        
        // Get ALL observations
        let allObservations = [];
        let page = 1;
        const perPage = 200;
        let hasMore = true;
        
        // First, get total count
        const countUrl = `${inat_urlbase}observations?per_page=1&${winurlparams}`;
        const countResponse = await fetch(countUrl);
        const countData = await countResponse.json();
        const totalObservations = countData.total_results || 0;
        
        console.log(`Found ${totalObservations} total observations`);
        
        // Update initial progress
        updateMonthlyLegendProgress(0, totalObservations);
        
        // Fetch observations in batches
        while (hasMore) {
            const observationsUrl = `${inat_urlbase}observations?per_page=${perPage}&page=${page}&${winurlparams}`;
            const response = await fetch(observationsUrl);
            const data = await response.json();
            
            if (!data.results || data.results.length === 0) {
                hasMore = false;
                break;
            }
            
            allObservations = allObservations.concat(data.results);
            
            // Update loading progress
            updateMonthlyLegendProgress(allObservations.length, totalObservations);
            console.log(`Loaded ${allObservations.length} observations...`);
            
            if (data.results.length < perPage) {
                hasMore = false;
            }
            page++;
        }
        
        // Filter to observations with coordinates and observation dates
        monthlyObservationData = allObservations.filter(obs => 
            obs.geojson && obs.geojson.coordinates && obs.observed_on
        );
        
        console.log(`Found ${monthlyObservationData.length} observations with dates and coordinates`);
        
        // Complete loading and show final legend
        completeMonthlyLegend();
        
        // Create monthly markers
        createMonthlyMarkers(monthlyObservationData);
        
    } catch (error) {
        console.error('Error fetching observations for monthly view:', error);
        // Update legend to show error state
        showMonthlyLegendError('Failed to load observations');
    }
}

// Function to show error in monthly legend
function showMonthlyLegendError(errorMessage) {
    // Remove existing legend if present
    if (window.monthlyLegendControl) {
        mymap.removeControl(window.monthlyLegendControl);
    }
    
    const legend = L.control({ position: 'bottomleft' });
    
    legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'month-legend');
        div.style.cssText = `
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 12px;
            max-width: 180px;
        `;
        
        div.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 5px; color: #d32f2f;">
                Monthly View Error
            </div>
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 10px 0;">
                <div style="color: #d32f2f; font-size: 24px; margin-bottom: 8px;">⚠️</div>
                <div style="font-size: 10px; color: #666; text-align: center;">
                    ${errorMessage}<br>
                    <button onclick="retryMonthlyView()" style="
                        margin-top: 8px;
                        padding: 4px 8px;
                        background: #4caf50;
                        color: white;
                        border: none;
                        border-radius: 3px;
                        font-size: 10px;
                        cursor: pointer;
                    ">
                        Retry
                    </button>
                </div>
            </div>
        `;
        
        return div;
    };
    
    legend.addTo(mymap);
    window.monthlyLegendControl = legend;
}

// Function to retry monthly view
function retryMonthlyView() {
    clearMonthlyView();
    fetchMonthlyObservations();
}

// Function to get month from observation
function getMonthFromObservation(obs) {
    const observedDate = new Date(obs.observed_on);
    return observedDate.getMonth() + 1; // 1-12
}

// Function to get color for month (1-12)
function getMonthColor(month) {
    const colors = [
        '#FF6B6B', // Jan - Deep Red
        '#FF8E53', // Feb - Orange-Red
        '#FFB347', // Mar - Orange
        '#FFD166', // Apr - Yellow-Orange
        '#A8E6CF', // May - Light Green
        '#7BC8A4', // Jun - Green
        '#4ECDC4', // Jul - Teal
        '#45B7D1', // Aug - Light Blue
        '#6C5CE7', // Sep - Purple
        '#A29BFE', // Oct - Lavender
        '#DDA0DD', // Nov - Plum
        '#FFB6C1'  // Dec - Pink
    ];
    return colors[month - 1] || '#CCCCCC';
}

// Function to create monthly markers with separate clustering per month
function createMonthlyMarkers(observations) {
    // Clear existing layers
    clearMonthlyView();
    
    // Show processing message
    if (window.monthlyLegendControl) {
        const legendDiv = document.querySelector('.month-legend');
        if (legendDiv) {
            legendDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 5px;">
                    Processing Data...
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px 0;">
                    <div class="monthly-loading-spinner" style="margin-bottom: 10px;"></div>
                    <div style="font-size: 10px; color: #666; text-align: center;">
                        Creating ${observations.length.toLocaleString()} markers<br>
                        Grouping by month...
                    </div>
                </div>
            `;
        }
    }
    
    // Small delay to show processing message
    setTimeout(() => {
        // Group observations by month
        const observationsByMonth = {};
        for (let month = 1; month <= 12; month++) {
            observationsByMonth[month] = [];
        }
        
        // Sort observations by month
        observations.forEach(obs => {
            const month = getMonthFromObservation(obs);
            if (month >= 1 && month <= 12) {
                observationsByMonth[month].push(obs);
            }
        });
        
        // Create separate cluster groups for each month
        Object.keys(observationsByMonth).forEach(month => {
            const monthNum = parseInt(month);
            const monthObservations = observationsByMonth[monthNum];
            
            if (monthObservations.length === 0) return;
            
            // Create a marker cluster group for this month ONLY
            const monthCluster = L.markerClusterGroup({
                maxClusterRadius: 20, // Smaller cluster radius as requested
                spiderfyOnMaxZoom: true,
                showCoverageOnHover: false,
                zoomToBoundsOnClick: true,
                disableClusteringAtZoom: 18, // Stop clustering at high zoom
                iconCreateFunction: function(cluster) {
                    const count = cluster.getChildCount();
                    const monthName = getMonthName(monthNum);
                    
                    // Create custom cluster icon with month color
                    return L.divIcon({
                        html: `<div style="
                            background-color: ${getMonthColor(monthNum)};
                            width: 16px;
                            height: 16px;
                            border-radius: 50%;
                            border: 1px solid white;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            font-weight: bold;
                            font-size: 9px;
                        ">
                            ${count}
                        </div>`,
                        className: `month-cluster month-${monthNum}`,
                        iconSize: [30, 30]
                    });
                }
            });
            
            // Create individual markers for this month
            monthObservations.forEach(obs => {
                const lat = obs.geojson.coordinates[1];
                const lng = obs.geojson.coordinates[0];
                
                // Create custom marker
                const marker = L.circleMarker([lat, lng], {
                    radius: 5,
                    fillColor: getMonthColor(monthNum),
                    color: '#ffffff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 1
                });
                
                // Bind popup
                const popupContent = createMonthlyPopupContent(obs, monthNum);
                marker.bindPopup(popupContent);
                
                // Add to this month's cluster
                monthCluster.addLayer(marker);
            });
            
            // Store the cluster
            monthlyClusters[monthNum] = monthCluster;
            
            // Add to map
            monthCluster.addTo(mymap);
            
            console.log(`Month ${monthNum}: ${monthObservations.length} observations`);
        });
        
        // Update legend to show completion
        addMonthlyLegend(false);
        
        // Fit map to show all markers if we have any
        const allClusters = Object.values(monthlyClusters);
        if (allClusters.length > 0) {
            const allMarkers = L.featureGroup(allClusters);
            mymap.fitBounds(allMarkers.getBounds().pad(0.1));
        }
        
    }, 100);
}

// Function to create popup content for monthly markers
function createMonthlyPopupContent(obs, month) {
    const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ];
    
    const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
    const observer = obs.user?.login || 'Unknown';
    const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
    const observedDate = new Date(obs.observed_on);
    const formattedDate = observedDate.toLocaleDateString();
    
    return `
        <div style="max-width: 250px;">
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                ${photoUrl ? '<img src="' + photoUrl + '" style="width: 60px; height: 60px; object-fit: cover; margin-right: 10px; border-radius: 3px;">' : 
                  '<div style="width: 60px; height: 60px; margin-right: 10px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; border-radius: 3px; color: #999; font-size: 12px;">No photo</div>'}
                <div style="flex: 1;">
                    <strong style="font-size: 14px; display: block; margin-bottom: 3px;">${taxonName}</strong>
                    <div style="font-size: 11px; color: ${getMonthColor(month)}; font-weight: bold; margin-bottom: 3px;">
                        ${monthNames[month - 1]}
                    </div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 5px;">By: ${observer}</div>
                </div>
            </div>
            <div style="font-size: 11px; margin-bottom: 8px;">
                <strong>Observed:</strong> ${formattedDate}<br>
                <strong>Location:</strong> ${obs.geojson.coordinates[1].toFixed(6)}, ${obs.geojson.coordinates[0].toFixed(6)}<br>
                ${obs.positional_accuracy ? `<strong>Accuracy:</strong> ${obs.positional_accuracy}m<br>` : ''}
                <strong>Grade:</strong> ${obs.quality_grade}
            </div>
            <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" 
               style="display: block; text-align: center; background: ${getMonthColor(month)}; color: white; padding: 6px; border-radius: 4px; text-decoration: none; font-size: 12px;">
                View on iNaturalist
            </a>
        </div>
    `;
}

// Helper function to get month name
function getMonthName(month) {
    const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return monthNames[month - 1] || 'Unknown';
}

// Function to add monthly legend
function addMonthlyLegend(loading = true) {
    // Remove existing legend if present
    if (window.monthlyLegendControl) {
        mymap.removeControl(window.monthlyLegendControl);
    }
    
    const legend = L.control({ position: 'bottomleft' });
    
    legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'month-legend');
        div.style.cssText = `
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 12px;
            max-width: 180px;
            min-height: 120px;
        `;
        
        if (loading) {
            div.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 5px;">
                    Loading Monthly View...
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px 0;">
                    <div class="monthly-loading-spinner" style="
                        width: 30px;
                        height: 30px;
                        border: 3px solid #f3f3f3;
                        border-top: 3px solid #4caf50;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                        margin-bottom: 10px;
                    "></div>
                    <div style="font-size: 10px; color: #666; text-align: center;">
                        Loading observations...<br>
                        <span id="monthly-loading-count">0</span> loaded
                    </div>
                </div>
            `;
        } else {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            div.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 5px;">
                    Observation Month
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 8px;">
                    ${monthNames.map((monthName, index) => {
                        const monthNum = index + 1;
                        const monthColor = getMonthColor(monthNum);
                        return `
                            <div style="display: flex; align-items: center; margin-bottom: 2px;">
                                <div style="width: 12px; height: 12px; background-color: ${monthColor}; border-radius: 50%; margin-right: 5px; border: 1px solid #ddd;"></div>
                                <span style="font-size: 10px;">${monthName}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 8px; font-size: 9px; color: #666; border-top: 1px solid #eee; padding-top: 5px;">
                    • Clusters show same month only<br>
                </div>
            `;
        }
        
        return div;
    };
    
    legend.addTo(mymap);
    window.monthlyLegendControl = legend;
}

// Function to update loading progress in legend
function updateMonthlyLegendProgress(loaded, total) {
    if (!window.monthlyLegendControl) return;
    
    const legendDiv = document.querySelector('.month-legend');
    if (!legendDiv) return;
    
    const countElement = legendDiv.querySelector('#monthly-loading-count');
    if (countElement) {
        countElement.textContent = `${loaded.toLocaleString()}`;
        
        // Update progress message based on percentage
        const progressPercent = total > 0 ? Math.round((loaded / total) * 100) : 0;
        const messageElement = countElement.previousElementSibling;
        if (messageElement && messageElement.nodeType === 3) { // Text node
            messageElement.textContent = `Loading observations... ${progressPercent}%`;
        }
    }
}

// Function to complete loading and show month colors
function completeMonthlyLegend() {
    // Re-add legend without loading state
    addMonthlyLegend(false);
}

// Function to clear monthly view
function clearMonthlyView() {
    // Remove all month clusters
    Object.values(monthlyClusters).forEach(cluster => {
        if (cluster && mymap.hasLayer(cluster)) {
            mymap.removeLayer(cluster);
        }
    });
    
    // Clear references
    monthlyClusters = {};
    monthlyMarkers = {};
    
    // Remove legend
    if (window.monthlyLegendControl) {
        mymap.removeControl(window.monthlyLegendControl);
        window.monthlyLegendControl = null;
    }
}

function toggleIconicTaxon(taxon) {
   let currentValue = filters.get('iconic_taxa');
   let taxa = currentValue ? currentValue.split(',') : [];
   
   if (taxa.includes(taxon)) {
      taxa = taxa.filter(t => t !== taxon);
   } else {
      taxa.push(taxon);
   }
   
   if (taxa.length > 0) {
      filters.set('iconic_taxa', taxa.join(','));
   } else {
      filters.delete('iconic_taxa');
   }
   updateCategoryButtons();
}

function handleDateTypeChange() {
   const dateType = document.getElementById('date-type').value;
   const exactDate = document.getElementById('exact-date');
   const dateRange = document.getElementById('date-range');
   const dateMonth = document.getElementById('date-month');
   
   exactDate.style.display = 'none';
   dateRange.style.display = 'none';
   dateMonth.style.display = 'none';
   
   // Clear conflicting date filters when switching date types
   if (dateType === 'exact') {
      exactDate.style.display = 'block';
      // Clear other date filters from the map
      filters.delete('d1');
      filters.delete('d2');
      filters.delete('month');
      // Clear other date input fields
      document.getElementById('date-start').value = '';
      document.getElementById('date-end').value = '';
      document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   } else if (dateType === 'range') {
      dateRange.style.display = 'block';
      // Clear other date filters from the map
      filters.delete('on');
      filters.delete('month');
      // Clear other date input fields
      document.getElementById('exact-date').value = '';
      document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   } else if (dateType === 'month') {
      dateMonth.style.display = 'block';
      // Clear other date filters from the map
      filters.delete('on');
      filters.delete('d1');
      filters.delete('d2');
      // Clear other date input fields
      document.getElementById('exact-date').value = '';
      document.getElementById('date-start').value = '';
      document.getElementById('date-end').value = '';
   } else {
      // 'any' - clear all date filters
      filters.delete('on');
      filters.delete('d1');
      filters.delete('d2');
      filters.delete('month');
      // Clear all date input fields
      document.getElementById('exact-date').value = '';
      document.getElementById('date-start').value = '';
      document.getElementById('date-end').value = '';
      document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   }
}

function updateMonthFilter() {
   const monthCheckboxes = document.querySelectorAll('#date-month input[type="checkbox"]');
   const selectedMonths = Array.from(monthCheckboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);
   
   if (selectedMonths.length > 0) {
      filters.set('month', selectedMonths.join(','));
   } else {
      filters.delete('month');
   }
}

function applyAllFilters() {
    // Save slider value before applying filters
    saveSliderValueToFilters();
    
    let params = new URLSearchParams(window.location.search);
    
    // Clear existing filter params
    const currentView = filters.get('view') || params.get('view') || 'default';
    ['captive', 'verifiable', 'quality_grade', 'on', 'd1', 'd2', 'month', 
     'iconic_taxa', 'view', 'compare_exclude_param', 'taxon_name', 'place_name', 'place_id', 'histogram_enabled', 'zoom_level'].forEach(p => params.delete(p));
    
    // Add current filters
    filters.forEach((value, key) => {
        params.set(key, value);
    });
    
    // Preserve view if it was previously set
    if (currentView && !filters.has('view')) {
        params.set('view', currentView);
    }
    
    // Add histogram state if enabled
    if (histogramSearchEnabled) {
        params.set('histogram_enabled', 'true');
    }
    
    // Add date filters if set
    const dateType = document.getElementById('date-type').value;
    if (dateType === 'exact') {
        const exactDate = document.getElementById('exact-date').value;
        if (exactDate) {
            params.set('on', exactDate);
            filters.set('on', exactDate);
        }
    } else if (dateType === 'range') {
        const startDate = document.getElementById('date-start').value;
        const endDate = document.getElementById('date-end').value;
        if (startDate) {
            params.set('d1', startDate);
            filters.set('d1', startDate);
        }
        if (endDate) {
            params.set('d2', endDate);
            filters.set('d2', endDate);
        }
    } else if (dateType === 'month') {
        updateMonthFilter();
    }
    
    // Add compare exclude param if in subsetratio view
    if (filters.get('view') === 'subsetratio' || currentView === 'subsetratio') {
        const compareParam = document.getElementById('compare-exclude-param').value;
        if (compareParam) {
            params.set('compare_exclude_param', compareParam);
            filters.set('compare_exclude_param', compareParam);
        }
    }
    
    // Add search inputs
    const taxonName = document.getElementById('taxon_name').value;
    const placeName = document.getElementById('place_name').value;
    const placeId = document.getElementById('place_id').value;
    
    if (taxonName) {
        params.set('taxon_name', taxonName);
    }
    
    if (placeName) {
        params.set('place_name', placeName);
        if (placeId) {
            params.set('place_id', placeId);
        }
    }
    
    // If monthly view is selected, initialize it after page reload
    if (filters.get('view') === 'monthly' || currentView === 'monthly') {
        params.set('view', 'monthly');
    }
    
    // Reload with filters
    window.location.href = window.location.pathname + '?' + params.toString();
}

function resetAllFilters() {
   filters.clear();
   
   // Reset checkboxes
   document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
   document.querySelectorAll('input[type="radio"]').forEach(rb => rb.checked = false);
   document.querySelector('input[name="view"][value="default"]').checked = true;
   
   // Reset selects
   document.getElementById('date-type').selectedIndex = 0;
   handleDateTypeChange();
   
   // Reset subsetratio
   document.getElementById('subsetratio-params').style.display = 'none';
   document.getElementById('compare-exclude-param').value = '';
   
   // Reset date inputs
   document.getElementById('exact-date').value = '';
   document.getElementById('date-start').value = '';
   document.getElementById('date-end').value = '';
   
   // Reset month checkboxes
   document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   
   // Reset category buttons
   updateCategoryButtons();
}

function initializeFilterValues() {
    const params = new URLSearchParams(window.location.search);
    
    // First, clear the filters map completely
    filters.clear();
    
    // Set view radio
    const view = params.get('view') || 'default';
    document.querySelector(`input[name="view"][value="${view}"]`).checked = true;
    
    // Only add view to filters if it's not the default
    if (view !== 'default') {
        filters.set('view', view);
    }
    
    if (view === 'subsetratio') {
        document.getElementById('subsetratio-params').style.display = 'block';
        const compareParam = params.get('compare_exclude_param');
        if (compareParam) {
            document.getElementById('compare-exclude-param').value = compareParam;
            filters.set('compare_exclude_param', compareParam);
        }
    }
    
    // Set histogram state from URL
    const histogramEnabled = params.get('histogram_enabled') === 'true';
    if (histogramEnabled) {
        histogramSearchEnabled = true;
        elevationSearchConfirmed = true;
        const histogramCheckbox = document.getElementById('enable-histogram');
        if (histogramCheckbox) {
            histogramCheckbox.checked = true;
        }
        
		if (view === 'elevation') {
			// Restore slider from URL
			restoreSliderFromURL();
			
			// Show slider
			const sliderContainer = document.getElementById('accuracy-slider-container');
			if (sliderContainer) {
				sliderContainer.style.display = 'block';
			}
		}
        
    } else {
        histogramSearchEnabled = false;
        elevationSearchConfirmed = false;
        const histogramCheckbox = document.getElementById('enable-histogram');
        if (histogramCheckbox) {
            histogramCheckbox.checked = false;
        }
        
		if (view !== 'elevation') {
			// Hide slider
			const sliderContainer = document.getElementById('accuracy-slider-container');
			if (sliderContainer) {
				sliderContainer.style.display = 'none';
			}
		}
    }
   
   // Set checkboxes
   const checkboxes = {
      'captive=false': 'filter-wild',
      'captive=true': 'filter-captive',
      'verifiable=true': 'filter-verifiable',
      'quality_grade=research': 'filter-research',
      'quality_grade=needs_id': 'filter-needsid'
   };
   
   Object.entries(checkboxes).forEach(([paramValue, checkboxId]) => {
      const [param, value] = paramValue.split('=');
      const checkbox = document.getElementById(checkboxId);
      if (checkbox && params.get(param) === value) {
         checkbox.checked = true;
         filters.set(param, value);
      }
   });
   
   // Set date fields - ONLY ONE date type should be active at a time
   if (params.has('on')) {
      document.getElementById('date-type').value = 'exact';
      document.getElementById('exact-date').value = params.get('on');
      filters.set('on', params.get('on'));
   } else if (params.has('d1')) {
      document.getElementById('date-type').value = 'range';
      document.getElementById('date-start').value = params.get('d1');
      document.getElementById('date-end').value = params.get('d2') || '';
      filters.set('d1', params.get('d1'));
      if (params.get('d2')) {
         filters.set('d2', params.get('d2'));
      }
   } else if (params.has('month')) {
      document.getElementById('date-type').value = 'month';
      const months = params.get('month').split(',');
      const monthCheckboxes = document.querySelectorAll('#date-month input[type="checkbox"]');
      monthCheckboxes.forEach(cb => {
         if (months.includes(cb.value)) {
            cb.checked = true;
         }
      });
      filters.set('month', params.get('month'));
   } else {
      document.getElementById('date-type').value = 'any';
   }
   handleDateTypeChange();
   
   // Set iconic taxa
   const iconicTaxa = params.get('iconic_taxa');
   if (iconicTaxa) {
      filters.set('iconic_taxa', iconicTaxa);
   }
   
   // These are search parameters, not filter parameters
   const searchParams = ['taxon_name', 'place_name', 'place_id'];
   searchParams.forEach(param => {
      if (params.has(param)) {
         // These are search parameters, not filter parameters
         // We track them separately if needed
      }
   });
   
   // Don't count 'view=default' in filters since it's the default
   if (filters.has('view') && filters.get('view') === 'default') {
      filters.delete('view');
   }
   
   updateCategoryButtons();
}

// Simple function to get current zoom level for elevation collection
function getCurrentZoomLevel() {
    if (!histogramSearchEnabled) return 12;
    
    const accuracySlider = document.getElementById('accuracy-tolerance-slider');
    const zoomLevel = accuracySlider ? parseInt(accuracySlider.value) : 12;
    
    // Validate range
    if (isNaN(zoomLevel) || zoomLevel < 0 || zoomLevel > 15) {
        return 12;
    }
    
    return zoomLevel;
}

// Autocomplete functions with place_id support
function handleTaxonSearch(event) {
   if (event.key === 'Enter') {
      applySearch();
   } else if (event.target.value.length > 2) {
      fetchTaxonAutocomplete(event.target.value);
   }
   updateClearButton('taxon_name');
}

function handlePlaceSearch(event) {
   if (event.key === 'Enter') {
      applySearch();
   } else if (event.target.value.length > 2) {
      fetchPlaceAutocomplete(event.target.value);
   }
   updateClearButton('place_name');
}

function clearTaxonSearch() {
   document.getElementById('taxon_name').value = '';
   hideAutocomplete('taxon');
   updateClearButton('taxon_name');
}

function clearPlaceSearch() {
   document.getElementById('place_name').value = '';
   document.getElementById('place_id').value = '';
   selectedPlaceId = null;
   hideAutocomplete('place');
   updateClearButton('place_name');
}

function updateClearButton(fieldId) {
   const field = document.getElementById(fieldId);
   const clearBtn = field.nextElementSibling;
   clearBtn.style.display = field.value ? 'inline' : 'none';
}

function fetchTaxonAutocomplete(query) {
   const url = `https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(query)}`;
   
   fetch(url)
      .then(response => response.json())
      .then(data => {
         showAutocomplete('taxon', data.results || []);
      })
      .catch(error => {
         console.error('Error fetching taxon autocomplete:', error);
      });
}

function fetchPlaceAutocomplete(query) {
   const url = `https://api.inaturalist.org/v1/places/autocomplete?q=${encodeURIComponent(query)}`;
   
   fetch(url)
      .then(response => response.json())
      .then(data => {
         showAutocomplete('place', data.results || []);
      })
      .catch(error => {
         console.error('Error fetching place autocomplete:', error);
      });
}

function showAutocomplete(type, results) {
   hideAutocomplete(type);
   
   if (results.length === 0) return;
   
   const input = document.getElementById(type === 'taxon' ? 'taxon_name' : 'place_name');
   const container = input.parentElement;
   
   const autocomplete = document.createElement('div');
   autocomplete.className = 'ui-autocomplete ui-front ui-widget ui-widget-content';
   autocomplete.id = type === 'taxon' ? 'taxon-autocomplete' : 'place-autocomplete';
   
   results.forEach(result => {
      const item = document.createElement('div');
      item.className = 'ui-menu-item ac-result';
      
      let html = '';
      if (type === 'taxon') {
         const thumb = result.default_photo?.square_url || 'https://static.inaturalist.org/sites/1-logo.svg';
         const title = result.preferred_common_name || result.name;
         const subtitle = result.preferred_common_name ? `<i>${result.name}</i>` : (result.rank || '');
         
         html = `
            <div class="ac" data-taxon-id="${result.id}">
               <div class="ac-thumb">
                  <img src="${thumb}" alt="${title}">
               </div>
               <div class="ac-label">
                  <div>
                     <span class="title">${title}</span>
                     <span class="subtitle">${subtitle}</span>
                  </div>
               </div>
               <a class="ac-view" target="_blank" href="https://www.inaturalist.org/taxa/${result.id}">View</a>
            </div>
         `;
         
         item.onclick = () => {
            input.value = result.preferred_common_name || result.name;
            hideAutocomplete(type);
         };
      } else {
         const title = result.display_name || result.name;
         
         html = `
            <div class="ac" data-place-id="${result.id}">
               <div class="ac-label">
                  <div>
                     <span class="title">${title}</span>
                  </div>
               </div>
               <a class="ac-view" target="_blank" href="https://www.inaturalist.org/places/${result.id}">View</a>
            </div>
         `;
         
         item.onclick = () => {
            input.value = result.display_name || result.name;
            storePlaceId(result.id);
            hideAutocomplete(type);
         };
      }
      
      item.innerHTML = html;
      autocomplete.appendChild(item);
   });
   
   container.appendChild(autocomplete);
   positionAutocomplete(input, autocomplete);
}

function hideAutocomplete(type) {
   const id = type === 'taxon' ? 'taxon-autocomplete' : 'place-autocomplete';
   const existing = document.getElementById(id);
   if (existing) {
      existing.remove();
   }
}

function positionAutocomplete(input, autocomplete) {
   const rect = input.getBoundingClientRect();
   autocomplete.style.position = 'absolute';
   autocomplete.style.top = `38.1px`;
   autocomplete.style.left = `0px`;
   autocomplete.style.width = `${rect.width}px`;
   autocomplete.style.display = 'block';
   autocomplete.style.zIndex = '1003';
}

document.addEventListener('click', function(event) {
   if (!event.target.closest('.ac-chooser')) {
      hideAutocomplete('taxon');
      hideAutocomplete('place');
   }
});

function applySearch() {
    const taxonName = document.getElementById('taxon_name').value;
    const placeName = document.getElementById('place_name').value;
    const placeId = document.getElementById('place_id').value;
    
    let params = new URLSearchParams(window.location.search);
    
    // Get current view
    const currentView = filters.get('view') || params.get('view') || 'default';
    
    if (taxonName) {
        params.set('taxon_name', taxonName);
    } else {
        params.delete('taxon_name');
    }
    
    if (placeName) {
        params.set('place_name', placeName);
        if (placeId) {
            params.set('place_id', placeId);
        }
    } else {
        params.delete('place_name');
        params.delete('place_id');
    }
    
    // If monthly view is selected, we need to set it in URL
    if (currentView === 'monthly') {
        params.set('view', 'monthly');
    }
    
    window.location.href = window.location.pathname + '?' + params.toString();
}

// AWS Terrain Tiles Utility Functions
function latLonToTile(lat, lon, zoom) {
    const latRad = lat * Math.PI / 180;
    const n = Math.pow(2, zoom);

    const xTile = Math.floor((lon + 180) / 360 * n);
    const yTile = Math.floor(
        (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n
    );

    return { x: xTile, y: yTile, z: zoom };
}

function groupPointsByTile(points, zoom) {
    const groups = {};

    for (const p of points) {
        const tile = latLonToTile(p.lat, p.lng, zoom);
        const key = `${tile.z}/${tile.x}/${tile.y}`;

        if (!groups[key]) groups[key] = [];
        groups[key].push({ 
            ...p, 
            tile,
            pixelX: null,
            pixelY: null
        });
    }

    return groups;
}

function getTileURL(z, x, y) {
    return `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`;
}

function latLonToPixelInTile(lat, lng, tile, zoom) {
    const n = Math.pow(2, zoom);

    const x = ((lng + 180) / 360 * n - tile.x) * 256;
    const y =
        ((1 -
            Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) /
            Math.PI) /
            2 *
            n -
            tile.y) *
        256;

    return { 
        x: Math.floor(x), 
        y: Math.floor(y),
        // Ensure within bounds
        inBounds: x >= 0 && x < 256 && y >= 0 && y < 256
    };
}

function readElevation(ctx, x, y) {
    if (x < 0 || x >= 256 || y < 0 || y >= 256) return null;
    
    const p = ctx.getImageData(x, y, 1, 1).data;
    return p[0] * 256 + p[1] + p[2] / 256 - 32768;
}

// Load tile image with error handling
async function loadTileImage(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = (err) => {
            console.warn(`Failed to load tile: ${url}`, err);
            reject(new Error(`Tile load failed: ${url}`));
        };
        img.src = url;
    });
}

// Batch processor for AWS Terrain Tiles
async function getElevationsForPoints(points, zoomLevel) {
    // Make sure zoomLevel is a number
    zoomLevel = parseInt(zoomLevel);
    if (isNaN(zoomLevel) || zoomLevel < 0 || zoomLevel > 15) {
        console.warn(`Invalid zoom level ${zoomLevel}, using default 12`);
        zoomLevel = 12;
    }
    
    console.log(`Processing ${points.length} points at zoom ${zoomLevel}`);
    
    const groups = groupPointsByTile(points, zoomLevel);
    const results = [];
    const failedTiles = new Set();
    let processedTiles = 0;
    const totalTiles = Object.keys(groups).length;

    console.log(`Grouped into ${totalTiles} tiles at zoom ${zoomLevel}`);

    // Track missing points for debugging
    const missingPointsDebug = [];
    const successfulPoints = [];
    
	let globalMissingPoints = [];
	missingPointsDebug.forEach(point => {
		globalMissingPoints.push({
			...point,
			zoomLevel: zoomLevel
		});
	});

	// And after processing, if there are missing points, visualize them:
	if (globalMissingPoints.length > 0) {
		console.log(`Total missing points across all tiles: ${globalMissingPoints.length}`);
		
		// Visualize on map
		setTimeout(() => {
			visualizeMissingElevations(globalMissingPoints, zoomLevel);
		}, 1000);
	}

    // Process tiles in parallel with concurrency limit
    const concurrencyLimit = 6;
    const tileKeys = Object.keys(groups);
    
    for (let i = 0; i < tileKeys.length; i += concurrencyLimit) {
        const batch = tileKeys.slice(i, i + concurrencyLimit);
        const batchPromises = batch.map(async (key) => {
            try {
                const [z, x, y] = key.split("/").map(Number);
                const url = getTileURL(z, x, y);
                
                // Update loading progress
                processedTiles++;
                const progressPercent = 40 + (processedTiles / totalTiles * 40);
                updateLoadingProgress(
                    progressPercent,
                    `Loading tile ${processedTiles}/${totalTiles} (zoom ${zoomLevel})`
                );

                const img = await loadTileImage(url);
                const canvas = document.createElement("canvas");
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                // Process all points in this tile
				for (const p of groups[key]) {
					const pix = latLonToPixelInTile(p.lat, p.lng, p.tile, zoomLevel);
					
					if (pix.inBounds) {
						const elev = readElevation(ctx, pix.x, pix.y);
						if (elev !== null) {
							// Check if elevation is reasonable
							if (elev > -1000 && elev < 9000) {
								results.push({
									id: p.id,
									lat: p.lat,  // Use the ORIGINAL lat/lng from the point
									lng: p.lng,  // Not from the pixel calculation
									elevation: elev * 3.28084,
									observation: p.obs,
									originalLat: p.lat,  // Debug: store original
									originalLng: p.lng   // Debug: store original
								});
								
                                successfulPoints.push({
                                    lat: p.lat,
                                    lng: p.lng,
                                    elevation: elev,
                                    tile: key,
                                    pixel: pix
                                });
                            } else {
                                // Invalid elevation range
                                missingPointsDebug.push({
                                    type: 'invalid_elevation',
                                    lat: p.lat,
                                    lng: p.lng,
                                    elevation: elev,
                                    tile: key,
                                    pixel: pix,
                                    reason: `Elevation ${elev} outside reasonable range (-1000 to 9000m)`
                                });
                                console.debug(`Invalid elevation ${elev} for point ${p.lat},${p.lng} in tile ${key}`);
                            }
                        } else {
                            // Couldn't read elevation
                            missingPointsDebug.push({
                                type: 'null_elevation',
                                lat: p.lat,
                                lng: p.lng,
                                tile: key,
                                pixel: pix,
                                reason: 'Elevation read returned null'
                            });
                            console.debug(`Null elevation for point ${p.lat},${p.lng} in tile ${key}`);
                        }
                    } else {
                        // Point out of tile bounds
                        missingPointsDebug.push({
                            type: 'out_of_bounds',
                            lat: p.lat,
                            lng: p.lng,
                            tile: key,
                            pixel: pix,
                            reason: `Point at pixel (${pix.x},${pix.y}) outside tile bounds (0-255)`
                        });
                        console.debug(`Point ${p.lat},${p.lng} out of tile bounds in tile ${key}`);
                    }
                }
                
                return { success: true, tile: key, points: groups[key].length };
            } catch (error) {
                console.warn(`Failed to process tile ${key}:`, error);
                failedTiles.add(key);
                
                // Add all points in this tile to missing debug
                if (groups[key]) {
                    groups[key].forEach(p => {
                        missingPointsDebug.push({
                            type: 'tile_load_failed',
                            lat: p.lat,
                            lng: p.lng,
                            tile: key,
                            reason: `Tile load failed: ${error.message}`
                        });
                    });
                }
                
                return { success: false, tile: key, error: error.message };
            }
        });

        const batchResults = await Promise.allSettled(batchPromises);
        const successful = batchResults.filter(r => r.status === 'fulfilled' && r.value?.success === true).length;
        
        // Log tile failures if any
        batchResults.forEach((result, index) => {
            if (result.status === 'fulfilled' && result.value?.success === false) {
                console.warn(`Tile ${batch[index]} failed:`, result.value.error);
            }
        });
        
        // Small delay between batches to be polite to the API
        if (i + concurrencyLimit < tileKeys.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    console.log(`Successfully processed ${results.length} points, failed tiles: ${failedTiles.size}`);
    
    // Debug output for missing points
    if (missingPointsDebug.length > 0) {
        console.group('Missing Elevations Analysis');
        console.log(`Total missing: ${missingPointsDebug.length}`);
        
        // Group by reason
        const byReason = missingPointsDebug.reduce((acc, point) => {
            acc[point.type] = (acc[point.type] || 0) + 1;
            return acc;
        }, {});
        
        console.log('Missing by reason:', byReason);
        
        // Show sample of missing points
        if (missingPointsDebug.length <= 20) {
            console.log('All missing points:', missingPointsDebug);
        } else {
            console.log('Sample of missing points (first 10):', missingPointsDebug.slice(0, 10));
        }
        
        // Check if missing points are clustered geographically
        const missingByTile = missingPointsDebug.reduce((acc, point) => {
            if (point.tile) {
                acc[point.tile] = (acc[point.tile] || 0) + 1;
            }
            return acc;
        }, {});
        
        console.log('Missing by tile:', missingByTile);
        
        console.groupEnd();
    }
    
    // Show successful points summary
    if (successfulPoints.length > 0) {
        console.group('Successful Elevations Summary');
        console.log(`Successfully retrieved ${successfulPoints.length} elevations`);
        
        // Calculate elevation statistics
        const elevations = successfulPoints.map(p => p.elevation);
        const minElev = Math.min(...elevations);
        const maxElev = Math.max(...elevations);
        const avgElev = elevations.reduce((a, b) => a + b, 0) / elevations.length;
        
        console.log(`Elevation range: ${minElev.toFixed(1)}m to ${maxElev.toFixed(1)}m`);
        console.log(`Average elevation: ${avgElev.toFixed(1)}m`);
        
        // Show distribution across tiles
        const byTile = successfulPoints.reduce((acc, point) => {
            acc[point.tile] = (acc[point.tile] || 0) + 1;
            return acc;
        }, {});
        
        console.log('Successful points per tile (sample):', 
            Object.entries(byTile).slice(0, 5).map(([tile, count]) => `${tile}: ${count}`));
        
        console.groupEnd();
    }
    
    return results;
}

// Elevation Histogram Variables
let elevationHistogramVisible = true;
let elevationData = [];
let histogramContainer;
let isCollectingData = false;
let elevationRequestQueue = [];
let isCancellingElevation = false;
let nextRequestTime = 0;
let openTopoDataEnabled = true;
let delayTimer = null;
// Elevation histogram search toggle
let histogramSearchEnabled = false;
let elevationSearchConfirmed = false;

// Function to update zoom level display
function updateZoomLevelDisplay(value) {
    const display = document.getElementById('zoom-level-display');
    if (display) {
        display.textContent = value;
    }
}

function toggleHistogramSearch() {
    const checkbox = document.getElementById('enable-histogram');
    const sliderContainer = document.getElementById('accuracy-slider-container');
    
    if (checkbox.checked) {
		histogramSearchEnabled = true;
		elevationSearchConfirmed = true;
		checkbox.checked = true;
		
		// Show accuracy slider
		if (sliderContainer) {
			sliderContainer.style.display = 'block';
		}
		
		updateFilter('histogram_enabled', 'true', true);
    } else {
        histogramSearchEnabled = false;
        elevationSearchConfirmed = false;
        
        // Hide accuracy slider
        if (sliderContainer) {
            sliderContainer.style.display = 'none';
        }
        
        updateFilter('histogram_enabled', 'false', true);
        
        // Hide histogram if visible
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
    }
}

// Save slider value to filters when applying search
function saveSliderValueToFilters() {
    const accuracySlider = document.getElementById('accuracy-tolerance-slider');
    if (accuracySlider && histogramSearchEnabled) {
        filters.set('zoom_level', accuracySlider.value);
    } else {
        filters.delete('zoom_level');
    }
}

// Restore slider value from URL
function restoreSliderFromURL() {
    const params = new URLSearchParams(window.location.search);
    const zoomLevel = params.get('zoom_level');
    const histogramEnabled = params.get('histogram_enabled') === 'true';
    
    if (zoomLevel && histogramEnabled) {
        const accuracySlider = document.getElementById('accuracy-tolerance-slider');
        const zoomDisplay = document.getElementById('zoom-level-display');
        
        if (accuracySlider) {
            accuracySlider.value = zoomLevel;
        }
        if (zoomDisplay) {
            zoomDisplay.textContent = zoomLevel;
        }
    }
}

function checkLargeDatasetWarning(observationCount) {
    if (observationCount > 10000 && histogramSearchEnabled) {
		const warningMessage = `⚠️ Large Dataset Detected ⚠️

Found ${observationCount.toLocaleString()} observations with coordinates.

Consider filtering observations or decreasing accuracy tolerance before elevation lookup.

Click OK to continue anyway, or Cancel to stop elevation lookup.`;
        
        const continueAnyway = confirm(warningMessage);
        
        if (!continueAnyway) {
            // User cancelled, disable histogram search
            histogramSearchEnabled = false;
            elevationSearchConfirmed = false;
            document.getElementById('enable-histogram').checked = false;
            return false;
        }
    }
    return true;
}

// Function to initialize elevation histogram
function initElevationHistogram() {
    // Don't create histogram if search is disabled
    if (!histogramSearchEnabled) {
        // If histogram exists, hide it
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
        histogramStarted = false;
        return;
    }
    
    // Check if histogram is already running
    if (histogramStarted && document.getElementById('elevationHistogram')) {
        // Histogram already exists and is running, just make sure it's visible
        const histogram = document.getElementById('elevationHistogram');
        histogram.style.display = 'block';
        return;
    }
    
    // Check if histogram already exists (but not started yet)
    if (document.getElementById('elevationHistogram')) {
        // Just show it and refresh data if it exists
        const histogram = document.getElementById('elevationHistogram');
        histogram.style.display = 'block';
        histogramStarted = true;
        
        // Refresh data if we don't have any
        if (elevationData.length === 0) {
            collectElevationData();
        }
        return;
    }
    
    // Mark as started
    histogramStarted = true;
    
    // Create histogram container WITH LOADING CLASS
    const histogramDiv = document.createElement('div');
    histogramDiv.className = 'elevation-histogram loading';
    histogramDiv.id = 'elevationHistogram';
    histogramDiv.innerHTML = `
        <div class="histogram-header">
            <h3 class="histogram-title">Loading...</h3>
            <div class="histogram-controls">
                <button class="close-btn minimize" onclick="toggleElevationHistogram()" title="Minimize">−</button>
            </div>
        </div>
        <div class="histogram-content">
            <div class="loading-indicator" id="loadingIndicator">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading elevation data...</div>
                <div class="loading-progress">
                    <div class="loading-progress-bar" id="loadingProgressBar"></div>
                </div>
            </div>
            <div class="histogram-container" style="display: none;" id="histogramContainer">
                <div class="histogram-y-axis" id="histogramYAxis"></div>
                <div class="histogram-chart" id="histogramChart"></div>
            </div>
            <div class="histogram-x-axis" id="histogramXAxis"></div>
            <div class="histogram-stats" id="histogramStats"></div>
        </div>
    `;
    
    document.body.appendChild(histogramDiv);
    
    // Collect elevation data
    collectElevationData();
}

// Function to toggle histogram visibility
function toggleElevationHistogram() {
   const histogram = document.getElementById('elevationHistogram');
   const btn = histogram.querySelector('.close-btn.minimize');
   
   if (histogram.classList.contains('minimized')) {
      histogram.classList.remove('minimized');
      btn.innerHTML = '−';
      btn.title = "Minimize";
      elevationHistogramVisible = true;
   } else {
      histogram.classList.add('minimized');
      btn.innerHTML = '↕';
      btn.title = "Restore";
      elevationHistogramVisible = false;
   }
}

// Function to update loading progress
function updateLoadingProgress(percentage, text) {
    const progressBar = document.getElementById('loadingProgressBar');
    const loadingText = document.getElementById('loadingStatusText');
    
    if (progressBar) {
        progressBar.style.width = `${percentage}%`;
    }
    if (loadingText && text) {
        loadingText.textContent = text;
    }
}

// Function to collect elevation data using AWS Terrain Tiles
async function collectElevationData() {
    // Check if histogram search is enabled
    if (!histogramSearchEnabled) {
        // If histogram exists, hide it
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
        histogramStarted = false;
        return;
    }
    
    if (isCollectingData) return;
    isCollectingData = true;
    isCancellingElevation = false;
    
    const histogram = document.getElementById('elevationHistogram');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const histogramContainer = document.getElementById('histogramContainer');
    
    // Ensure histogram has loading class
    if (histogram) {
        histogram.classList.add('loading');
        // Update title to show loading
        const title = histogram.querySelector('.histogram-title');
        if (title) {
            title.textContent = 'Loading...';
        }
    }
    
    // Reset UI
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingStatusText">Fetching observations...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loadingProgressBar"></div>
            </div>
            <button id="cancelElevationBtn" class="btn" style="margin-top: 12px; padding: 6px 12px; font-size: 11px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Cancel Elevation Lookup
            </button>
        `;
        
        document.getElementById('cancelElevationBtn').addEventListener('click', cancelElevationLookup);
    }
    
    if (histogramContainer) histogramContainer.style.display = 'none';
    
    // Get current zoom level
    const zoomLevel = getCurrentZoomLevel();
    console.log("Collecting elevation data with zoom level:", zoomLevel);
    
    updateLoadingProgress(0, `Fetching observations (Zoom: ${zoomLevel})...`);
    
    elevationData = [];
    
    try {
        // Get ALL observations (not limited to 500)
        let allObservations = [];
        let page = 1;
        const perPage = 200;
        let hasMore = true;
        let totalObservations = 0;
        
        // First, get total count to show accurate progress
        const countUrl = `${inat_urlbase}observations?per_page=1&${winurlparams}`;
        const countResponse = await fetch(countUrl);
        const countData = await countResponse.json();
        totalObservations = countData.total_results || 0;

        const shouldContinue = checkLargeDatasetWarning(totalObservations);
        if (!shouldContinue) {
            isCollectingData = false;
            
            // Update histogram to show disabled state
            const histogram = document.getElementById('elevationHistogram');
            if (histogram) {
                histogram.style.display = 'none';
            }
            return;
        }
        
        if (totalObservations === 0) {
            showNoObservationsMessage();
            return;
        }
        
        updateLoadingProgress(5, `Found ${totalObservations} total observations (Zoom: ${zoomLevel})...`);
        
        // Fetch observations in batches
        while (hasMore && !isCancellingElevation) {
            const observationsUrl = `${inat_urlbase}observations?per_page=${perPage}&page=${page}&${winurlparams}`;
            const response = await fetch(observationsUrl);
            const data = await response.json();
            
            if (!data.results || data.results.length === 0) {
                hasMore = false;
                break;
            }
            
            allObservations = allObservations.concat(data.results);
            
            updateLoadingProgress(
                5 + (allObservations.length / totalObservations * 25),
                `Loaded ${allObservations.length} of ${totalObservations} observations...`
            );
            
            if (data.results.length < perPage) {
                hasMore = false;
            }
            page++;
        }
        
        if (isCancellingElevation) {
            showCancellationMessage();
            return;
        }
        
        if (allObservations.length === 0) {
            showNoObservationsMessage();
            return;
        }
        
        // Filter to observations with coordinates
        const validObservations = allObservations.filter(obs => 
            obs.geojson && obs.geojson.coordinates
        );
        
        updateLoadingProgress(30, `Processing ${validObservations.length} observations with coordinates (Zoom: ${zoomLevel})...`);
        
        if (validObservations.length === 0) {
            showNoObservationsMessage();
            return;
        }
        
        // Prepare ALL coordinates for bulk lookup
        const coordsToLookup = validObservations.map(obs => ({
            lat: obs.geojson.coordinates[1],
            lng: obs.geojson.coordinates[0],
            obs: obs
        }));
        
        updateLoadingProgress(35, `Getting elevations for ${coordsToLookup.length} locations using AWS Terrain Tiles (Zoom: ${zoomLevel})...`);
        
        // Use AWS Terrain Tiles for elevation lookup
        const elevations = await getBulkElevation(coordsToLookup);
        
        if (isCancellingElevation) {
            showCancellationMessage();
            return;
        }
        
        updateLoadingProgress(90, 'Processing data...');
        
        // Combine elevation data with observations
        coordsToLookup.forEach((coord, index) => {
            if (elevations[index] !== null) {
                elevationData.push({
                    id: coord.obs.id,
                    lat: coord.lat,
                    lng: coord.lng,
                    elevation: elevations[index],
                    observation: coord.obs
                });
            }
        });
        
        // Remove loading class and expand
        if (histogram) {
            histogram.classList.remove('loading');
            // Update title
            const title = histogram.querySelector('.histogram-title');
            if (title) {
                title.textContent = 'Elevation Distribution (ft)';
            }
        }
        
        // Hide loading, show histogram
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        if (histogramContainer) histogramContainer.style.display = 'flex';
        
        // Create histogram if we have data
        if (elevationData.length > 0) {
            createHorizontalHistogram();
        } else {
            showNoElevationDataMessage();
        }
        
        updateLoadingProgress(100, 'Complete!');
        
    } catch (error) {
        console.error('Error collecting elevation data:', error);
        showErrorMessage('Error loading elevation data');
        
        // Ensure loading class is removed even on error
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.classList.remove('loading');
        }
    } finally {
        isCollectingData = false;
        if (delayTimer) {
            clearTimeout(delayTimer);
            delayTimer = null;
        }
    }
}

// Function to cancel elevation lookup
function cancelElevationLookup() {
    isCancellingElevation = true;
    
    // Clear any pending delay timer
    if (delayTimer) {
        clearTimeout(delayTimer);
        delayTimer = null;
    }
    
    // Remove loading class
    const histogram = document.getElementById('elevationHistogram');
    if (histogram) {
        histogram.classList.remove('loading');
        // Update title
        const title = histogram.querySelector('.histogram-title');
        if (title) {
            title.textContent = 'Elevation Distribution (ft)';
        }
    }

    const histogramStatsBox = document.getElementById('histogramStats');
	if (histogramStatsBox){
		histogramStatsBox.style.display = 'none';
	}
    
    // Update UI to show cancellation
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">⏹️</div>
                <div class="empty-state-title">Cancelled</div>
                <div class="empty-state-subtitle">Elevation lookup was cancelled</div>
                <button class="btn" onclick="refreshElevationHistogram()" style="margin-top: 12px; padding: 6px 12px; font-size: 11px;">
                    Try Again
                </button>
            </div>
        `;
    }
}

// Function to show cancellation message
function showCancellationMessage() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">⏹️</div>
                <div class="empty-state-title">Cancelled</div>
                <div class="empty-state-subtitle">Elevation lookup was cancelled</div>
                <button class="btn" onclick="refreshElevationHistogram()" style="margin-top: 12px; padding: 6px 12px; font-size: 11px;">
                    Try Again
                </button>
            </div>
        `;
    }
}

// Function for bulk elevation lookup using AWS Terrain Tiles
async function getBulkElevation(coordinates) {
    if (coordinates.length === 0) return [];
    
    // Get current zoom level
    const zoomLevel = getCurrentZoomLevel();
    console.log(`Using zoom level ${zoomLevel} for ${coordinates.length} coordinates`);
    
    // Convert coordinates to the format needed
    const points = coordinates.map((coord, index) => ({
        id: `coord-${index}`,
        lat: coord.lat,
        lng: coord.lng,
        obs: coord.obs,
        originalIndex: index  // Keep track of original position
    }));
    
    try {
        updateLoadingProgress(40, `Getting elevations using AWS Terrain Tiles (zoom ${zoomLevel})...`);
        
        // Use AWS Terrain Tiles
        const awsResults = await getElevationsForPoints(points, zoomLevel);
        
        console.log(`AWS returned ${awsResults.length} elevation results`);
        
        // Initialize all elevations as null
        const elevations = new Array(coordinates.length).fill(null);
        
        // Track which AWS results have been used
        const usedAwsResults = new Array(awsResults.length).fill(false);
        // Track which coordinates have been matched
        const matchedCoordinates = new Array(coordinates.length).fill(false);
        
        let matchedCount = 0;
        
        // First pass: Exact matching with small tolerance
        const EXACT_TOLERANCE = 0.00001; // ~1 meter
        
        awsResults.forEach((awsResult, awsIndex) => {
            // Find the closest unmatched coordinate
            let bestMatchIndex = -1;
            let bestDistance = Infinity;
            
            for (let coordIndex = 0; coordIndex < coordinates.length; coordIndex++) {
                if (matchedCoordinates[coordIndex]) continue; // Skip already matched
                
                const coord = coordinates[coordIndex];
                const latDiff = Math.abs(coord.lat - awsResult.lat);
                const lngDiff = Math.abs(coord.lng - awsResult.lng);
                
                // Calculate simple Euclidean distance (good enough for small distances)
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                
                if (distance < bestDistance && distance < EXACT_TOLERANCE) {
                    bestDistance = distance;
                    bestMatchIndex = coordIndex;
                }
            }
            
            if (bestMatchIndex !== -1) {
                elevations[bestMatchIndex] = awsResult.elevation;
                matchedCoordinates[bestMatchIndex] = true;
                usedAwsResults[awsIndex] = true;
                matchedCount++;
                
            }
        });
        
        console.log(`First pass: ${matchedCount} exact matches`);
        
        // Second pass: More relaxed matching for remaining
        const RELAXED_TOLERANCE = 0.001; // ~100 meters
        let relaxedMatches = 0;
        
        awsResults.forEach((awsResult, awsIndex) => {
            if (usedAwsResults[awsIndex]) return; // Skip already used
            
            let bestMatchIndex = -1;
            let bestDistance = Infinity;
            
            for (let coordIndex = 0; coordIndex < coordinates.length; coordIndex++) {
                if (matchedCoordinates[coordIndex]) continue;
                
                const coord = coordinates[coordIndex];
                const latDiff = Math.abs(coord.lat - awsResult.lat);
                const lngDiff = Math.abs(coord.lng - awsResult.lng);
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                
                if (distance < bestDistance && distance < RELAXED_TOLERANCE) {
                    bestDistance = distance;
                    bestMatchIndex = coordIndex;
                }
            }
            
            if (bestMatchIndex !== -1) {
                elevations[bestMatchIndex] = awsResult.elevation;
                matchedCoordinates[bestMatchIndex] = true;
                usedAwsResults[awsIndex] = true;
                matchedCount++;
                relaxedMatches++;
                
                console.debug(`Relaxed match: AWS result ${awsIndex} → coordinate ${bestMatchIndex} (distance: ${bestDistance.toFixed(6)})`);
            }
        });
        
        console.log(`Second pass: ${relaxedMatches} relaxed matches`);
        console.log(`Total matched: ${matchedCount} out of ${awsResults.length} AWS results`);
        
        // Check for unused AWS results
        const unusedAwsResults = awsResults.filter((_, index) => !usedAwsResults[index]);
        if (unusedAwsResults.length > 0) {
            console.warn(`${unusedAwsResults.length} AWS results not matched to any coordinate:`);
            unusedAwsResults.forEach((result, i) => {
                console.warn(`  ${i}: ${result.lat.toFixed(6)}, ${result.lng.toFixed(6)} = ${result.elevation?.toFixed(1)}ft`);
            });
        }
        
        // Check for unmatched coordinates
        const missingIndices = [];
        matchedCoordinates.forEach((matched, index) => {
            if (!matched) {
                missingIndices.push(index);
                const coord = coordinates[index];
                console.warn(`Unmatched coordinate ${index}: ${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}`);
            }
        });
        
        console.log(`Unmatched coordinates: ${missingIndices.length}`);
        
        if (missingIndices.length > 0 && !isCancellingElevation) {
            console.log(`Missing ${missingIndices.length} elevations, attempting fallback`);
            
            // Only use fallback if we have significant missing data
            if (missingIndices.length < coordinates.length * 0.1) { // Less than 10% missing
                console.log(`Only ${missingIndices.length} missing (${(missingIndices.length/coordinates.length*100).toFixed(1)}%), skipping fallback`);
            } else {
                updateLoadingProgress(80, `Using fallback for ${missingIndices.length} missing elevations...`);
                
                // Use fallback for missing points
                const fallbackBatchSize = 10;
                for (let i = 0; i < missingIndices.length; i += fallbackBatchSize) {
                    if (isCancellingElevation) break;
                    
                    const batchIndices = missingIndices.slice(i, i + fallbackBatchSize);
                    const batchPromises = batchIndices.map(async (index) => {
                        const coord = coordinates[index];
                        const elevation = await getElevationForCoordinate(coord.lat, coord.lng);
                        elevations[index] = elevation;
                        
                        updateLoadingProgress(
                            80 + (i / missingIndices.length * 15),
                            `Fallback: ${Math.min(i + batchIndices.length, missingIndices.length)}/${missingIndices.length}...`
                        );
                    });
                    
                    await Promise.all(batchPromises);
                    
                    if (i + fallbackBatchSize < missingIndices.length && !isCancellingElevation) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
            }
        }
        
        // Final statistics
        const validElevations = elevations.filter(e => e !== null).length;
        console.log(`Final result: ${validElevations} valid elevations out of ${coordinates.length} total (${(validElevations/coordinates.length*100).toFixed(1)}%)`);
        
        // Debug: Show distribution of elevations
        const elevationValues = elevations.filter(e => e !== null).map(e => e);
        if (elevationValues.length > 0) {
            const min = Math.min(...elevationValues);
            const max = Math.max(...elevationValues);
            const avg = elevationValues.reduce((a, b) => a + b, 0) / elevationValues.length;
            console.log(`Elevation stats: min=${min.toFixed(1)}ft, max=${max.toFixed(1)}ft, avg=${avg.toFixed(1)}ft`);
        }
        
        return elevations;
        
    } catch (error) {
        console.error('AWS Terrain Tiles processing failed:', error);
        
        // Fall back to original method
        console.warn('Falling back to original elevation lookup method');
        return await getBulkElevationFallback(coordinates);
    }
}

// Function to visualize missing elevations on the map
function visualizeMissingElevations(missingPoints, zoomLevel) {
    if (!missingPoints || missingPoints.length === 0) return;
    
    console.group('Visualizing Missing Elevations');
    
    // Create a layer group for visualization
    if (window.missingElevationsLayer) {
        mymap.removeLayer(window.missingElevationsLayer);
    }
    
    window.missingElevationsLayer = L.layerGroup().addTo(mymap);
    
    // Different colors for different failure reasons
    const colorMap = {
        'invalid_elevation': '#ff0000', // Red
        'null_elevation': '#ff9900',    // Orange
        'out_of_bounds': '#ffff00',     // Yellow
        'tile_load_failed': '#9900ff',  // Purple
        'no_match': '#00ffff'           // Cyan
    };
    
    missingPoints.forEach(point => {
        const marker = L.circleMarker([point.lat, point.lng], {
            radius: 6,
            fillColor: colorMap[point.type] || '#000000',
            color: '#ffffff',
            weight: 2,
            opacity: 0.8,
            fillOpacity: 0.6
        });
        
        const popupContent = `
            <div style="font-size: 12px;">
                <strong>Missing Elevation</strong><br>
                <strong>Type:</strong> ${point.type}<br>
                <strong>Reason:</strong> ${point.reason}<br>
                <strong>Location:</strong> ${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}<br>
                <strong>Tile:</strong> ${point.tile || 'N/A'}<br>
                <strong>Zoom:</strong> ${zoomLevel}<br>
                ${point.pixel ? `<strong>Pixel:</strong> (${point.pixel.x},${point.pixel.y}) inBounds: ${point.pixel.inBounds}` : ''}
            </div>
        `;
        
        marker.bindPopup(popupContent);
        marker.addTo(window.missingElevationsLayer);
    });
    
    console.log(`Added ${missingPoints.length} markers for missing elevations`);
    console.log('Legend:');
    Object.entries(colorMap).forEach(([type, color]) => {
        console.log(`%c${type}`, `color: ${color}; font-weight: bold;`);
    });
    console.groupEnd();
    
    // Add a control to remove the layer
    const controlDiv = document.createElement('div');
    controlDiv.innerHTML = `
        <button onclick="removeMissingElevationsLayer()" 
                style="padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer;">
            Clear Missing Points
        </button>
    `;
    
    L.control({position: 'bottomright'}).onAdd = function() {
        return controlDiv;
    }.addTo(mymap);
}

function removeMissingElevationsLayer() {
    if (window.missingElevationsLayer) {
        mymap.removeLayer(window.missingElevationsLayer);
        window.missingElevationsLayer = null;
    }
}

// Fallback to original method if AWS fails
async function getBulkElevationFallback(coordinates) {
    if (coordinates.length === 0) return [];
    
    const elevations = new Array(coordinates.length).fill(null);
    
    // Reset cancellation flag
    isCancellingElevation = false;
    
    // Check if Open Topo Data is available (within daily limits)
    if (openTopoDataEnabled) {
        try {
            // Split coordinates into chunks (100 max) (OpenTopoData limit)
			const chunkSize = 100;
			const coordinateChunks = [];

			for (let i = 0; i < coordinates.length; i += chunkSize) {
				coordinateChunks.push(coordinates.slice(i, i + chunkSize));
			}

			// Track how many we can actually process
			let coordinatesToProcess = coordinates.length;
			if (coordinates.length > 10000) {
				coordinatesToProcess = 10000;
				console.warn(`Processing first 10,000 of ${coordinates.length} coordinates (daily limit)`);
			}

			const chunksToProcess = Math.ceil(coordinatesToProcess / chunkSize);

			// Process each chunk
			for (let chunkIndex = 0; chunkIndex < chunksToProcess; chunkIndex++) {
				if (isCancellingElevation) {
					console.log('Elevation lookup cancelled');
					break;
				}
				
				// Check if open topo data is still enabled
				if (!openTopoDataEnabled) {
					break;
				}
				
				const chunk = coordinateChunks[chunkIndex];
				const chunkStartIndex = chunkIndex * chunkSize;
				
				// Create locations string for Open Topo Data API
				const locations = chunk.map(coord => 
					`${coord.lat.toFixed(6)},${coord.lng.toFixed(6)}`
				).join('|');
				
				// Calculate delay based on rate limiting
				const now = Date.now();
				const delay = Math.max(0, nextRequestTime - now);
				
				if (delay > 0) {
					updateLoadingProgress(
						40 + (chunkIndex / chunksToProcess * 40),
						`Getting elevations: ${chunkIndex * chunkSize + 1}-${Math.min((chunkIndex + 1) * chunkSize, coordinates.length)} of ${coordinates.length}`
					);
					
					await new Promise(resolve => {
						delayTimer = setTimeout(resolve, delay);
					});
					delayTimer = null;
				}
				
				updateLoadingProgress(
					40 + (chunkIndex / chunksToProcess * 40),
					`Getting elevations: ${chunkIndex * chunkSize + 1}-${Math.min((chunkIndex + 1) * chunkSize, coordinates.length)} of ${coordinates.length}`
				);
                
				// Make request to Open Topo Data through CORS proxy
				const openTopoDataUrl = `https://api.opentopodata.org/v1/aster30m?locations=${locations}`;
				const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(openTopoDataUrl)}`;

				try {
					const response = await fetch(proxyUrl, {
						method: 'GET',
						headers: {
							'Accept': 'application/json',
						}
					});
					
					if (response.ok) {
						const data = await response.json();
                        
                        if (data.results && data.results.length === chunk.length) {
                            data.results.forEach((result, resultIndex) => {
                                const globalIndex = chunkStartIndex + resultIndex;
                                if (result.elevation !== null && result.elevation !== undefined) {
                                    // Convert meters to feet (1 meter = 3.28084 feet)
                                    elevations[globalIndex] = result.elevation * 3.28084;
                                }
                            });
                            
							// Update rate limiting - add delay between requests
							nextRequestTime = Date.now() + 1500; // 1.5 second delay between requests
                        } else {
                            console.warn('Open Topo Data returned unexpected response format');
                        }
                    } else if (response.status === 429) {
                        // Rate limited
                        console.warn('Open Topo Data rate limited, switching to fallback');
                        openTopoDataEnabled = false;
                        break;
                    } else {
                        console.warn(`Open Topo Data error ${response.status}, switching to fallback`);
                        openTopoDataEnabled = false;
                        break;
                    }
                } catch (error) {
                    console.warn('Open Topo Data request failed:', error);
                    openTopoDataEnabled = false;
                    break;
                }
            }
        } catch (error) {
            console.warn('Open Topo Data bulk processing failed:', error);
            openTopoDataEnabled = false;
        }
    }
    
    // Fill in any missing elevations with fallback services
    if (!openTopoDataEnabled || elevations.some(e => e === null)) {
        updateLoadingProgress(80, 'Using fallback elevation services...');
        
        // Try Open-Elevation for remaining null values
        const remainingIndices = elevations.map((elev, index) => elev === null ? index : -1)
                                          .filter(i => i !== -1);
        
        if (remainingIndices.length > 0) {
            // Process remaining coordinates in smaller batches for fallback
            const fallbackBatchSize = 10; // Smaller batches for fallback
            let processedCount = 0;
            
            for (let i = 0; i < remainingIndices.length; i += fallbackBatchSize) {
                if (isCancellingElevation) break;
                
                const batchIndices = remainingIndices.slice(i, i + fallbackBatchSize);
                const batchPromises = batchIndices.map(async (index) => {
                    const coord = coordinates[index];
                    const elevation = await getElevationForCoordinate(coord.lat, coord.lng);
                    elevations[index] = elevation;
                    processedCount++;
                    
                    updateLoadingProgress(
                        80 + (processedCount / remainingIndices.length * 15),
                        `Fallback: ${processedCount}/${remainingIndices.length}...`
                    );
                });
                
                await Promise.all(batchPromises);
                
                // Small delay between fallback batches to avoid overwhelming APIs
                if (i + fallbackBatchSize < remainingIndices.length && !isCancellingElevation) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }
    }
    
    return elevations;
}

// Function to get elevation for a single coordinate (fallback)
async function getElevationForCoordinate(lat, lng) {
   // Try USGS API first (feet)
   const usgsUrl = `https://epqs.nationalmap.gov/v1/json?y=${lat}&x=${lng}&output=json&units=Feet`;
   
   try {
      const response = await fetch(usgsUrl);
      const data = await response.json();
      
      if (data && data.value !== undefined && data.value > -1000000) {
         return data.value;
      }
   } catch (error) {
      console.warn('USGS elevation API failed for coordinate:', lat, lng);
   }
   
   // Try Open-Elevation API (meters)
   try {
      const openElevationUrl = `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`;
      const response = await fetch(openElevationUrl);
      const data = await response.json();
      
      if (data.results && data.results[0] && data.results[0].elevation !== undefined) {
         // Convert meters to feet (1 meter = 3.28084 feet)
         return data.results[0].elevation * 3.28084;
      }
   } catch (error) {
      console.warn('Open-Elevation API failed for coordinate:', lat, lng);
   }
   
   return null;
}

// Function to create horizontal histogram with evenly spaced elevation intervals
function createHorizontalHistogram() {
   if (elevationData.length === 0) return;
   
   // Extract elevations
   const elevations = elevationData.map(d => d.elevation);
   
   // Calculate statistics
   const minElevation = Math.min(...elevations);
   const maxElevation = Math.max(...elevations);
   const avgElevation = elevations.reduce((a, b) => a + b, 0) / elevations.length;
   
   // Determine elevation range - default to 6000ft, extend if needed
   const DEFAULT_MAX_ELEVATION = 6000;
   const maxElevationForChart = Math.max(DEFAULT_MAX_ELEVATION, Math.ceil(maxElevation / 1000) * 1000);
   
   // Use 500ft intervals, with at least 12 bins (0-6000ft)
   const binWidth = 500;
   const numBins = Math.ceil(maxElevationForChart / binWidth);
   
   // Create bin ranges
   const binRanges = [];
   for (let i = 0; i < numBins; i++) {
      const start = i * binWidth;
      const end = (i + 1) * binWidth;
      binRanges.push({ 
         start: Math.round(start), 
         end: Math.round(end),
         label: `${Math.round(start)}-${Math.round(end)} ft`
      });
   }
   
   // Initialize bins with zeros
   const bins = new Array(numBins).fill(0);
   
   // Populate bins
   for (const elevation of elevations) {
      let binIndex = Math.floor(elevation / binWidth);
      
      // Clamp to valid range
      if (binIndex < 0) binIndex = 0;
      if (binIndex >= numBins) binIndex = numBins - 1;
      
      bins[binIndex]++;
   }
   
   // Find max count for scaling (ignore empty bins for scaling)
   const nonZeroBins = bins.filter(count => count > 0);
   const maxCount = nonZeroBins.length > 0 ? Math.max(...nonZeroBins) : 0;
   
   // Create Y-axis with labels every 1000ft
   const histogramYAxis = document.getElementById('histogramYAxis');
   histogramYAxis.innerHTML = '<div class="y-axis-line"></div>';
   
   // Add Y-axis labels (show every 1000ft)
   const labelsToShow = [];
   for (let elevation = 0; elevation <= maxElevationForChart; elevation += 1000) {
      labelsToShow.push(elevation);
   }
   
   // Reverse labels so highest is at top
   labelsToShow.reverse().forEach(elevation => {
      const labelDiv = document.createElement('div');
      labelDiv.className = 'histogram-y-label';
      labelDiv.textContent = elevation === 0 ? '0' : `${elevation / 1000}k`;
      
      // Calculate position percentage (0% at bottom, 100% at top)
      const positionPercent = (elevation / maxElevationForChart) * 100;
      labelDiv.style.position = 'absolute';
      labelDiv.style.top = `${100 - positionPercent}%`;
      labelDiv.style.transform = 'translateY(-50%)';
      
      histogramYAxis.appendChild(labelDiv);
   });
   
   // Create horizontal bars
   const histogramChart = document.getElementById('histogramChart');
   histogramChart.innerHTML = '';
   
   // Add grid lines
   const chartGrid = document.createElement('div');
   chartGrid.className = 'chart-grid';
   
   // Add grid lines for each 1000ft
   for (let elevation = 0; elevation <= maxElevationForChart; elevation += 1000) {
      const positionPercent = (elevation / maxElevationForChart) * 100;
      const gridLine = document.createElement('div');
      gridLine.className = 'grid-line';
      gridLine.style.top = `${100 - positionPercent}%`;
      chartGrid.appendChild(gridLine);
   }
   
   histogramChart.appendChild(chartGrid);
   
   // Create rows (one for each 500ft bin, reversed so highest elevation is at top)
   const reversedBins = [...bins].reverse();
   const reversedBinRanges = [...binRanges].reverse();
   
   reversedBins.forEach((count, index) => {
	   const row = document.createElement('div');
	   row.className = 'histogram-row';
	   
	   // Add elevation range label on the left side
	   const rangeLabel = document.createElement('div');
	   rangeLabel.className = 'elevation-range-label';
	   rangeLabel.textContent = `${reversedBinRanges[index].start}–${reversedBinRanges[index].end}`;
	   rangeLabel.style.cssText = `
		  position: absolute;
		  left: 0px;
		  top: 45%;
		  transform: translateY(-50%);
		  font-size: 8px;
		  font-weight: 600;
		  color: #FFFFFF;
		  opacity: 0;
		  transition: opacity 0.2s ease;
		  pointer-events: none;
		  white-space: nowrap;
		  padding: 2px 4px;
		  border-radius: 3px;
		  z-index: 1001;
	   `;
	   row.appendChild(rangeLabel);
	   
	   // Create the bar
	   const bar = document.createElement('div');
	   bar.className = count > 0 ? 'histogram-bar' : 'histogram-bar empty';
	   
	   // Calculate width based on count (percentage of max count)
	   const widthPercent = maxCount > 0 && count > 0 ? (count / maxCount) * 100 : 0;
	   bar.style.width = `${widthPercent}%`;
	   
	   if (count > 0) {
		  // Add color gradient based on elevation
		  const elevation = reversedBinRanges[index].start;
		  const elevationRatio = elevation / maxElevationForChart;
		  const hue = 210 - (elevationRatio * 60); // Blue to purple gradient
		  bar.style.background = `linear-gradient(90deg, 
			 hsl(${hue}, 75%, 60%) 0%, 
			 hsl(${hue + 10}, 80%, 50%) 100%)`;
		  
		  // Add hover effect
		  bar.onmouseenter = () => {
			 bar.style.filter = 'brightness(1.15)';
			 rangeLabel.style.opacity = '1';
		  };
		  bar.onmouseleave = () => {
			 bar.style.filter = 'brightness(1)';
			 rangeLabel.style.opacity = '0';
		  };
		  
		  // Add count label inside bar
		  const countLabel = document.createElement('div');
		  countLabel.className = 'bar-count';
		  countLabel.textContent = count;
		  bar.appendChild(countLabel);
		  
		  // Click to show observations in this elevation range
		  bar.onclick = () => {
			 showObservationsInRange(reversedBinRanges[index].start, reversedBinRanges[index].end);
		  };
	   }
	   
	   row.appendChild(bar);
	   histogramChart.appendChild(row);
	});
   
   // Create X-axis labels
   const xAxis = document.getElementById('histogramXAxis');
   if (maxCount <= 10) {
      // For small counts, show all values
      const xLabels = [];
      for (let i = 0; i <= maxCount; i++) {
         xLabels.push(i);
      }
      xAxis.innerHTML = `
         <div class="histogram-x-labels" style="justify-content: space-between;">
            ${xLabels.map(val => '<span>' + val + '</span>').join('')}
         </div>
      `;
   } else {
      // For larger counts, show up to 5 evenly spaced values
      const numLabels = Math.min(5, maxCount);
      const xLabels = [];
      for (let i = 0; i <= numLabels; i++) {
         const value = Math.round((i / numLabels) * maxCount);
         xLabels.push(value);
      }
      
      // Remove duplicates
      const uniqueLabels = [...new Set(xLabels)];
      
      xAxis.innerHTML = `
         <div class="histogram-x-labels">
            ${uniqueLabels.map(val => '<span>' + val + '</span>').join('')}
         </div>
      `;
   }
   
   // Update stats panel
   const stats = document.getElementById('histogramStats');
   stats.innerHTML = `
      <div class="stats-grid">
         <div class="stat-item">
            <div class="stat-label">Min Elevation</div>
            <div class="stat-value">${Math.round(minElevation)}<span class="stat-unit">ft</span></div>
         </div>
         <div class="stat-item">
            <div class="stat-label">Max Elevation</div>
            <div class="stat-value">${Math.round(maxElevation)}<span class="stat-unit">ft</span></div>
         </div>
         <div class="stat-item">
            <div class="stat-label">Average</div>
            <div class="stat-value">${Math.round(avgElevation)}<span class="stat-unit">ft</span></div>
         </div>
         <div class="stat-item">
            <div class="stat-label">Observations</div>
            <div class="stat-value">${elevationData.length}</div>
         </div>
      </div>
   `;
   
   // Update title to show elevation range
   const histogramTitle = document.querySelector('.histogram-title');
   if (histogramTitle) {
      if (maxElevation > DEFAULT_MAX_ELEVATION) {
         histogramTitle.textContent = `Elevation Distribution (ft)`;
      } else {
         histogramTitle.textContent = `Elevation Distribution (ft)`;
      }
   }
}

// Variables for observation list
let observationListPanel = null;
let currentObservations = [];
let currentRange = null;
let selectedObservationIndex = -1;
let itemsPerPage = 15;
let currentPage = 1;

function showObservationsInRange(minElev, maxElev) {
    const observationsInRange = elevationData.filter(d => 
        d.elevation >= minElev && d.elevation < maxElev
    );
    
    currentObservations = observationsInRange;
    currentRange = { minElev, maxElev };
    currentPage = 1;
    itemsPerPage = 15; // Items per page for the list
    
    // First, clear any existing markers from previous range selections
    clearObservationMarkers();
    
    // Create observation list panel if it doesn't exist
    createObservationListPanel();
    
    // Update the panel title with elevation range and count
    updateObservationListTitle(minElev, maxElev, observationsInRange.length);
    
    // Load first page of observations into the list
    loadObservationListPage();
    
    // Create markers for ALL observations in range (not just first page)
    createMarkersForAllObservations();
    
    // Show the panel
    observationListPanel.style.display = 'flex';
}

function createObservationListPanel() {
    if (observationListPanel) return;
    
    observationListPanel = document.createElement('div');
    observationListPanel.className = 'observation-list-panel';
    observationListPanel.id = 'observationListPanel';
	observationListPanel.innerHTML = `
		<div class="observation-list-header">
			<h3 id="observationListTitle">Observations</h3>
			<div class="observation-list-controls">
				<button onclick="clearObservationMarkers()" title="Clear Markers">🗑️</button>
				<button onclick="toggleObservationList()" title="Minimize">−</button>
			</div>
		</div>
		<div class="observation-list-content">
			<div class="observation-list-items" id="observationListItems">
				<div class="no-observations">
					Select an elevation range from the histogram
				</div>
			</div>
		</div>
		<div class="observation-list-footer">
			<button class="load-more-btn" onclick="loadMoreObservations()" id="loadMoreBtn" disabled>
				Load More Observations
			</button>
		</div>
	`;
    
    document.body.appendChild(observationListPanel);
}

function updateObservationListTitle(minElev, maxElev, count) {
    const title = document.getElementById('observationListTitle');
    if (title) {
        title.textContent = `${minElev}-${maxElev} ft (${count})`;
    }
}

function loadObservationListPage() {
    const itemsContainer = document.getElementById('observationListItems');
    if (!itemsContainer) return;
    
    // Clear existing items
    itemsContainer.innerHTML = '';
    
    // Calculate start and end indices for first page
    const startIndex = 0;
    const endIndex = Math.min(itemsPerPage, currentObservations.length);
    const pageObservations = currentObservations.slice(startIndex, endIndex);
    
    if (pageObservations.length === 0) {
        itemsContainer.innerHTML = `
            <div class="no-observations">
                No observations in this elevation range
            </div>
        `;
        return;
    }
    
    // Create items for each observation
    pageObservations.forEach((obsData, index) => {
        const globalIndex = index;
        const obs = obsData.observation;
        const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
        const observer = obs.user?.login || 'Unknown';
        const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
        
        // Get elevation color
        const elevationColor = getElevationColor(obsData.elevation);
        
        const item = document.createElement('div');
        item.className = `observation-item ${selectedObservationIndex === globalIndex ? 'selected' : ''}`;
        item.onclick = () => highlightObservationFromList(globalIndex);
        
        item.innerHTML = `
            <div class="observation-item-photo ${!photoUrl ? 'no-photo' : ''}">
                ${photoUrl ? `<img src="${photoUrl}" alt="${taxonName}">` : 'No Photo'}
            </div>
            <div class="observation-item-details">
                <div class="observation-item-name" title="${taxonName}">${taxonName}</div>
                <div class="observation-item-elevation" style="color: ${elevationColor}">
                    ${Math.round(obsData.elevation)} ft
                </div>
                <div class="observation-item-meta">
                    <span>By: ${observer}</span>
                    <span>•</span>
                    <span>${obs.observed_on?.substring(0, 10) || 'Unknown date'}</span>
                </div>
            </div>
        `;
        
        itemsContainer.appendChild(item);
    });
    
    // Update load more button
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    if (loadMoreBtn) {
        if (endIndex >= currentObservations.length) {
            loadMoreBtn.disabled = true;
            loadMoreBtn.textContent = 'All observations loaded';
            loadMoreBtn.style.opacity = '0.6';
        } else {
            loadMoreBtn.disabled = false;
            loadMoreBtn.textContent = `Load More (${endIndex}/${currentObservations.length})`;
            loadMoreBtn.style.opacity = '1';
        }
    }
}

function getElevationColor(elevation) {
    if (!currentRange) return '#3498db';
    
    // Calculate position in current range
    const rangeSize = currentRange.maxElev - currentRange.minElev;
    const positionInRange = (elevation - currentRange.minElev) / rangeSize;
    
    // Use same color gradient as histogram (blue to purple)
    const hue = 210 - (positionInRange * 120);
    return `hsl(${hue}, 75%, 60%)`;
}

function createMarkersForAllObservations() {
    if (!currentObservations || currentObservations.length === 0) {
        console.log('No observations to create markers for');
        return;
    }
    
    console.log(`Creating markers for ${currentObservations.length} observations`);
    
    // Create a layer group for all markers
    observationMarkers = L.layerGroup();
    
    // Create a marker for EACH observation
    currentObservations.forEach((obsData, index) => {
        const elevationColor = getElevationColor(obsData.elevation);
        
        // Create marker with elevation-based color
        const marker = L.circleMarker([obsData.lat, obsData.lng], {
            radius: 6,
            fillColor: elevationColor,
            color: '#ffffff',
            weight: 1,
            opacity: 1,
            fillOpacity: 1
        });
        
        // Store the index with the marker
        marker.observationIndex = index;
        
        const obs = obsData.observation;
        const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
        const observer = obs.user?.login || 'Unknown';
        const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
        
        const markerPopupContent = `
            <div style="max-width: 250px;">
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    ${photoUrl ? '<img src="' + photoUrl + '" style="width: 60px; height: 60px; object-fit: cover; margin-right: 10px; border-radius: 3px;">' : 
                      '<div style="width: 60px; height: 60px; margin-right: 10px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; border-radius: 3px; color: #999; font-size: 12px;">No photo</div>'}
                    <div style="flex: 1;">
                        <strong style="font-size: 14px; display: block; margin-bottom: 3px;">${taxonName}</strong>
                        <div style="font-size: 11px; color: ${elevationColor}; font-weight: bold; margin-bottom: 3px;">
                            ${Math.round(obsData.elevation)} ft
                        </div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">By: ${observer}</div>
                    </div>
                </div>
                <div style="font-size: 11px; margin-bottom: 8px;">
                    <strong>Location:</strong> ${obsData.lat.toFixed(6)}, ${obsData.lng.toFixed(6)}<br>
                    <strong>Observed:</strong> ${obs.observed_on || 'Unknown date'}
                </div>
                <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" 
                   style="display: block; text-align: center; background: #4caf50; color: white; padding: 6px; border-radius: 4px; text-decoration: none; font-size: 12px;">
                    View observation on iNaturalist
                </a>
            </div>
        `;
        
        marker.bindPopup(markerPopupContent);
        marker.addTo(observationMarkers);
        
        // Add click handler to highlight in list
        marker.on('click', () => {
            highlightObservationFromList(index);
        });
        
        // Store marker reference
        observationMarkersList[index] = marker;
    });
    
    // Add the marker layer to the map
    observationMarkers.addTo(mymap);
    
    // Fit map to show ALL markers (not just first page)
    if (observationMarkersList.length > 0) {
        const group = new L.featureGroup(observationMarkersList.filter(m => m));
        mymap.fitBounds(group.getBounds().pad(0.1)); // Add 10% padding
    }
    
    console.log(`Created ${observationMarkersList.filter(m => m).length} markers on map`);
}

// Function to create markers for specific page only (for list synchronization)
function createMarkersForCurrentPageOnly() {
    // Calculate start and end indices for current page
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, currentObservations.length);
    const pageObservations = currentObservations.slice(startIndex, endIndex);
    
    // Clear any existing markers from previous page
    if (observationMarkers) {
        mymap.removeLayer(observationMarkers);
        observationMarkersList = [];
    }
    
    // Create a layer group for page markers
    observationMarkers = L.layerGroup();
    
    pageObservations.forEach((obsData, localIndex) => {
        const globalIndex = startIndex + localIndex;
        const elevationColor = getElevationColor(obsData.elevation);
        
        // Create marker with elevation-based color
        const marker = L.circleMarker([obsData.lat, obsData.lng], {
            radius: 6,
            fillColor: elevationColor,
            color: '#ffffff',
            weight: 2,
            opacity: 0.8,
            fillOpacity: 0.7
        });
        
        // Store the global index with the marker
        marker.observationIndex = globalIndex;
        
        const obs = obsData.observation;
        const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
        const observer = obs.user?.login || 'Unknown';
        const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
        
        const markerPopupContent = `
            <div style="max-width: 250px;">
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    ${photoUrl ? '<img src="' + photoUrl + '" style="width: 60px; height: 60px; object-fit: cover; margin-right: 10px; border-radius: 3px;">' : 
                      '<div style="width: 60px; height: 60px; margin-right: 10px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; border-radius: 3px; color: #999; font-size: 12px;">No photo</div>'}
                    <div style="flex: 1;">
                        <strong style="font-size: 14px; display: block; margin-bottom: 3px;">${taxonName}</strong>
                        <div style="font-size: 11px; color: ${elevationColor}; font-weight: bold; margin-bottom: 3px;">
                            ${Math.round(obsData.elevation)} ft
                        </div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">By: ${observer}</div>
                    </div>
                </div>
                <div style="font-size: 11px; margin-bottom: 8px;">
                    <strong>Location:</strong> ${obsData.lat.toFixed(6)}, ${obsData.lng.toFixed(6)}<br>
                    <strong>Observed:</strong> ${obs.observed_on || 'Unknown date'}
                </div>
                <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" 
                   style="display: block; text-align: center; background: #4caf50; color: white; padding: 6px; border-radius: 4px; text-decoration: none; font-size: 12px;">
                    View observation on iNaturalist
                </a>
            </div>
        `;
        
        marker.bindPopup(markerPopupContent);
        marker.addTo(observationMarkers);
        
        // Add click handler to highlight in list
        marker.on('click', () => {
            highlightObservationFromList(globalIndex);
        });
        
        // Store marker reference
        observationMarkersList[globalIndex] = marker;
    });
    
    // Add the marker layer to the map
    observationMarkers.addTo(mymap);
    
    // Fit map to show markers from this page only
    const validMarkers = observationMarkersList.filter(m => m);
    if (validMarkers.length > 0) {
        const group = new L.featureGroup(validMarkers);
        mymap.fitBounds(group.getBounds().pad(0.1)); // Add 10% padding
    }
}

function highlightObservationFromList(index) {
    selectedObservationIndex = index;
    
    // Update list selection
    const items = document.querySelectorAll('.observation-item');
    items.forEach((item, i) => {
        // Calculate the actual index for this item
        const startIndex = (currentPage - 1) * itemsPerPage;
        const actualIndex = startIndex + i;
        item.classList.toggle('selected', actualIndex === index);
    });
    
    // Find and highlight the corresponding marker
    if (observationMarkersList[index]) {
        // Reset all markers to their original colors
        Object.keys(observationMarkersList).forEach(key => {
            const marker = observationMarkersList[key];
            if (marker && marker.observationIndex !== undefined) {
                const markerIndex = marker.observationIndex;
                const obsData = currentObservations[markerIndex];
                if (obsData) {
                    const elevationColor = getElevationColor(obsData.elevation);
                    const isSelected = parseInt(key) === index;
                    
                    marker.setStyle({
                        fillColor: elevationColor,
                        color: isSelected ? '#ffeb3b' : '#ffffff', // Yellow border for selected
                        radius: isSelected ? 8 : 6,
                        weight: isSelected ? 3 : 2
                    });
                }
            }
        });
        
        // Open the popup for the selected marker
        observationMarkersList[index].openPopup();
        
        // Pan to the selected marker
        mymap.panTo(observationMarkersList[index].getLatLng());
        
        // Ensure the marker is visible by adjusting zoom if needed
        const markerBounds = observationMarkersList[index].getBounds();
        if (markerBounds) {
            const currentBounds = mymap.getBounds();
            if (!currentBounds.contains(markerBounds)) {
                mymap.setView(observationMarkersList[index].getLatLng(), mymap.getZoom());
            }
        }
    }
}

function loadMoreObservations() {
    currentPage++;
    
    // Calculate start and end indices for the new page
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, currentObservations.length);
    
    if (startIndex >= currentObservations.length) {
        console.log('No more observations to load');
        return;
    }
    
    console.log(`Loading page ${currentPage}: items ${startIndex + 1} to ${endIndex}`);
    
    // Get the new page of observations
    const newPageObservations = currentObservations.slice(startIndex, endIndex);
    const itemsContainer = document.getElementById('observationListItems');
    
    if (!itemsContainer || newPageObservations.length === 0) return;
    
    // Append new items to the existing list
    newPageObservations.forEach((obsData, index) => {
        const globalIndex = startIndex + index;
        const obs = obsData.observation;
        const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
        const observer = obs.user?.login || 'Unknown';
        const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
        
        // Get elevation color
        const elevationColor = getElevationColor(obsData.elevation);
        
        const item = document.createElement('div');
        item.className = `observation-item ${selectedObservationIndex === globalIndex ? 'selected' : ''}`;
        item.onclick = () => highlightObservationFromList(globalIndex);
        
        item.innerHTML = `
            <div class="observation-item-photo ${!photoUrl ? 'no-photo' : ''}">
                ${photoUrl ? `<img src="${photoUrl}" alt="${taxonName}">` : 'No Photo'}
            </div>
            <div class="observation-item-details">
                <div class="observation-item-name" title="${taxonName}">${taxonName}</div>
                <div class="observation-item-elevation" style="color: ${elevationColor}">
                    ${Math.round(obsData.elevation)} ft
                </div>
                <div class="observation-item-meta">
                    <span>By: ${observer}</span>
                    <span>•</span>
                    <span>${obs.observed_on?.substring(0, 10) || 'Unknown date'}</span>
                </div>
            </div>
        `;
        
        itemsContainer.appendChild(item);
    });
    
    // Update load more button
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    if (loadMoreBtn) {
        if (endIndex >= currentObservations.length) {
            loadMoreBtn.disabled = true;
            loadMoreBtn.textContent = 'All observations loaded';
            loadMoreBtn.style.opacity = '0.6';
        } else {
            loadMoreBtn.disabled = false;
            loadMoreBtn.textContent = `Load More (${endIndex}/${currentObservations.length})`;
            loadMoreBtn.style.opacity = '1';
        }
    }
    
    // Auto-scroll to show the newly loaded items
    const lastItem = itemsContainer.lastElementChild;
    if (lastItem) {
        lastItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function toggleObservationList() {
    if (!observationListPanel) return;
    
    const minimizeBtn = observationListPanel.querySelector('.observation-list-controls button:last-child');
    
    if (observationListPanel.classList.contains('minimized')) {
        observationListPanel.classList.remove('minimized');
        if (minimizeBtn) {
            minimizeBtn.textContent = '−';
            minimizeBtn.title = "Minimize";
        }
    } else {
        observationListPanel.classList.add('minimized');
        if (minimizeBtn) {
            minimizeBtn.textContent = '☶';
            minimizeBtn.title = "Expand";
        }
    }
}

// Variables to track observation markers
let observationMarkers = null;
let observationMarkersList = [];

// Function to clear observation markers from map
function clearObservationMarkers() {
    if (observationMarkers) {
        mymap.removeLayer(observationMarkers);
        observationMarkers = null;
    }
    observationMarkersList = [];
    selectedObservationIndex = -1;
    
    // Clear the observation list
    const itemsContainer = document.getElementById('observationListItems');
    if (itemsContainer) {
        itemsContainer.innerHTML = `
            <div class="no-observations">
                Select an elevation range from the histogram
            </div>
        `;
    }
    
    // Reset title
    const title = document.getElementById('observationListTitle');
    if (title) {
        title.textContent = 'Observations';
    }
    
    // Reset page counter
    currentPage = 1;
    
    // Reset load more button
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    if (loadMoreBtn) {
        loadMoreBtn.disabled = false;
        loadMoreBtn.textContent = 'Load More Observations';
        loadMoreBtn.style.opacity = '1';
    }
}

// Function to show message when no elevation data is available
function showNoElevationDataMessage() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const histogramContainer = document.getElementById('histogramContainer');
    const histogram = document.getElementById('elevationHistogram');
    
    // Remove loading class
    if (histogram) {
        histogram.classList.remove('loading');
    }
    
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">🗺️</div>
                <div style="font-size: 13px; margin-bottom: 5px;">No elevation data available</div>
                <div style="font-size: 11px; color: #888;">Elevation data is primarily available for locations in the USA.</div>
            </div>
        `;
    }
    if (histogramContainer) histogramContainer.style.display = 'none';
}

function showErrorMessage(message) {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const histogramContainer = document.getElementById('histogramContainer');
    const histogram = document.getElementById('elevationHistogram');
    
    // Remove loading class
    if (histogram) {
        histogram.classList.remove('loading');
    }
    
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon" style="color: #d32f2f;">❌</div>
                <div style="font-size: 13px; color: #d32f2f; margin-bottom: 5px;">Error</div>
                <div style="font-size: 11px; color: #888;">${message}</div>
            </div>
        `;
    }
    if (histogramContainer) histogramContainer.style.display = 'none';
}

// Function to show message when no observations found
function showNoObservationsMessage() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const histogramContainer = document.getElementById('histogramContainer');
    
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">🔍</div>
                <div style="font-size: 13px;">No observations found</div>
                <div style="font-size: 11px; color: #888; margin-top: 5px;">Try adjusting your search filters</div>
            </div>
        `;
    }
    if (histogramContainer) histogramContainer.style.display = 'none';
}

// Function to show error message
function showErrorMessage(message) {
   const loadingIndicator = document.getElementById('loadingIndicator');
   const histogramContainer = document.getElementById('histogramContainer');
   
   if (loadingIndicator) {
      loadingIndicator.innerHTML = `
         <div class="empty-state">
            <div class="empty-state-icon" style="color: #d32f2f;">❌</div>
            <div style="font-size: 13px; color: #d32f2f; margin-bottom: 5px;">Error</div>
            <div style="font-size: 11px; color: #888;">${message}</div>
         </div>
      `;
   }
   if (histogramContainer) histogramContainer.style.display = 'none';
}

// Function to update histogram when map view changes
function updateHistogramOnViewChange(newView) {
    const histogram = document.getElementById('elevationHistogram');
    const histogramToggle = document.getElementById('elevation-histogram-toggle');
    const sliderContainer = document.getElementById('accuracy-slider-container');
    
    if (newView === 'elevation') {
        // Show the histogram toggle
        if (histogramToggle) {
            histogramToggle.style.display = 'block';
        }
        
        // Show/hide slider based on histogram state
        if (histogramSearchEnabled && sliderContainer) {
            sliderContainer.style.display = 'block';
        } else if (sliderContainer) {
            sliderContainer.style.display = 'none';
        }
        
        // Only show histogram if search is enabled
        if (histogramSearchEnabled && histogram) {
            histogram.style.display = 'block';
        }
    } else {
        // Hide histogram toggle and slider for other views
        if (histogramToggle) {
            histogramToggle.style.display = 'none';
        }
        if (sliderContainer) {
            sliderContainer.style.display = 'none';
        }
        
        // Hide histogram if visible
        if (histogram) {
            histogram.style.display = 'none';
        }
    }
}

// Modify the existing toggleView function to handle histogram
const originalToggleView = window.toggleView;
window.toggleView = function(view) {
    // Clear monthly view if switching away from it
    if (view !== 'monthly') {
        clearMonthlyView();
    }
    originalToggleView.call(this, view);
    updateHistogramOnViewChange(view);
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    const params = new URLSearchParams(window.location.search);
    const taxonName = params.get('taxon_name');
    const placeName = params.get('place_name');
    const placeId = params.get('place_id');
    const view = params.get('view') || 'default';

    // Initialize monthly view only if it's active in URL
    if (view === 'monthly') {
        // Small delay to ensure map is loaded
        setTimeout(() => {
            // Add initial loading legend immediately
            addMonthlyLegend(true);
            initMonthlyView();
        }, 500);
    }
    
    if (taxonName) {
        document.getElementById('taxon_name').value = taxonName;
        updateClearButton('taxon_name');
    }
    
    if (placeName) {
        document.getElementById('place_name').value = placeName;
        updateClearButton('place_name');
    }
    
    if (placeId) {
        document.getElementById('place_id').value = placeId;
        selectedPlaceId = placeId;
    }
    
    // Initialize month checkbox events
    document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('change', updateMonthFilter);
    });
    
    // Initialize histogram state
    histogramSearchEnabled = false;
    elevationSearchConfirmed = false;
    histogramStarted = false;
    
    // If we're in elevation view, show the toggle
    if (view === 'elevation') {
        const histogramToggle = document.getElementById('elevation-histogram-toggle');
        if (histogramToggle) {
            histogramToggle.style.display = 'block';
        }
        
        // Check if histogram was previously enabled via URL
        const histogramEnabled = params.get('histogram_enabled') === 'true';
        if (histogramEnabled) {
            histogramSearchEnabled = true;
            elevationSearchConfirmed = true;
            const histogramCheckbox = document.getElementById('enable-histogram');
            if (histogramCheckbox) {
                histogramCheckbox.checked = true;
            }
            
            // Restore slider immediately
            restoreSliderFromURL();

			// Start histogram if not already running
			if (!histogramStarted) {
				setTimeout(() => {
					initElevationHistogram();
				}, 500);
			}
        }
    }

    // Initialize observation list panel (hidden by default)
    setTimeout(() => {
        createObservationListPanel();
        if (observationListPanel) {
            observationListPanel.style.display = 'none';
        }
    }, 100);
    
    // Hide filters initially
    hideFilters();
});

// Simple verification function
function verifySliderState() {
    const params = new URLSearchParams(window.location.search);
    const accuracySlider = document.getElementById('accuracy-tolerance-slider');
    const zoomDisplay = document.getElementById('zoom-level-display');
    
    console.log('Slider State Verification:', {
        urlHasZoomLevel: params.has('zoom_level'),
        urlZoomValue: params.get('zoom_level'),
        sliderValue: accuracySlider ? accuracySlider.value : 'no slider',
        displayValue: zoomDisplay ? zoomDisplay.textContent : 'no display',
        histogramEnabled: histogramSearchEnabled,
        matches: accuracySlider && params.get('zoom_level') ? 
                 accuracySlider.value === params.get('zoom_level') : 
                 'N/A'
    });
}

// Call verification after page loads
setTimeout(verifySliderState, 1000);

// Refresh function
function refreshElevationHistogram() {
    if (view === 'elevation' && !isCollectingData) {
        // Add loading class
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.classList.add('loading');
            // Update title to show loading
            const title = histogram.querySelector('.histogram-title');
            if (title) {
                title.textContent = 'Loading...';
            }
        }
        
		const histogramStatsBox = document.getElementById('histogramStats');
		if (histogramStatsBox){
			histogramStatsBox.style.display = 'block';
		}

        histogramStarted = false; // Allow fresh start
        collectElevationData();
    }
}

// Expose refresh function globally
window.refreshElevationHistogram = refreshElevationHistogram;

// Get parameters from the url
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));

// Check if this is a fresh load with no parameters
if (winurlparams.toString() === '' || 
    (winurlparams.toString() === 'view=default' && winurlparams.size === 1)) {
   // Redirect to default search
   const defaultParams = new URLSearchParams();
   defaultParams.set('taxon_name', 'King Bolete');
   defaultParams.set('place_name', 'Washington, US');
   defaultParams.set('place_id', '46');
   defaultParams.set('view', 'default');
   
   window.location.href = window.location.pathname + '?' + defaultParams.toString();
   // Page will reload with parameters, so stop here
   // Add a loading message or let it redirect
   document.body.innerHTML = '<div style="padding: 20px; text-align: center;">Loading default search: King Bolete in Washington, US...</div>';
   throw new Error("Redirecting to default search");
}
// Extract ALL parameters first
var taxon_name = winurlparams.get('taxon_name');
var place_name = winurlparams.get('place_name');
var taxon_id = winurlparams.get('taxon_id');
taxon_id = (taxon_id===null?null:taxon_id.split(',')[0]);
var place_id = winurlparams.get('place_id');
place_id = (place_id===null?null:place_id.split(',')[0]);
var centerlat = winurlparams.get('centerlat');
var centerlng = winurlparams.get('centerlng');
var defaultzoom = winurlparams.get('defaultzoom');
var showtaxonplace = winurlparams.get('showtaxonplace') || 'false';
var showtaxonrange = winurlparams.get('showtaxonrange') || 'false';
var showexpectednearby = winurlparams.get('showexpectednearby') || 'false';
var showplace = winurlparams.get('showplace') || 'false';
var view = winurlparams.get('view') || 'default';
var compexclparam = winurlparams.get('compare_exclude_param'); // Moved up
var thresholded = winurlparams.get('thresholded') || 'true';
winurlparams.delete('centerlat');
winurlparams.delete('centerlng');
winurlparams.delete('defaultzoom');
winurlparams.delete('showtaxonplace');
winurlparams.delete('showtaxonrange');
winurlparams.delete('showexpectednearby');
winurlparams.delete('showplace');
winurlparams.delete('view');
winurlparams.delete('compare_exclude_param');
winurlparams.delete('thresholded');
let compareurlparams = new URLSearchParams(winurlparams);
if (compexclparam) { for (p of compexclparam.split(',')) { compareurlparams.delete(p); }; };
function fdate(str) {
   str = str.replace(/t/i,' '); //replaces T (case insensitive) with a space
   str = str.replace(/([+-]\d{2}\:?\d{2})/,' ($1)'); //puts parenthesis around time zone offset
   str = str.replace(/z/i,' (+00:00)'); //replaces Z (case insensitve) with UTC
   str = str.replace('+00:00','±00:00');
   return str;
};
function fround(num,places) {
   var n = num*1;
   return n.toFixed(places); 
};
function furl(url,txt=url) { return '<a href="'+url+'">'+txt+'</a>'; };
function faddelem(etype,eparent=null,eclass=null,eid=null,ehtml=null,etext=null) {
   var eobj = document.createElement(etype);
   if (eclass!==null) { eobj.classList = eclass };
   if (eid!==null) { eobj.id = eid };
   if (ehtml!==null) { eobj.innerHTML = ehtml };
   if (etext!==null) { eobj.innerText = etext };
   if (eparent!==null) { eparent.appendChild(eobj); };
   return eobj;
};
function ffetch(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};
let inat_urlbase = 'https://api.inaturalist.org/v1/';
if (winurlparams=="") {
   var div = faddelem('div',document.body,null,'info');
   faddelem('h1',div,null,null,'Map of iNaturalist Observations');
   faddelem('p',div,null,null,'This page displays a map of iNaturalist observations. Clicking on any observation marker opens a pop-up window which provides basic details of the observation');
   faddelem('p',div,null,null,'This page requires that you input at least one filter parameter in the URL. For example, if the URL of this page is '+winurlexsearchstr +', and you want to see research grade ocotillo observations, then you would navigate to '+furl(winurlexsearchstr+'?taxon_id=49325&quality_grade=research')+' in your web browser. This page will accept most parameters documented for the '+ furl(inat_urlbase+'docs/#!/Observations/get_observations','iNaturalist API Get Observations Endpoint')+ '.');
   faddelem('p',div,null,null,'If place_id is included as a parameter, then the place polygon will be available as an optional layer in the map. If taxon_id is included as a parameter, then taxon places and taxon range will be available as optional layers in this map (if they have been defined in iNaturalist).');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=elevation", then the map will display with the USGS topo basemap (with contours in feet) by default, and the info pop-ups will include elevation (sourced from the '+furl('https://epqs.nationalmap.gov/','USGS elevation point query service')+'). USGS does not provide elevations outside of the United States. In cases where the USGS returns no data, the page will fall back to the '+furl('https://open-elevation.com/','Open-Elevation API')+'. As an example, if you want to see mountain goats in the United States, then you would navigate to '+furl(winurlexsearchstr+'?view=elevation&taxon_id=42414&place_id=1')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=heatmap", then the map will show a heatmap view of observations on a muted-color basemap. By default, clicking the heatmap will not open a info pop-up. As an example, to get an idea of where user kueda has made observations, you would navigate to '+furl(winurlexsearchstr+'?view=heatmap&user_id=kueda')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=subsetratio", then the map will compare a gridded view of one set of observations (the subset, defined in the URL) to another set (the superset, defined by a required special "compare_exclude_param" parameter, which removes one or more parameters from the subset parameter list). The color of the markers will vary based on the ratio of subset to superset for each cell (red=1.0 and blue=0.0), and they will appear on top of a gray basemap. As an example, to compare research grade plant observations to verifiable plant observations, you would navigate to '+furl(winurlexsearchstr+'?view=subsetratio&verifiable=true&quality_grade=research&taxon_id=47126&compare_exclude_param=quality_grade')+' in your web browser. Note that if you use exclusion filter parameters (ex. not_user_id) in your subset and remove them from the superset, then you may get unexpected results (because the subset would no longer be a true subset).');    //faddelem('p',div,null,null,'If a special "view" parameter is set to "=ecolandunit", then the map will display with a USGS Ecological Land Unit overlay on a dark basemap by default, and the info pop-ups will include USGS ELU information (sourced from '+furl('https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems','USGS Global Ecosystems')+'). This should work on any point of land worldwide. As an example, if you want to see maples around the world, then you would navigate to '+furl(winurlexsearchstr+'?view=ecolandunit&taxon_id=47727&defaultzoom=2')+' in your web browser.');
   faddelem('p',div,null,null,'The map used to offer a USGS Ecological Land Unit overlay on a dark basemap, with pop-ups offering detailed USGS ELU information (sourced from '+furl('https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems','USGS Global Ecosystems')+'). However, USGS no longer provides this data as of early 2025. USGS offers similar, newer data in the form of '+furl('https://www.sciencebase.gov/catalog/item/6296791ed34ec53d276bb293','World Terrestrial Ecosystems') +'. However, WTEs do not appear to be as detailed / useful as ELUs. So this map does not offer WTEs as a replacement option.');
   faddelem('p',div,null,null,'There are 2 final sets of special parameters: centerlat, centerlng, and defaultzoom can be used to set the default map center and zoom level when the map is first opened; and showtaxonplace, showtaxonrange, showexpectednearby, and showplace can be set to true to display specific layers by default.');
}
else {
   var mapdiv = faddelem('div',document.body,null,'mapid');
   // iNat Observation Layer, using grid markers at lower zooms and points at higher zooms
//   let inat_circles = {url:inat_urlbase+'colored_heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Density Circles)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_colored_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
   let inat_heat = {url:inat_urlbase+'heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Heatmap)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
//   let gbif_density_point_py = {url:'https://api.gbif.org/v2/map/occurrence/density/{z}/{x}/{y}@1x.png?srs=EPSG:3857&style=purpleYellow.point&publishingOrg=28eb1a3f-1c15-4a95-931a-4af90ecb574d',description:'iNaturalist Observations in GBIF',attribution:'<a href="https://www.gbif.org/developer/maps">GBIF occurrence data</a>'};
//   var l_inat_circles = L.tileLayer(inat_circles.url+'?'+winurlparams,{minZoom:2, maxZoom:20, attribution:inat_circles.attribution});
   var l_inat_heat = L.tileLayer(inat_heat.url+'?'+winurlparams,{minZoom:0, maxZoom:20, attribution:inat_heat.attribution});
//   var l_gbif = L.tileLayer(gbif_density_point_py.url,{minZoom:2, maxZoom:20, attribution:gbif_density_point_py.attribution});
   let inat_points = {url:inat_urlbase+'points/{z}/{x}/{y}.png',description:'iNaturalist Observations (Points)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_points_zoom_x_y_png">iNaturalist observation data</a>'};
   let inat_grid = {url:inat_urlbase+'grid/{z}/{x}/{y}.png',description:'iNaturalist Observations (Grid)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_grid_zoom_x_y_png">iNaturalist observation data</a>'};
   var l_inat_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:0,maxZoom:20, attribution:inat_points.attribution});
   var l_inat_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:0,maxZoom:20,attribution:inat_grid.attribution});
   var l_inat_obs_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:10,maxZoom:20, attribution:inat_points.attribution});
   var l_inat_obs_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:2,maxZoom:9,attribution:inat_grid.attribution});
   var g_inat_obs = L.layerGroup([l_inat_obs_grid,l_inat_obs_points]);
   // iNat Observation Layer mods
   var l_inat_heat_mod_transparent = L.tileLayer.styleFilter(inat_heat.url+'?'+winurlparams,{minZoom:0, maxZoom:20, attribution:inat_heat.attribution, filter:'opacity(50%)'});
   // iNat UTFGrid Selection
   // (hover to see selected area, and click to view selected observation)
   async function fpopup(obs,count) {
      var s = (obs.photos.length==0) ? '[No Photo]' : '<img src="'+obs.photos[0].url+'" />';
      s += (obs.photos.length>1) ? ' ['+obs.photos.length+']' : '';
      s += '<br />observation #: <a target="_blank" href="'+obs.uri+'">'+obs.id+'</a> (grade: '+obs.quality_grade+')';
      s += '<br />taxon: ' + ((obs.taxon==null) ? '[Unknown]' : obs.taxon.preferred_common_name ? (obs.taxon.preferred_common_name+' ('+obs.taxon.name+')') : obs.taxon.name );
      s += '<br />observer: '+obs.user.login;
//      s += '<br />location: '+obs.place_guess;
      s += '<br />coordinates: '+fround(obs.geojson.coordinates[1],6)+', '+fround(obs.geojson.coordinates[0],6);
      s += (obs.positional_accuracy==null) ? '' : ' ('+fround(obs.positional_accuracy,1)+'m)';
      if (view==='elevation') {
         var elevationurl = 'https://epqs.nationalmap.gov/v1/json?y='+obs.geojson.coordinates[1]+'&x='+obs.geojson.coordinates[0]+'&output=json&units=Feet';
         var elevation = await ffetch(elevationurl)
            .then((data) => {
               return data;
            });
         if ((elevation?elevation.value:-1000000)>-1000000) { s += '<br />elevation: '+ (fround(elevation.value,1)+'ft, '+ fround(elevation.value*0.3048,1) + 'm'); }
         else {
            var elevationurl_fallback = 'https://api.open-elevation.com/api/v1/lookup?locations='+obs.geojson.coordinates[1]+','+obs.geojson.coordinates[0];
            var elevation_fallback = await ffetch(elevationurl_fallback)
               .then((data) => {
                  return data?.results[0];
               });
            s += '<br />elevation: '+ (elevation_fallback?(elevation_fallback.elevation+'m'):'[Unknown]');
         };
      };
      s += '<br />observed: '+((obs.time_observed_at==null) ? ((obs.observed_on==null) ? '[Unknown]': obs.observed_on) : fdate(obs.time_observed_at));
      s += '<br />created: '+((obs.created_at==null) ? obs.created_at_details.date : fdate(obs.created_at));
      s += '<br />last updated: '+fdate(obs.updated_at);
//      if (obs.description==null) {}
//      else if (obs.description.length < 200) {s += '<br />'+obs.description }
//      else {s += '<br />'+(obs.description.substring(0,191)+'... (more)')};
/*
      // ecological land units data is no longer provided as of early 2025 :(
      if (view==='ecolandunit') {
         function latlngtoxy(latlng) { return L.CRS.EPSG3857.project(latlng); };
         let mapExtent = mymap.getBounds();
         let pointXY = latlngtoxy(L.latLng(obs.geojson.coordinates[1],obs.geojson.coordinates[0]));
         var ecoluurl = `https://rmgsc.cr.usgs.gov/arcgis/rest/services/globalelus/MapServer/identify?geometry={"x":${pointXY.x},"y":${pointXY.y}}&geometryType=esriGeometryPoint&sr=102100&layers=all:4&tolerance=3&mapExtent=${latlngtoxy(mapExtent.getNorthWest()).x},${latlngtoxy(mapExtent.getNorthWest()).y},${latlngtoxy(mapExtent.getSouthEast()).x},${latlngtoxy(mapExtent.getSouthEast()).y}&imageDisplay=1,1,96&returnGeometry=false&returnZ=false&returnM=false&returnUnformattedValues=false&f=pjson`;
         var ecoludetails = await ffetch(ecoluurl)
            .then((data) => {
               return data.results[0].attributes;
            });
         s += '<hr /><details>'
         s += '<summary>Ecological Land Unit: ' + (ecoludetails ? (ecoludetails['Raster.ELU'] ?? 'N/A') : 'N/A') + '</summary>';
         s += '- Bioclimate: ' + (ecoludetails ? (ecoludetails['Raster.ELU_Bio_De'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Cover: ' + (ecoludetails ? (ecoludetails['Raster.ELU_GLC_De'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Form: ' + (ecoludetails ? (ecoludetails['Raster.ELU_LF_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Lithology: ' + (ecoludetails ? (ecoludetails['Raster.ELU_Lit_De'] ?? 'N/A') : 'N/A');
         s += '</details>';
         s += '<hr /><details>';
         s += '<summary>Ecological Facet: ' + (ecoludetails ? (ecoludetails['Raster.EF'] ?? 'N/A') : 'N/A') + '</summary>';
         s += '- Bioclimate: ' + (ecoludetails ? (ecoludetails['Raster.EF_Bio_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Cover: ' + (ecoludetails ? (ecoludetails['Raster.EF_GLC_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Form: ' + (ecoludetails ? (ecoludetails['Raster.EF_LF_Desc'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Lithology: ' + (ecoludetails ? (ecoludetails['Raster.EF_Lit_Des'] ?? 'N/A') : 'N/A');
         s += '</details>';
         var ecosysdetails;
         let contSets = ['US','SA','AF'];
         for (let cont of contSets) {
            var ecosysurl = `https://rmgsc.cr.usgs.gov/arcgis/rest/services/cont${cont}/MapServer/identify?geometry={"x":${pointXY.x},"y":${pointXY.y}}&geometryType=esriGeometryPoint&sr=102100&layers=all:0,1,2,3,4&tolerance=3&mapExtent=${latlngtoxy(mapExtent.getNorthWest()).x},${latlngtoxy(mapExtent.getNorthWest()).y},${latlngtoxy(mapExtent.getSouthEast()).x},${latlngtoxy(mapExtent.getSouthEast()).y}&imageDisplay=1,1,96&returnGeometry=false&returnZ=false&returnM=false&returnUnformattedValues=false&f=pjson`;
            ecosysdetails = await ffetch(ecosysurl)
               .then((data) => {
                  return ((data.results?.length||0)===0) ? null : data.results;
               });
            if (ecosysdetails) { break; };
         };
         
         if (ecosysdetails) {
         s += '<hr /><details>';
            s += '<summary>Ecosystem: ' + (ecosysdetails[0]?.attributes ? (ecosysdetails[0]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A') + '</summary>';
            s += '- Bioclimate: ' + (ecosysdetails[1].attributes ? (ecosysdetails[1].attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            s += '<br /> - Land Form: ' + (ecosysdetails[2]?.attributes ? (ecosysdetails[2]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            s += '<br /> - Land Lithology: ' + (ecosysdetails[3]?.attributes ? (ecosysdetails[3]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            if (ecosysdetails.length>4) {s += '<br /> - Topographic Position: ' + (ecosysdetails[4]?.attributes ? (ecosysdetails[4]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A'); };
            s += '</details>';
         };
      };
*/
      if (count>1) {
         s += '<hr />'
         s += `This marker also denotes ${count-1} older observation${(count>2)?'s':''}.`
      };
      L.popup().setLatLng([obs.geojson.coordinates[1],obs.geojson.coordinates[0]])
         .setContent(s).openOn(mymap);
   };
   var u_inat_options = {
      resolution: 4,
      pointerCursor: true,
      mouseInterval: 66,  // Delay for mousemove events
      minZoom:0,
      maxZoom:20, 
   };
   var u_inat_points = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, { ...u_inat_options, minZoom:10 });
   u_inat_points.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_points_all = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, u_inat_options);
   u_inat_points_all.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_grid = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, { ...u_inat_options, minZoom:2, maxZoom:9 });
   u_inat_grid.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_grid_all = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, u_inat_options);
   u_inat_grid_all.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_grid_superset = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+compareurlparams, u_inat_options);
   u_inat_grid_superset.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var v_inat_options = {
      idField: 'id',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
      buildIndex: true,  // requires above field to be set properly
      fillColor: 'black',
      shadowBlur: 0,  // Number of pixels for blur effect
      shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
      debug: false,  // if true, show tile borders and tile keys
      minZoom:0,
      maxZoom:20, 
   };
   var v_inat_points = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, { ...v_inat_options, minZoom:10, });
   var v_inat_points_all = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, v_inat_options);
   var v_inat_grid = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, { ...v_inat_options, minZoom:2, maxZoom:9 });
   var v_inat_grid_all = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, v_inat_options);
   var v_inat_grid_superset = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+compareurlparams, v_inat_options);
   var g_utfgdm_sel = L.layerGroup([u_inat_grid,u_inat_points,v_inat_grid,v_inat_points]);
   var g_utfgdm_sel_points = L.layerGroup([u_inat_points_all,v_inat_points_all]);
   var g_utfgdm_sel_grid = L.layerGroup([u_inat_grid_all,v_inat_grid_all]);
   var g_utfgdm_sel_superset = L.layerGroup([u_inat_grid_superset,v_inat_grid_superset]);
   // iNat UTFGrid Comparison Layer
   // note that iNat provides 4 UTFGrid endpoints. the grid and heatmap endpoints are interchangeable and the ones to use for this application.
   let utfgridapi = {url:'https://api.inaturalist.org/v1/grid/{z}/{x}/{y}.grid.json',attr:'<a href="https://api.inaturalist.org/v1/docs/#!/UTFGrid/get_grid_zoom_x_y_grid_json">iNaturalist</a>'};
   var l_utfgrid_compare = L.gridLayer.utfGridCompare({url:utfgridapi.url+'?'+winurlparams,attribution:utfgridapi.attr,marker:{size:0.75,opacity:0.5},urlcompare:utfgridapi.url+'?'+compareurlparams})
   // Other iNaturalist Layers
   var l_inat_place = L.tileLayer(inat_urlbase+'places/'+place_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_places_place_id_zoom_x_y_png">iNaturalist place polygon</a>'});
   // iNaturalist Taxon Places Checklist and Range Layers
   var l_inat_taxonplace = L.tileLayer(inat_urlbase+'taxon_places/'+taxon_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_places_taxon_id_zoom_x_y_png">iNaturalist taxon place checklist data</a>'});
   var l_inat_taxonrange = L.tileLayer(inat_urlbase+'taxon_ranges/'+taxon_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_ranges_taxon_id_zoom_x_y_png">iNaturalist taxon range data</a>'});
   // Geomodel layers
   var l_inat_geomodel = L.tileLayer(inat_urlbase+'geomodel/'+taxon_id+'/{z}/{x}/{y}.png?thresholded='+thresholded,{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'">iNaturalist geomodel</a>'});
   // Stamen layers
   // these are deprecated as Stamen tiles are now maintained by Stadia
   var s_stamen_copyright = 'Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://www.openstreetmap.org/copyright">ODbL</a>.'; // used for all sets except Watercolor
   var s_stamen_urlbase = 'https://stamen-tiles-{s}.a.ssl.fastly.net/';
   //var l_stamen_watercolor = L.tileLayer(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{minZoom:0, maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'});
   //var l_stamen_terrain = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainbg = L.tileLayer(s_stamen_urlbase+'terrain-background/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainlines = L.tileLayer(s_stamen_urlbase+'terrain-lines/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainlabels = L.tileLayer(s_stamen_urlbase+'terrain-labels/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_toner = L.tileLayer(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlite = L.tileLayer(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerbg = L.tileLayer(s_stamen_urlbase+'toner-background/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerhybrid = L.tileLayer(s_stamen_urlbase+'toner-hybrid/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlines = L.tileLayer(s_stamen_urlbase+'toner-lines/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlabels = L.tileLayer(s_stamen_urlbase+'toner-labels/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   // Stamen layer mods
   //var l_stamen_toner_mod_dark25 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(25%)'});
   //var l_stamen_toner_mod_dark70 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(70%)'});
   //var l_stamen_toner_mod_green_on_black = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(40%) sepia(40%) hue-rotate(60deg) saturate(400%) contrast(200%)'});
   //var l_stamen_toner_mod_black_on_blue = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'invert(100%) brightness(60%) sepia(100%) hue-rotate(180deg) saturate(150%)'});
   //var l_stamen_tonerlite_mod_dark50 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(50%) contrast(125%)'});
   //var l_stamen_tonerlite_mod_dark_with_purple = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'invert(100%) brightness(70%) sepia(100%) hue-rotate(205deg) saturate(160%)'});
   //var l_stamen_tonerlite_mod_olive = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(50%) sepia(100%) hue-rotate(15deg) saturate(160%)'});
   //var l_stamen_watercolor_mod_gray = L.tileLayer.styleFilter(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{minZoom:0, maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.', filter:'grayscale(85%)'});
   // Stamen Watercolor (now housed at Smithsonian)
   let s_watercolor = {url:'https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', attribution:'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'};
   var l_stamen_watercolor = L.tileLayer(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution});
   var l_stamen_watercolor_mod_muted = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(85%)'});
   var l_stamen_watercolor_mod_gray = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(100%)'});
   var l_stamen_watercolor_mod_darkgray = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(100%) brightness(50%)'});
   // OpenStreetMaps & OpenTopoMap
   let s_osm_std = {url:'https://tile.openstreetmap.org/{z}/{x}/{y}.png', attribution:'&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'};
   var l_osm_std = L.tileLayer(s_osm_std.url, {minZoom:0, maxNativeZoom:19, maxZoom:20, attribution:s_osm_std.attribution});
   var l_osm_de = L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', {minZoom:0, maxZoom:20, attribution:'&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles <a href="https://openstreetmap.de/">OpenStreetMap Deutschland</a>'});
   var l_osm_fr = L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {minZoom:0, maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - rendu <a href="https://openstreetmap.fr">OSM France</a>'});
   var l_osm_hot = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {minZoom:0, maxNativeZoom:19, maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - Tiles courtesy of <a href="https://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'});
   let s_otm = {url:'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attribution:'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org/">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'};
   var l_otm = L.tileLayer(s_otm.url,{minZoom:0, maxNativeZoom:17, maxZoom:20, attribution:s_otm.attribution});
   // mods
   var l_otm_mod_muted = L.tileLayer.styleFilter(s_otm.url,{minZoom:0, maxNativeZoom:17, maxZoom:20, attribution:s_otm.attribution, filter:'grayscale(60%)'});
   var l_osm_std_mod_lightgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%)'});
   var l_osm_std_mod_medgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) brightness(50%) contrast(150%)'});
   var l_osm_std_mod_medgray2 = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) brightness(50%) contrast(150%) invert(100%) contrast(125%)'});
   var l_osm_std_mod_darkgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) invert(100%)'});
   var l_osm_std_mod_darkest = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) invert(100%) brightness(80%) contrast(125%)'});
   // EOX -- http://maps.eox.at/
   // capabilities (including attribution) -- https://tiles.maps.eox.at/wmts/1.0.0/WMTSCapabilities.xml
   function f_eox_url(tileset,format) { return `https://tiles.maps.eox.at/wmts/1.0.0/${tileset}/default/g/{z}/{y}/{x}.${format}`; }; 
   // basemaps
   var l_eox_osm = L.tileLayer(f_eox_url('osm_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">OpenStreetMap</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_blackmarble = L.tileLayer(f_eox_url('blackmarble_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Black Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'});
   var l_eox_bluemarble = L.tileLayer(f_eox_url('bluemarble_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Blue Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'});
   var l_eox_terrain = L.tileLayer(f_eox_url('terrain_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var l_eox_terrain_light = L.tileLayer(f_eox_url('terrain-light_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var l_eox_sentinel2_2024 = L.tileLayer(f_eox_url('s2cloudless-2024_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2024) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2023 = L.tileLayer(f_eox_url('s2cloudless-2023_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2023) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2022 = L.tileLayer(f_eox_url('s2cloudless-2022_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2022) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2021 = L.tileLayer(f_eox_url('s2cloudless-2021_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2021) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2020 = L.tileLayer(f_eox_url('s2cloudless-2020_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2020) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2019 = L.tileLayer(f_eox_url('s2cloudless-2019_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2019) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2018 = L.tileLayer(f_eox_url('s2cloudless-2018_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2019) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   //var l_eox_sentinel2_2017 = L.tileLayer(f_eox_url('s2cloudless-2017_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2017) released under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.'});
   //var l_eox_sentinel2_2016 = L.tileLayer(f_eox_url('s2cloudless-2016_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2016 &amp; 2017) released under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.'});
   // overlays
   var l_eox_hydrography = L.tileLayer(f_eox_url('hydrography_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Hydrography overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_coastline = L.tileLayer(f_eox_url('coastline_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Coastline overlay</a> { Rendering &copy; <a href="https://eox.at">EOX</a> }'}); 
   var l_eox_streets = L.tileLayer(f_eox_url('streets_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Streets overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_overlay = L.tileLayer(f_eox_url('overlay_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_overlay_bright = L.tileLayer(f_eox_url('overlay_bright_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Overlay bright</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   // USGS maps (US primarily)
   var s_usgs_urlbase = 'https://basemap.nationalmap.gov/arcgis/rest/services/'
   //var l_usgs_topo = L.tileLayer(s_usgs_urlbase+'USGSTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, attribution:'<a href="'+s_usgs_urlbase+'USGSTopo/MapServer">USGS The National Map</a>: National Boundaries Dataset, 3DEP Elevation Program, Geographic Names Information System, National Hydrography Dataset, National Land Cover Database, National Structures Dataset, and National Transportation Dataset; USGS Global Ecosystems; U.S. Census Bureau TIGER/Line data; USFS Road Data; Natural Earth Data; U.S. Department of State Humanitarian Information Unit; and NOAA National Centers for Environmental Information, U.S. Coastal Relief Model'});
   var l_usgs_topo = L.tileLayer(s_usgs_urlbase+'USGSTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, attribution:'<a href="'+s_usgs_urlbase+'USGSTopo/MapServer">USGS The National Map</a>'});
   // var l_stamen_terrain_fallback = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{minZoom:9, maxNativeZoom:16, attribution:s_stamen_copyright});
   var l_eox_terrain_light_fallback = L.tileLayer(f_eox_url('terrain-light_3857','jpg'),{minZoom:9, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var g_usgs_topo = L.layerGroup([l_eox_terrain_light_fallback, l_usgs_topo]);
   var l_usgs_img = L.tileLayer(s_usgs_urlbase+'USGSImageryOnly/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSImageryOnly/MapServer">USGS The National Map</a>: Orthoimagery'});
   var l_usgs_imgtopo = L.tileLayer(s_usgs_urlbase+'USGSImageryTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSImageryTopo/MapServer">USGS The National Map</a>: Orthoimagery and US Topo'});
   //var l_usgs_relief = L.tileLayer(s_usgs_urlbase+'USGSShadedReliefOnly/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSShadedReliefOnly/MapServer">USGS The National Map</a>: 3D Elevation Program'});
   var l_usgs_hydro = L.tileLayer(s_usgs_urlbase+'USGSHydroCached/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSHydroCached/MapServer">USGS The National Map</a>: National Hydrography Dataset'});
   // USGS Ecological Land Units (Worldwide coverage) -- no longer available as of early 2025
   // (Note: The WMS Server doesn't respond very well when requesting many tiled images. So we'll request images from the /export route instead using a custom tileLayer extension.)
   //var l_usgs_ecolandunit = L.tileLayer.wms('https://rmgsc.cr.usgs.gov/arcgis/services/globalelus/MapServer/WMSServer?',{minZoom:0, maxZoom:20, attribution:'<a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">USGS Global Ecosystems</a>', format:'image/png32', transparent:true, layers:'4'});
   //var l_usgs_ecolandunit = L.tileLayer.usgs('https://rmgsc.cr.usgs.gov/ArcGIS/rest/services/globalelus/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:0',{minZoom:0, maxZoom:20, attribution:'<a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">USGS Global Ecosystems</a>', filter:'opacity(100%)'});
   // USGS Elevation (US, Mexico, Canada)
   // (Note: The WMS Server seems to be gone as of 2024. So we'll go with /exportImage route to get tiled images.)
   //var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer';
   var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage?';
   var s_usgs_3dep_attribution = '<a href="https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer">USGS 3D Elevation Program</a>';
   //var l_usgs_3dep_hillshade = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Hillshade Gray'}); //possible values: 'Hillshade Gray', 'Hillshade Multidirectional' , 'Hillshade Elevation Tinted', 'GreyHillshade_elevationFill'
   //var l_usgs_3dep_aspect = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Aspect Map'}); //possible values: 'Aspect Map', 'Aspect Degrees'
   //var l_usgs_3dep_slope = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Slope Map'}); //possible values: 'Slope Map', 'Slope Degrees'
   var l_usgs_3dep_hillshade = L.tileLayer.usgs(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, renderingRule:'Hillshade Gray'}); //possible values: 'Hillshade Gray', 'Hillshade Multidirectional' , 'Hillshade Elevation Tinted', 'GreyHillshade_elevationFill'
   var l_usgs_3dep_aspect = L.tileLayer.usgs(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, renderingRule:'Aspect Map'}); //possible values: 'Aspect Map', 'Aspect Degrees'
   var l_usgs_3dep_slope = L.tileLayer.usgs(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, renderingRule:'Slope Map'}); //possible values: 'Slope Map', 'Slope Degrees'
   // USGS other overlays (US only)
   // (Note: The WMS Server doesn't respond very well when requesting many tiled images. So we'll request images from the /export route instead using a custom tileLayer extension.)
   var s_usgs_overlay_attribution = '<a href="https://carto.nationalmap.gov/">USGS the National Map</a>'
   //var l_usgs_3dep_contours = L.tileLayer.wms('https://carto.nationalmap.gov/arcgis/services/contours/MapServer/WMSServer?',{minZoom:8, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35', format:'image/png32', transparent:true});
   //var l_usgs_3dep_transport = L.tileLayer.wms('https://carto.nationalmap.gov/arcgis/services/transportation/MapServer/WMSServer?',{minZoom:4, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38', format:'image/png32', transparent:true});
   var l_usgs_3dep_contours = L.tileLayer.usgs('https://carto.nationalmap.gov/arcgis/rest/services/contours/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:1,2,3,4,5,6,7,8,10,11,12,13,15,16,17,18,21,22,25,26',{minZoom:8, maxZoom:20, attribution:s_usgs_overlay_attribution, filter:'opacity(100%)'});
   // var l_usgs_3dep_transport = L.tileLayer.usgs('https://carto.nationalmap.gov/arcgis/rest/services/transportation/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38',{minZoom:4, maxZoom:20, attribution:s_usgs_overlay_attribution, filter:'opacity(100%)'});
   var l_graticule = L.tileLayer.wms('https://gis.ngdc.noaa.gov/arcgis/services/web_mercator/graticule/MapServer/WMSServer?',{minZoom:0, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6', format:'image/png32', transparent:true});
   //debug layer
   var l_debug = L.gridLayer.debugCoords();
   var defaultlayers = (view==='elevation') ? [g_usgs_topo]
      //: (view==='ecolandunit') ? [l_eox_terrain,l_usgs_ecolandunit,l_eox_overlay]
      : (view==='heatmap') ? [l_stamen_watercolor_mod_muted,l_eox_overlay]
      : (view==='subsetratio') ? [l_osm_std_mod_medgray2]
      : [l_osm_std];
   if (taxon_id!==null) {
      if (showtaxonplace==='true') {defaultlayers.push(l_inat_taxonplace)};
      if (showtaxonrange==='true') {defaultlayers.push(l_inat_taxonrange)};
      if (showexpectednearby==='true') {defaultlayers.push(l_inat_geomodel)};
   };
   if (place_id!==null) { 
      if (showplace==='true') {defaultlayers.push(l_inat_place)};
   };
   if (view==='heatmap') {
      defaultlayers.push(l_inat_heat);
   }
   else if (view==='subsetratio' && compexclparam) {
      defaultlayers.push(l_utfgrid_compare);
      defaultlayers.push(g_utfgdm_sel_grid);
   } 
   else {
      defaultlayers.push(g_inat_obs);
      defaultlayers.push(g_utfgdm_sel);
   };
   // define available basemaps (can view only one at a time)
   var basemaps = {
      "Stamen Watercolor": l_stamen_watercolor,
      "Stamen Watercolor Mod (Muted)": l_stamen_watercolor_mod_muted,
      "Stamen Watercolor Mod (Gray)": l_stamen_watercolor_mod_gray,
      "Stamen Watercolor Mod (Dark Gray)": l_stamen_watercolor_mod_darkgray,
      //"Stamen Terrain": l_stamen_terrain,
      //"Stamen Terrain Background": l_stamen_terrainbg,
      //"Stamen Toner": l_stamen_toner,
      //"Stamen Toner Background": l_stamen_tonerbg,
      //"Stamen Toner Lite": l_stamen_tonerlite,
      //"Stamen Toner Mod (Med Dark)": l_stamen_toner_mod_dark70,
      //"Stamen Toner Mod (Dark)": l_stamen_toner_mod_dark25,
      //"Stamen Toner Mod (Green on Black)": l_stamen_toner_mod_green_on_black,
      //"Stamen Toner Mod (Black on Blue)": l_stamen_toner_mod_black_on_blue,
      //"Stamen Toner Lite Mod (Med Dark)": l_stamen_tonerlite_mod_dark50,
      //"Stamen Toner Lite Mod (Dark with Purple)": l_stamen_tonerlite_mod_dark_with_purple,
      //"Stamen Toner Lite Mod (Olive)": l_stamen_tonerlite_mod_olive,
      "OpenTopoMap": l_otm,
      "OpenTopoMap Mod (Muted)": l_otm_mod_muted,
      "OpenStreetMap Standard": l_osm_std,
      "OpenStreetMap Std Mod (Light Gray)": l_osm_std_mod_lightgray,
      "OpenStreetMap Std Mod (Gray 1)": l_osm_std_mod_medgray,
      "OpenStreetMap Std Mod (Gray 2)": l_osm_std_mod_medgray2,
      "OpenStreetMap Std Mod (Dark Gray)": l_osm_std_mod_darkgray,
      "OpenStreetMap Std Mod (Near Black)": l_osm_std_mod_darkest,
      "OpenStreetMap Deutschland": l_osm_de,
      "OpenStreetMap France": l_osm_fr,
      "OpenStreetMap Humanitarian": l_osm_hot,
      "EOX OSM": l_eox_osm,
      "EOX Black Marble": l_eox_blackmarble,
      "EOX Blue Marble": l_eox_bluemarble,
      "EOX Sentinel-2 2024": l_eox_sentinel2_2024,
      "EOX Sentinel-2 2023": l_eox_sentinel2_2023,
      "EOX Sentinel-2 2022": l_eox_sentinel2_2022,
      "EOX Sentinel-2 2021": l_eox_sentinel2_2021,
      "EOX Sentinel-2 2020": l_eox_sentinel2_2020,
      "EOX Sentinel-2 2019": l_eox_sentinel2_2019,
      "EOX Sentinel-2 2018": l_eox_sentinel2_2018,
      //"EOX Sentinel-2 2017": l_eox_sentinel2_2017,
      //"EOX Sentinel-2 2016": l_eox_sentinel2_2016,
      "EOX Terrain": l_eox_terrain,
      "EOX Terrain (Light)": l_eox_terrain_light,
      "USGS Imagery": l_usgs_img,
      "USGS Topo": g_usgs_topo,
      "USGS Imagery + Topo": l_usgs_imgtopo,
      //"USGS Relief": l_usgs_relief,
      "USGS Hillshade (US, CA, MX)": l_usgs_3dep_hillshade,
      "USGS Aspect (US, CA, MX)": l_usgs_3dep_aspect,
      "USGS Slope (US, CA, MX)": l_usgs_3dep_slope,
   };
   // define available overlay maps (can view more than one at a time, arranged in order from lowest to highest)
   var overlaymaps = {
      //"USGS Ecological Land Units": l_usgs_ecolandunit,
      "USGS Hydro": l_usgs_hydro,
      "EOX Hydrography": l_eox_hydrography,
      "USGS Contours (US only)": l_usgs_3dep_contours,
      //"USGS Trasnportation": l_usgs_3dep_transport,
      //"Stamen Terrain Lines": l_stamen_terrainlines,
      //"Stamen Toner Lines": l_stamen_tonerlines,
      //"Stamen Toner Hybrid": l_stamen_tonerhybrid,
      //"Stamen Terrain Labels": l_stamen_terrainlabels,
      //"Stamen Toner Labels": l_stamen_tonerlabels,
      "EOX Streets": l_eox_streets,
      "EOX Coastline": l_eox_coastline,
      "EOX Overlay": l_eox_overlay,
      "EOX Overlay (Bright)": l_eox_overlay_bright,
      ...((taxon_id==null) ? {} : {"iNaturalist Taxon Range": l_inat_taxonrange}),
      ...((taxon_id==null) ? {} : {"iNaturalist Taxon Places": l_inat_taxonplace}),
      ...((taxon_id==null) ? {} : (thresholded? {"iNaturalist Expected Nearby": l_inat_geomodel} : {"iNaturalist Unthresholded Geomodel": l_inat_geomodel})),
      ...((place_id==null) ? {} : {"iNaturalist Place": l_inat_place}),
      ...((compexclparam==null) ? {} : {"iNaturalist Subset Ratio (Red=1.0, Blue=0.0)": l_utfgrid_compare}),
      //"iNaturalist Observations Density in GBIF (no filters)": l_gbif,
      "iNaturalist Observations Heatmap": l_inat_heat,
      "iNaturalist Observations Heatmap Mod (Transparent)": l_inat_heat_mod_transparent,
      //"iNaturalist Observations Circles": l_inat_circles,
      "iNaturalist Observations Grid": l_inat_grid,
      "iNaturalist Observations Points": l_inat_points,
      "iNaturalist Observations":g_inat_obs,
      "iNaturalist Observation Info":g_utfgdm_sel,
      "iNaturalist Observation Info for Grid":g_utfgdm_sel_grid,
      ...((compexclparam==null) ? {} : {"iNaturalist Observation Info for Superset Grid": g_utfgdm_sel_superset}),
      "iNaturalist Observation Info for Points":g_utfgdm_sel_points,
      "Graticule":l_graticule,
      "Debug Grid":l_debug,
   };
   var mymap;
   // if centerlat, centerlng, or defaultzoom are specified, then use that user-specified value
   // otherwise, set map extent based on coverage of observations
   let prom = (centerlat===null && centerlng===null && defaultzoom===null) ? ffetch(inat_urlbase+'observations?return_bounds=true&per_page=0&'+winurlparams) : Promise.resolve(null);
   prom.then((data) => {
      return data?.total_bounds;
   })
   .then((bbox) => {
      // create map, and set default center coordinates, zoom level, and layers
      mymap = L.map('mapid', {
         center: [centerlat||0,centerlng||0], // default to lat 0, long 0
         zoom: defaultzoom??2, // iNat defaults to zoom level 2
         layers: defaultlayers,
         doubleClickZoom: false
      });
      if (bbox) {
         var bounds = [[bbox.nelat,(bbox.swlng<bbox.nelng?bbox.nelng:bbox.nelng+360)],[bbox.swlat,bbox.swlng]];
         var padding = {padding:[5,5]};
         mymap.fitBounds(bounds,padding);
      };
      // add a layer selector control and scale bar
      L.control.layers(basemaps, overlaymaps).addTo(mymap);
      L.control.scale().addTo(mymap);
   });
};
</script>
</body>
</html>
