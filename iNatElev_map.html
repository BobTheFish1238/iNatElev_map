<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Map of iNaturalist Observations" />
<title>Map of iNaturalist Observations</title>
<style>
   body { height:100vh; width:100vw; margin:0px; font:10pt Sans-Serif;}
   #mapid { height:100vh; width:100vw; position:absolute; top:0vh; left:0vw; background:darkgray; }
   #info { padding:15px; }
   h1 { margin-top:0px; }
   a { text-decoration:none; }
   
   /* Search Controls */
   .search-controls {
      position: absolute;
      top: 10px;
      left: 50px;
      z-index: 1000;
      background: white;
      padding: 30px 10px 10px 10px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      max-width: 300px;
      min-width: 250px;
      transition: all 0.3s ease;
   }
   
   .search-controls.minimized {
      max-width: 20px;
      min-width: 20px;
      height: 20px;
      overflow: hidden;
      padding: 5px 5px 5px 5px;
   }
   
   .search-controls.minimized *:not(.close-btn) {
      display: none !important;
   }
   
   .primary-filters {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
   }
   
   .ac-chooser {
      position: relative;
      flex: 1;
   }
   
   .ac-chooser input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
   }
   
   /* Autocomplete styling */
   .ui-autocomplete {
      position: absolute;
      z-index: 1002;
      max-height: 300px;
      overflow-y: auto;
      overflow-x: hidden;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      width: 100%;
   }
   
   .ui-menu-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
   }
   
   .ui-menu-item:hover {
      background-color: #f5f5f5;
   }
   
   .ui-menu-item.active {
      background-color: #e9e9e9;
   }
   
   .ac-result {
      display: flex;
      align-items: center;
      gap: 10px;
   }
   
   .ac-thumb {
      width: 40px;
      height: 40px;
      flex-shrink: 0;
   }
   
   .ac-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 3px;
   }
   
   .ac-label {
      flex: 1;
   }
   
   .ac-label .title {
      font-weight: bold;
      display: block;
   }
   
   .ac-label .subtitle {
      font-size: 11px;
      color: #666;
      font-style: italic;
   }
   
   .ac-view {
      font-size: 11px;
      color: #4caf50;
      text-decoration: none;
      white-space: nowrap;
   }
   
   .ac-view:hover {
      text-decoration: underline;
   }
   
   .searchclear {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      color: #999;
      font-size: 16px;
   }
   
   .searchclear:hover {
      color: #333;
   }
   
   .filter-container {
      margin-top: 10px;
   }
   
   .filter-btn {
      width: 100%;
      padding: 8px;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
   }
   
   .filter-btn:hover {
      background: #e9e9e9;
   }
   
   .filter-content {
      display: none;
      position: absolute;
      top: 0;
      left: 280px;
      margin-top: 0px;
      max-height: 500px;
      overflow-y: auto;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      width: 600px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
      z-index: 1001;
   }
   
   .filter-content.show {
      display: block;
   }
   
   .filter-group {
      margin-bottom: 15px;
   }
   
   .sectionlabel {
      font-weight: bold;
      margin-bottom: 8px;
      display: block;
      font-size: 12px;
      color: #333;
   }
   
   .checkbox, .radio {
      margin-bottom: 6px;
      font-size: 12px;
      display: flex;
      align-items: center;
   }
   
   .checkbox input, .radio input {
      margin-right: 6px;
   }
   
   .form-control {
      padding: 6px;
      font-size: 12px;
      margin-bottom: 5px;
      width: 100%;
      box-sizing: border-box;
   }
   
   .btn {
      padding: 6px 12px;
      font-size: 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f5f5f5;
      cursor: pointer;
   }
   
   .btn:hover {
      background: #e9e9e9;
   }
   
   .btn-primary {
      background: #4caf50;
      color: white;
      border-color: #4caf50;
   }
   
   .btn-primary:hover {
      background: #45a049;
   }
   
   .row {
      display: flex;
      flex-wrap: wrap;
      margin: 0 -5px;
   }
   
   .col-xs-3, .col-xs-4, .col-xs-6, .col-xs-12 {
      padding: 0 5px;
      box-sizing: border-box;
   }
   
   .col-xs-3 { width: 25%; }
   .col-xs-4 { width: 33.33%; }
   .col-xs-6 { width: 50%; }
   .col-xs-12 { width: 100%; }
   
   .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
   }
   
   .filters-dates {
      font-size: 12px;
   }
   
   .filters-dates input, .filters-dates select {
      margin-top: 5px;
      margin-bottom: 5px;
      width: 100%;
   }
   
   .month-checkboxes {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin-top: 5px;
   }
   
   .month-checkbox {
      display: flex;
      align-items: center;
   }
   
   .month-checkbox label {
      display: flex;
      align-items: center;
      font-size: 11px;
      cursor: pointer;
   }
   
   .month-checkbox input {
      margin-right: 4px;
   }
   
   #more-filters {
      margin-top: 10px;
      border-top: 1px solid #eee;
      padding-top: 10px;
   }
   
   .close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #666;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      z-index: 1002;
   }
   
   .close-btn:hover {
      background: #f5f5f5;
      color: #333;
   }
   
   .close-btn.minimize {
      width: 20px;
      height: 20px;

      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;

      line-height: 1;   /* prevents vertical font offset */
   }
	  
   .btn-group .btn.active {
      background-color: #4caf50 !important;
      color: white !important;
      border-color: #4caf50 !important;
   }

   /* Elevation Histogram Panel */
   .elevation-histogram {
      position: absolute;
      top: 235px;
      left: 50px;
      width: 238px;
      height: 360px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 16px;
      z-index: 1000;
      overflow: hidden;
      border: 1px solid #e0e0e0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   }
   
   .elevation-histogram.minimized {
      left: 5px;
      width: 0px;
      height: 0px;
      border-radius: 6px;
   }
   
   .elevation-histogram.minimized .histogram-content,
   .elevation-histogram.minimized .histogram-title {
      display: none;
   }
   
   .histogram-header {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 16px;
   }
   
   .histogram-title {
      margin: 0;
      font-size: 15px;
      font-weight: 600;
      color: #2c3e50;
      letter-spacing: -0.2px;
   }
   
   .histogram-controls {
      display: flex;
      gap: 4px;
   }
   
   .histogram-controls button {
      background: none;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #7f8c8d;
      transition: all 0.2s ease;
      font-size: 16px;
   }
   
   .histogram-controls button:hover {
      background: #f8f9fa;
      color: #2c3e50;
   }
   
   .histogram-container {
      width: 100%;
      height: 200px;
      display: flex;
      flex-direction: row;
      position: relative;
      background: #f8f9fa;
      border-radius: 6px;
      padding: 12px 0 0 0px;
   }
   
   .histogram-y-axis {
      width: 8px;
      height: 200px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
      padding-right: 8px;
   }
   
   .y-axis-line {
      position: absolute;
      right: 0;
      width: 1px;
      height: 100%;
      background: linear-gradient(to bottom, transparent, #dee2e6, transparent);
   }
   
   .histogram-y-label {
      font-size: 10px;
      color: #6c757d;
      text-align: right;
      padding: 2px 0;
      position: relative;
      z-index: 1;
      background: #f8f9fa;
      padding-right: 4px;
   }
   
   .histogram-chart {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
   }
   
   .chart-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
   }
   
   .grid-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(to right, transparent, #e9ecef 20px, #e9ecef calc(100% - 20px), transparent);
   }
   
   .histogram-row {
      display: flex;
      align-items: center;
      width: 100%;
      height: 9%; /* 11 rows total */
      position: relative;
      z-index: 2;
   }
   
   .histogram-bar {
      height: 70%;
      background: linear-gradient(90deg, #3498db, #2980b9);
      border-radius: 4px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      min-width: 4px;
      box-shadow: 0 2px 4px rgba(52, 152, 219, 0.2);
      z-index: 1000;
   }
   
   .histogram-bar:hover {
      transform: scaleY(1.05);
      box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
   }
   
   .histogram-bar.empty {
      background: #e9ecef;
      box-shadow: none;
   }
   
   .histogram-bar.empty:hover {
      transform: none;
      box-shadow: none;
      cursor: default;
   }
   
   .bar-count {
      position: absolute;
      right: -12px;
      top: 50%;
      transform: translateY(-60%);
      font-size: 10px;
      font-weight: 600;
      color: #2c3e50;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
   }
   
   .histogram-bar:hover .bar-count {
      opacity: 1;
   }
   
   .histogram-x-axis {
      width: 100%;
      height: 24px;
      font-size: 11px;
      color: #6c757d;
      text-align: center;
      margin-top: 4px;
      padding-left: 8px; /* Match Y-axis width */
   }
   
   .histogram-x-labels {
      display: flex;
      justify-content: space-between;
      width: 100%;
   }
   
   .histogram-stats {
      margin-top: 0px;
      padding: 6px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 6px;
      border: 1px solid #dee2e6;
   }
   
   .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
   }
   
   .stat-item {
      text-align: center;
   }
   
   .stat-label {
      font-size: 8px;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
   }
   
   .stat-value {
      font-size: 14px;
      font-weight: 600;
      color: #2c3e50;
   }
   
   .stat-unit {
      font-size: 12px;
      color: #95a5a6;
      margin-left: 2px;
   }
   
   /* Loading indicator */
   .loading-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #6c757d;
   }
   
   .loading-spinner {
      width: 40px;
      height: 40px;
      position: relative;
      margin-bottom: 16px;
   }
   
   .loading-spinner:before {
      content: '';
      box-sizing: border-box;
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid #e9ecef;
      border-top-color: #3498db;
      animation: spin 1s linear infinite;
   }
   
   @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
   }
   
   .loading-text {
      font-size: 13px;
      text-align: center;
      max-width: 90%;
      margin-bottom: 8px;
   }
   
   .loading-progress {
      width: 80%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      overflow: hidden;
   }
   
   .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2980b9);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 3px;
   }
   
   /* Empty state */
   .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #6c757d;
      text-align: center;
      padding: 40px 20px;
   }
   
   .empty-state-icon {
      font-size: 40px;
      margin-bottom: 16px;
      opacity: 0.3;
   }
   
   .empty-state-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #495057;
   }
   
   .empty-state-subtitle {
      font-size: 12px;
      line-height: 1.4;
      color: #868e96;
      max-width: 80%;
   }
   
   /* Responsive adjustments */
   @media (max-width: 768px) {
      .elevation-histogram {
         width: 280px;
         height: 480px;
      }
   }

	/* Elevation histogram toggle */
	#elevation-histogram-toggle label {
		font-size: 12px !important;
	}

	#elevation-histogram-toggle input[type="checkbox"] {
		margin-right: 6px;
	}

	.checkbox-label {
	  display: flex;
	  align-items: center;
	  font-size: 10px;
	}
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
// debug grid example from https://leafletjs.com/examples/extending/extending-2-layers.html
L.GridLayer.DebugCoords = L.GridLayer.extend({
   createTile: function (coords) {
      var tile = document.createElement('div');
      tile.innerHTML = [coords.x, coords.y, coords.z].join(', ');
      tile.style.outline = '1px solid red';
      return tile;
   }
});
L.gridLayer.debugCoords = function(opts) {
   return new L.GridLayer.DebugCoords(opts);
};
// this allows a style filter to be applied to a basemap tile layer
L.TileLayer.StyleFilter = L.TileLayer.extend({
   intialize: function (url, options) {
      L.TileLayer.prototype.initialize.call(this, url, options);
   },
   styleFilter: function () {
      var filters = this.options.filter || '';
      return filters;
   },
   _initContainer: function () {
      var tile = L.TileLayer.prototype._initContainer.call(this);
      this._container.style.filter = this.styleFilter();
   },
});
L.tileLayer.styleFilter = function (url, options) {
   return new L.TileLayer.StyleFilter(url, options);
};
// this provides a way to get some USGS map images as tiles, as an alternative to WMS
// primary use case is when the WMS Server doesn't respond very quickly
// but this can also be used for other reasons, such as custom styling of the tiles
L.TileLayer.USGS = L.TileLayer.extend({
   intialize: function (url, options) {
      L.TileLayer.prototype.initialize.call(this, url, options);
   },
   getTileUrl: function (coords) {
      var data = {
         //r: Browser.retina ? '@2x' : '',
         //s: this._getSubdomain(coords),
         x: coords.x,
         y: coords.y,
         z: this._getZoomForUrl()
      };
      let mMax = 20037508.3428;
      let mTile = 2*mMax/(Math.pow(2,data.z));
      let bb = [
         data.x*mTile-mMax,
         -(data.y+1)*mTile+mMax,
         (data.x+1)*mTile-mMax,
         -data.y*mTile+mMax,
      ];
      data['p'] = `&f=image&bboxSR=102100&imageSR=102100&size=${this._tileSize.x},${this._tileSize.y}&bbox=${bb[0]},${bb[1]},${bb[2]},${bb[3]}`;
      if (this.options.renderingRule) { data['p'] += `&renderingRule=%7B"rasterFunction"%3A"${this.options.renderingRule}"%7D`; };
      return this._url + data.p;
      //return Util.template(this._url, Util.extend(data, this.options));
   },
   styleFilter: function () {
      var filters = this.options.filter || '';
      return filters;
   },
   _initContainer: function () {
      var tile = L.TileLayer.prototype._initContainer.call(this);
      this._container.style.filter = this.styleFilter();
   },
});
L.tileLayer.usgs = function (url, options) {
   return new L.TileLayer.USGS(url, options);
};
/*
https://github.com/mapbox/corslite
BSD 2-Clause License
Copyright (c) 2017, Mapbox
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function corslite(url, callback, cors) {
    var sent = false;
    if (typeof window.XMLHttpRequest === 'undefined') {
        return callback(Error('Browser not supported'));
    }
    if (typeof cors === 'undefined') {
        var m = url.match(/^\s*https?:\/\/[^\/]*/);
        cors = m && (m[0] !== location.protocol + '//' + location.hostname +
                (location.port ? ':' + location.port : ''));
    }
    var x = new window.XMLHttpRequest();
    function isSuccessful(status) {
        return status >= 200 && status < 300 || status === 304;
    }
    if (cors && !('withCredentials' in x)) {
        // IE8-9
        x = new window.XDomainRequest();
        // Ensure callback is never called synchronously, i.e., before
        // x.send() returns (this has been observed in the wild).
        // See https://github.com/mapbox/mapbox.js/issues/472
        var original = callback;
        callback = function() {
            if (sent) {
                original.apply(this, arguments);
            } else {
                var that = this, args = arguments;
                setTimeout(function() {
                    original.apply(that, args);
                }, 0);
            }
        }
    }
    function loaded() {
        if (
            // XDomainRequest
            x.status === undefined ||
            // modern browsers
            isSuccessful(x.status)) callback.call(x, null, x);
        else callback.call(x, x, null);
    }
    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`
    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).
    if ('onload' in x) {
        x.onload = loaded;
    } else {
        x.onreadystatechange = function readystate() {
            if (x.readyState === 4) {
                loaded();
            }
        };
    }
    // Call the callback with the XMLHttpRequest object as an error and prevent
    // it from ever being called again by reassigning it to `noop`
    x.onerror = function error(evt) {
        // XDomainRequest provides no evt parameter
        callback.call(this, evt || true, null);
        callback = function() { };
    };
    // IE9 must have onprogress be set to a unique function.
    x.onprogress = function() { };
    x.ontimeout = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };
    x.onabort = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };
    // GET is the only supported HTTP Verb by XDomainRequest and is the
    // only one supported here.
    x.open('GET', url, true);
    // Send the request. Sending data is not supported.
    x.send(null);
    sent = true;
    return x;
}
if (typeof module !== 'undefined') module.exports = corslite;
/*
https://github.com/consbio/Leaflet.UTFGrid/blob/master/L.UTFGrid.js
Copyright (c) 2015 - 2017, Conservation Biology Institute
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
//heavily modified from: https://raw.githubusercontent.com/danzel/Leaflet.utfgrid/leaflet-master/src/leaflet.utfgrid.js
//depends on corslite
L.UTFGrid = L.TileLayer.extend({
	options: {
		resolution: 4,
		pointerCursor: true,
        mouseInterval: 66  // Delay for mousemove events
	},
	_mouseOn: null,
    _mouseOnTile: null,
    _tileCharCode: null, // '<tileKey>:<charCode>' or null
    _cache: null, // {<tileKey>: <utfgrid>}
    _idIndex: null, // {<featureID>: {<tileKey1>: true, ...<tileKeyN>: true} }
    _throttleMove: null, // holds throttled mousemove handler
    //_throttleConnectEventHandlers: null, // holds throttled connection setup function
    _updateCursor: function(){ }, //no-op, overridden below
	onAdd: function (map) {
        this._cache = {};
        this._idIndex = {};
        L.TileLayer.prototype.onAdd.call(this, map);
        this._throttleMove = L.Util.throttle(this._move, this.options.mouseInterval, this);
        if (this.options.pointerCursor) {
            this._updateCursor = function(cursor) { this._container.style.cursor = cursor; }
        }
        map.on('boxzoomstart', this._disconnectMapEventHandlers, this);
        // have to throttle or we get an immediate click event on boxzoomend
        map.on('boxzoomend', this._throttleConnectEventHandlers, this);
        this._connectMapEventHandlers();
	},
	onRemove: function () {
		var map = this._map;
        map.off('boxzoomstart', this._disconnectMapEventHandlers, this);
        map.off('boxzoomend', this._throttleConnectEventHandlers, this);
        this._disconnectMapEventHandlers();
		this._updateCursor('');
        L.TileLayer.prototype.onRemove.call(this, map);
	},
    createTile: function(coords) {
        this._loadTile(coords);
        return document.createElement('div');  // empty DOM node, required because this overrides L.TileLayer
	},
    setUrl: function(url, noRedraw) {
        this._cache = {};
        return L.TileLayer.prototype.setUrl.call(this, url, noRedraw);
    },
    _connectMapEventHandlers: function(){
        this._map.on('click', this._onClick, this);
        this._map.on('mousemove', this._throttleMove, this);
    },
    _disconnectMapEventHandlers: function(){
        this._map.off('click', this._onClick, this);
		this._map.off('mousemove', this._throttleMove, this);
    },
    _throttleConnectEventHandlers: function() {
        setTimeout(this._connectMapEventHandlers.bind(this), 100);
    },
    _update: function (center, zoom) {
        L.TileLayer.prototype._update.call(this, center, zoom);
    },
    _loadTile: function (coords) {
        var url = this.getTileUrl(coords);
		var key = this._tileCoordsToKey(coords);
		var self = this;
        if (this._cache[key]) { return }
        corslite(url, function(err, response){
            if (err) {
                self.fire('error', {error: err});
                return;
            }
            var data = JSON.parse(response.responseText);
            self._cache[key] = data;
            L.Util.bind(self._handleTileLoad, self)(key, data);
        }, true);
	},
    _handleTileLoad: function(key, data) {
        // extension point
    },
	_onClick: function (e) {
		this.fire('click', this._objectForEvent(e));
	},
	_move: function (e) {
        if (e.latlng == null){ return }
		var on = this._objectForEvent(e);
        if (on._tileCharCode !== this._tileCharCode) {
			if (this._mouseOn) {
				this.fire('mouseout', {
                    latlng: e.latlng,
                    data: this._mouseOn,
                    _tile: this._mouseOnTile,
                    _tileCharCode: this._tileCharCode
                });
				this._updateCursor('');
			}
			if (on.data) {
				this.fire('mouseover', on);
				this._updateCursor('pointer');
			}
			this._mouseOn = on.data;
            this._mouseOnTile = on._tile;
            this._tileCharCode = on._tileCharCode;
		} else if (on.data) {
			this.fire('mousemove', on);
		}
	},
	_objectForEvent: function (e) {
	    if (!e.latlng) return;  // keyboard <ENTER> events also pass through as click events but don't have latlng
        var map = this._map,
		    point = map.project(e.latlng),
		    tileSize = this.options.tileSize,
		    resolution = this.options.resolution,
		    x = Math.floor(point.x / tileSize),
		    y = Math.floor(point.y / tileSize),
		    gridX = Math.floor((point.x - (x * tileSize)) / resolution),
		    gridY = Math.floor((point.y - (y * tileSize)) / resolution),
			max = map.options.crs.scale(map.getZoom()) / tileSize;
        x = (x + max) % max;
        y = (y + max) % max;
        var tileKey = this._tileCoordsToKey({z: map.getZoom(), x: x, y: y});
		var data = this._cache[tileKey];
		if (!data) {
			return {
                latlng: e.latlng,
                data: null,
                _tile: null,
                _tileCharCode: null
            };
		}
        var charCode = data.grid[gridY].charCodeAt(gridX);
		var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];
		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}
		return {
            latlng: e.latlng,
            data: result,
            id: (result)? result.id: null,
            _tile: tileKey,
            _tileCharCode: tileKey + ':' + charCode
        };
	},
    _dataForCharCode: function (tileKey, charCode) {
        var data = this._cache[tileKey];
        var idx = this._utfDecode(charCode),
		    key = data.keys[idx],
		    result = data.data[key];
		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}
        return result;
    },
	_utfDecode: function (c) {
		if (c >= 93) {
			c--;
		}
		if (c >= 35) {
			c--;
		}
		return c - 32;
	},
    _utfEncode: function (c) {
        //reverse of above, returns charCode for c
        //derived from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js#L37
        var charCode = c + 32;
        if (charCode >= 34) {
            charCode ++;
        }
        if (charCode >= 92) {
            charCode ++;
        }
        return charCode;
    }
});
L.utfGrid = function (url, options) {
	return new L.UTFGrid(url, options);
};
L.UTFGridCanvas = L.UTFGrid.extend({
	options: {
        idField: 'ID',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
        buildIndex: true,  // requires above field to be set properly
        fillColor: 'black',
	    shadowBlur: 0,  // Number of pixels for blur effect
        shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
        debug: false  // if true, show tile borders and tile keys
    },
    _adjacentTiles: null,
    onAdd: function (map) {
        this._adjacentTiles = [];
        L.UTFGrid.prototype.onAdd.call(this, map);
	},
    createTile: function(coords) {
        this._loadTile(coords);
        var tile = document.createElement('canvas');
        tile.width = tile.height = this.options.tileSize;
        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), this._tileCoordsToKey(coords));
        }
        return tile;
	},
    _connectMapEventHandlers: function(){
        L.UTFGrid.prototype._connectMapEventHandlers.call(this);
        this.on('mouseover', this._handleMouseOver, this);
        this.on('mouseout', this._handleMouseOut, this);
    },
    _disconnectMapEventHandlers: function(){
        L.UTFGrid.prototype._disconnectMapEventHandlers.call(this);
        this.off('mouseover', this._handleMouseOver, this);
        this.off('mouseout', this._handleMouseOut, this);
    },
    _handleMouseOver: function (e) {
        if (e._tile == null || e._tileCharCode == null){ return }
        this._clearAdjacentTiles();
        // currently over this tile:
        var curTile = e._tile;
        this._drawTile(curTile, parseInt(e._tileCharCode.split(':')[3]));
        if (e.data && this._idIndex) {
            // draw adjacent tiles
            var id = e.data[this.options.idField];
            var zoomLevel = curTile.split(':')[2];
            if (!(id && this._idIndex[id] && this._idIndex[id][zoomLevel])) { return }
            var idx = this._idIndex[id][zoomLevel];
            for (var tileKey in idx) {
                //TODO: screen out any tiles that are not currently visible?
                if (tileKey !== curTile) {
                    this._drawTile(tileKey, idx[tileKey]);
                    this._adjacentTiles.push(tileKey);
                }
            }
        }
    },
    _handleMouseOut: function (e) {
        this._resetTile(e._tile);
        this._clearAdjacentTiles();
    },
    _clearAdjacentTiles: function() {
        // clear out any adjacent tiles that were drawn
        if (this._adjacentTiles) {
            for (var i = 0; i < this._adjacentTiles.length; i++) {
                this._resetTile(this._adjacentTiles[i]);
            }
            this._adjacentTiles = [];
        }
    },
    _handleTileLoad: function(tileKey, data) {
        // build index: {<id: {zoomLevel: {tileKey: tileCharCode} } }
        if (this.options.buildIndex) {
            var id, props, idx;
            var idField = this.options.idField;
            var zoomLevel = tileKey.split(':')[2];
            for (var i = 0; i < data.keys.length; i++) {
                props = data.data[data.keys[i]];
                if (props) {
                    id = props[idField];
                    if (id) {
                        if (this._idIndex[id] == null) {
                            this._idIndex[id] = {};
                        }
                        idx = this._idIndex[id];
                        if (idx[zoomLevel] == null) {
                            idx[zoomLevel] = {};
                        }
                        idx[zoomLevel][tileKey] = this._utfEncode(i);
                    }
                }
            }
        }
    },
    _drawTile: function(tileKey, charCode) {
        // for a given tile, find all pixels that match character and repaint
        // TODO: request animation frame?
        if (this._tiles[tileKey] == null){ return }
        var canvas = this._tiles[tileKey].el;
        var ctx = canvas.getContext('2d');
        this._resetTile(tileKey);
        var grid = this._cache[tileKey].grid;
        ctx.fillStyle = this.options.fillColor;
        var dim = this.options.tileSize / this.options.resolution;
        // TODO: order of traversal here may be backwards?  Do y then x?  (are data column major or row major?)
        //modified slightly from: https://github.com/mapbox/glower/blob/mb-pages/src/glower.js
        for (var x = 0; x < dim; x++) {
            for (var y = 0; y < dim; y++) {
                if (grid[y].charCodeAt(x) === charCode) {
                    var sweep = 1;
                    while (y < 63 && grid[y + 1].charCodeAt(x) === charCode) {
                        y++;
                        sweep++;
                    }
                    ctx.fillRect(x * 4, (y * 4) - ((sweep - 1) * 4), 4, 4 * sweep);
                }
            }
        }
        if (this.options.shadowBlur) {
            this._addShadow(canvas, ctx);
        }
	
    },
    _resetTile: function(tileKey) {
        // clear the canvas
        if (this._tiles[tileKey] == null){ return }
        var tile = this._tiles[tileKey].el;
        tile.width = this.options.tileSize;  // hard reset of canvas
        if (this.options.debug) {
            this._drawDefaultTile(tile.getContext('2d'), tileKey);
        }
    },
    _drawDefaultTile: function(ctx, tileKey) {
        // if this.options.debug, add tileKey text and borders
        ctx.fillStyle = 'black';
        ctx.fillText(tileKey, 20, 20);
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(255, 0);
        ctx.lineTo(255, 255);
        ctx.lineTo(0, 255);
        ctx.closePath();
        ctx.stroke();
    },
    _addShadow: function(canvas, ctx) {
        ctx.shadowBlur = this.options.shadowBlur;
        ctx.shadowColor = this.options.shadowColor || this.options.fillColor;
        //Blur effect copied from glower - https://github.com/cutting-room-floor/glower/blob/mb-pages/src/glower.js#L108
        ctx.globalAlpha = 0.7;
        ctx.globalCompositeOperation = 'lighter';
        var a = 1;
        ctx.drawImage(canvas, -a, -a);
        ctx.drawImage(canvas, a, a);
        ctx.drawImage(canvas, 0, -a);
        ctx.drawImage(canvas, -a, 0);
        ctx.globalAlpha = 1;
    }
});
L.utfGridCanvas = function (url, options) {
	return new L.UTFGridCanvas(url, options);
};
// iNaturalist UTFGrid Compare
function freplacexyz(url,x,y,z) {
   url = url.replace('{x}',x);
   url = url.replace('{y}',y);
   url = url.replace('{z}',z);
   return url;
};
function fgetutfgrid(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
//      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};
L.GridLayer.UTFGridCompare = L.GridLayer.extend({
   createTile: function (coords, done) {
      var tile = document.createElement('canvas');
      var tileSize = this.getTileSize();
      tile.width = tileSize.x;
      tile.height = tileSize.y;
      var cellsPerTile = {x:64,y:64};
      var cellSize = {x:tileSize.x/cellsPerTile.x,y:tileSize.y/cellsPerTile.y};
      var ctx = tile.getContext('2d');
      // default marker setups
      var dmarker = {type:'relative',offset:{x:0,y:0},size:0.75,opacity:0.5};
      var marker = null;
      if (this.options.marker) {
         marker = this.options.marker;
         marker.type = marker.type || dmarker.type;
         marker.size = marker.size || dmarker.size;
         marker.offset = marker.offset || dmarker.offset;
         marker.opacity = marker.opacity || dmarker.opacity;
      }
      else { marker = dmarker };
      var offset = marker.offset;
      // get UTFgrids
      url0 = this.options.urlcompare;
      url1 = this.options.url;
      var prom0 = fgetutfgrid(freplacexyz(url0,coords.x,coords.y,coords.z));
      var prom1 = fgetutfgrid(freplacexyz(url1,coords.x,coords.y,coords.z));
      Promise.all([prom0,prom1]).then(function(utfgrid) {
         //draw markers on the tile canvas
         //note that this code was originally written to assume a 64x64 UTFgrid.
         //although the UTFgrid is still 64x64, the associated "grid tile" is actually only 32x32.
         //theoretically, a 2x2 set of cells from the UTFgrid should correspond to a single cell from the "grid tile"; however, that is not actually the case (see https://forum.inaturalist.org/t/open-test-of-map-tile-improvements/7833/88).
         //so this code attempts to mimic a 32x32 "grid tile" by using the bottom-right cell from each 2x2 set of UTFgrid cells. 
         //for (cx=0;cx<cellsPerTile.x;cx++) {
         for (cx=0;cx<cellsPerTile.x/2;cx++) {
            //for (cy=0;cy<cellsPerTile.y;cy++) {
            for (cy=0;cy<cellsPerTile.y/2;cy++) {
               //var cell = {x:cx,y:cy};
               var cell = {x:cx*2+1,y:cy*2+1};
               //for details about decoding the UTFgrid, see https://github.com/mapbox/utfgrid-spec/blob/master/1.2/utfgrid.md
               var d = [];
               for (u=0;u<utfgrid.length;u++) {
                  var i = utfgrid[u].grid[cell.y].charCodeAt(cell.x);
                  i = i-((i>=93)?34:(i>=35)?33:32);
                  d.push(utfgrid[u].data[utfgrid[u].keys[i]]);
               };
               for (j=0;j<d.length;j++) { d[j] = d[j] ? d[j].cellCount||0 : 0; } // set d = cellCount (set to 0 if undefined)
               var markerColor = 0; // default to black
               ctx.beginPath();
               var circleRadius = cellSize.x*marker.size;
               ctx.arc(cell.x*cellSize.x+offset.x,cell.y*cellSize.y+offset.y,circleRadius,0,2*Math.PI,false);
               if ( d[0]<=0 ) { markerColor = 'rgba(128,128,128,0.00)'; } // no color
               // else if ( d[1]<=0 ) { markerColor = `rgba(0,0,255,${marker.opacity})`; } // blue
               else {
                  var f = d[1]/d[0];
                  f = (f<=0)?1:(f>=1)?0:1-f;
                  markerColor = `hsla(${(f*240)},100%,50%,${marker.opacity})`; // high (1.0) is red, low (0.0) is blue
                  ctx.fillStyle = markerColor;
                  ctx.fill();
               };
               ctx.strokeStyle = markerColor;
               ctx.stroke();
            };
         };
      });  
      // asynchronous call
      setTimeout(function() {
         done(null, tile);
      }, 1000);
      return tile;
   }
});
L.gridLayer.utfGridCompare = function (options) {
   return new L.GridLayer.UTFGridCompare(options);
};
</script>
</head>
<body>
<div class="search-controls">
   <button class="close-btn minimize" onclick="toggleSearchControls()" title="Minimize">âˆ’</button>
   <div class="primary-filters">
      <div class="ac-chooser">
         <input type="text" id="taxon_name" placeholder="Species" onkeyup="handleTaxonSearch(event)" onfocus="handleTaxonSearch(event)">
         <span class="searchclear" onclick="clearTaxonSearch()" style="display: none;">Ã—</span>
      </div>
      <div class="ac-chooser">
         <input type="text" id="place_name" placeholder="Location" onkeyup="handlePlaceSearch(event)" onfocus="handlePlaceSearch(event)">
         <span class="searchclear" onclick="clearPlaceSearch()" style="display: none;">Ã—</span>
         <input type="hidden" id="place_id">
      </div>
      <button class="btn btn-primary" onclick="applySearch()">Search</button>
   </div>
   
   <div class="filter-container">
      <button class="filter-btn" onclick="toggleFilters(event)">
         <span><i>â˜°</i> Filters</span>
      </button>
      
      <div class="filter-content" id="filter-dropdown">
         <div class="row">
            <div class="col-xs-3">
               <label class="sectionlabel">Show</label>
               <div class="filter-group">
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-wild" onchange="toggleFilter('captive', 'false', this)"> Wild</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-captive" onchange="toggleFilter('captive', 'true', this)"> Captive</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-verifiable" onchange="toggleFilter('verifiable', 'true', this)"> Verifiable</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-research" onchange="toggleFilter('quality_grade', 'research', this)"> Research Grade</label>
                  </div>
                  <div class="checkbox">
                     <label><input type="checkbox" id="filter-needsid" onchange="toggleFilter('quality_grade', 'needs_id', this)"> Needs ID</label>
                  </div>
               </div>
            </div>
            
            <div class="col-xs-3">
               <label class="sectionlabel">Categories</label>
               <div class="btn-group">
                  <button class="btn" onclick="toggleIconicTaxon('Aves')">Birds</button>
                  <button class="btn" onclick="toggleIconicTaxon('Plantae')">Plants</button>
                  <button class="btn" onclick="toggleIconicTaxon('Insecta')">Insects</button>
                  <button class="btn" onclick="toggleIconicTaxon('Mammalia')">Mammals</button>
                  <button class="btn" onclick="toggleIconicTaxon('Fungi')">Fungi</button>
                  <button class="btn" onclick="toggleIconicTaxon('Amphibia')">Amphibians</button>
                  <button class="btn" onclick="toggleIconicTaxon('Reptilia')">Reptiles</button>
                  <button class="btn" onclick="toggleIconicTaxon('Mollusca')">Mollusks</button>
               </div>
            </div>
            
            <div class="col-xs-3">
               <label class="sectionlabel">View Type</label>
               <div class="filter-group">
                  <div class="radio">
                     <label><input type="radio" name="view" value="default" onchange="toggleView(this.value)"> Default Map</label>
                  </div>
					<div class="radio">
						<label><input type="radio" name="view" value="elevation" onchange="toggleView(this.value)"> Elevation View</label>
					</div>

					<!-- Add this checkbox below the Elevation View radio button -->
					<div class="checkbox" id="elevation-histogram-toggle" style="display: none; margin-top: 5px; margin-left: 20px;">
						<label class="checkbox-label">
							<input type="checkbox" id="enable-histogram" onchange="toggleHistogramSearch()">
							<span style="font-size: 10px;">Elevation histogram</span>
						</label>
					</div>
                  <div class="radio">
                     <label><input type="radio" name="view" value="heatmap" onchange="toggleView(this.value)"> Heatmap View</label>
                  </div>
                  <div class="radio">
                     <label><input type="radio" name="view" value="subsetratio" onchange="toggleView(this.value)"> Subset Ratio View</label>
                  </div>
               </div>
               
               <div id="subsetratio-params" style="display:none; margin-top:10px;">
                  <label class="sectionlabel">Compare Exclude Param</label>
                  <input type="text" class="form-control" id="compare-exclude-param" placeholder="e.g., quality_grade" onchange="updateFilter('compare_exclude_param', this.value, true)">
                  <small style="color: #666; font-size: 10px;">Parameter to exclude for superset comparison</small>
               </div>
            </div>
            
            <div class="col-xs-3">
               <label class="sectionlabel">Date Observed</label>
               <div class="filters-dates">
                  <select class="form-control" id="date-type" onchange="handleDateTypeChange()">
                     <option value="any">Any</option>
                     <option value="exact">Exact Date</option>
                     <option value="range">Range</option>
                     <option value="month">Months</option>
                  </select>
                  
                  <input type="date" id="exact-date" class="form-control" style="display:none; margin-top:5px;">
                  
                  <div id="date-range" style="display:none; margin-top:5px;">
                     <input type="date" class="form-control" id="date-start" placeholder="Start date">
                     <input type="date" class="form-control" id="date-end" placeholder="End date">
                  </div>
                  
                  <div id="date-month" style="display:none; margin-top:5px;">
                     <div class="month-checkboxes">
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="1"> Jan</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="2"> Feb</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="3"> Mar</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="4"> Apr</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="5"> May</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="6"> Jun</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="7"> Jul</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="8"> Aug</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="9"> Sep</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="10"> Oct</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="11"> Nov</label>
                        </div>
                        <div class="month-checkbox">
                           <label><input type="checkbox" value="12"> Dec</label>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         
         <div class="row" style="margin-top: 15px;">
            <div class="col-xs-12">
               <button class="btn btn-primary" onclick="applyAllFilters()">Update Search</button>
               <button class="btn" onclick="resetAllFilters()">Reset Filters</button>
            </div>
         </div>
      </div>
   </div>
</div>
<script>
// Simple filter management
let filters = new Map();
let selectedPlaceId = null;
let isFiltersVisible = false;

function toggleSearchControls() {
   const controls = document.querySelector('.search-controls');
   const btn = document.querySelector('.close-btn.minimize');
   
   if (controls.classList.contains('minimized')) {
      // Restore from minimized state
      controls.classList.remove('minimized');
      btn.innerHTML = 'âˆ’';
      btn.title = "Minimize";
   } else {
      // Minimize - also hide filters if open
      controls.classList.add('minimized');
      hideFilters();
      btn.innerHTML = 'ðŸ”Žï¸Ž';
      btn.title = "Restore";
   }
}

function toggleFilters(event) {
   if (event) event.stopPropagation();
   
   const filterContent = document.getElementById('filter-dropdown');
   if (isFiltersVisible) {
      hideFilters();
   } else {
      showFilters();
   }
}

function updateCategoryButtons() {
   const iconicTaxa = filters.get('iconic_taxa');
   const categoryButtons = document.querySelectorAll('.btn-group .btn');
   
   categoryButtons.forEach(button => {
      // Get the taxon from the button's onclick attribute
      const match = button.getAttribute('onclick').match(/toggleIconicTaxon\('([^']+)'\)/);
      if (match) {
         const taxon = match[1];
         if (iconicTaxa && iconicTaxa.split(',').includes(taxon)) {
            button.style.backgroundColor = '#4caf50';
            button.style.color = 'white';
            button.style.borderColor = '#4caf50';
         } else {
            button.style.backgroundColor = '';
            button.style.color = '';
            button.style.borderColor = '#ddd';
         }
      }
   });
}

let histogramStarted = false;

function showFilters() {
    const filterContent = document.getElementById('filter-dropdown');
    filterContent.style.display = 'block';
    isFiltersVisible = true;
    initializeFilterValues();
    
    // Close filters when clicking outside
    setTimeout(() => {
        document.addEventListener('click', closeFiltersOnClickOutside);
    }, 10);
}

function hideFilters() {
   const filterContent = document.getElementById('filter-dropdown');
   filterContent.style.display = 'none';
   isFiltersVisible = false;
   document.removeEventListener('click', closeFiltersOnClickOutside);
}

function closeFiltersOnClickOutside(event) {
   const filterContent = document.getElementById('filter-dropdown');
   const filterBtn = document.querySelector('.filter-btn');
   
   if (!filterContent.contains(event.target) && !filterBtn.contains(event.target)) {
      hideFilters();
   }
}

// Store selected place ID when autocomplete item is clicked
function storePlaceId(placeId) {
   selectedPlaceId = placeId;
   document.getElementById('place_id').value = placeId;
}

// Simple filter toggle function
function toggleFilter(param, value, checkbox) {
   if (checkbox.checked) {
      filters.set(param, value);
   } else {
      filters.delete(param);
   }
}

function updateFilter(param, value, isActive) {
   if (isActive && value) {
      filters.set(param, value);
   } else {
      filters.delete(param);
   }
}

function toggleView(view) {
    filters.set('view', view);
    
    // Show/hide subsetratio params
    const subsetParams = document.getElementById('subsetratio-params');
    if (view === 'subsetratio') {
        subsetParams.style.display = 'block';
    } else {
        subsetParams.style.display = 'none';
        filters.delete('compare_exclude_param');
    }
    
    // Show/hide elevation histogram toggle
    const histogramToggle = document.getElementById('elevation-histogram-toggle');
    if (view === 'elevation') {
        histogramToggle.style.display = 'block';
        // Reset histogram state when switching to elevation view
        histogramSearchEnabled = false;
        elevationSearchConfirmed = false;
        document.getElementById('enable-histogram').checked = false;
    } else {
        histogramToggle.style.display = 'none';
        // Hide histogram if visible
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
    }
}

function toggleIconicTaxon(taxon) {
   let currentValue = filters.get('iconic_taxa');
   let taxa = currentValue ? currentValue.split(',') : [];
   
   if (taxa.includes(taxon)) {
      taxa = taxa.filter(t => t !== taxon);
   } else {
      taxa.push(taxon);
   }
   
   if (taxa.length > 0) {
      filters.set('iconic_taxa', taxa.join(','));
   } else {
      filters.delete('iconic_taxa');
   }
   updateCategoryButtons();
}

function handleDateTypeChange() {
   const dateType = document.getElementById('date-type').value;
   const exactDate = document.getElementById('exact-date');
   const dateRange = document.getElementById('date-range');
   const dateMonth = document.getElementById('date-month');
   
   exactDate.style.display = 'none';
   dateRange.style.display = 'none';
   dateMonth.style.display = 'none';
   
   // Clear conflicting date filters when switching date types
   if (dateType === 'exact') {
      exactDate.style.display = 'block';
      // Clear other date filters from the map
      filters.delete('d1');
      filters.delete('d2');
      filters.delete('month');
      // Clear other date input fields
      document.getElementById('date-start').value = '';
      document.getElementById('date-end').value = '';
      document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   } else if (dateType === 'range') {
      dateRange.style.display = 'block';
      // Clear other date filters from the map
      filters.delete('on');
      filters.delete('month');
      // Clear other date input fields
      document.getElementById('exact-date').value = '';
      document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   } else if (dateType === 'month') {
      dateMonth.style.display = 'block';
      // Clear other date filters from the map
      filters.delete('on');
      filters.delete('d1');
      filters.delete('d2');
      // Clear other date input fields
      document.getElementById('exact-date').value = '';
      document.getElementById('date-start').value = '';
      document.getElementById('date-end').value = '';
   } else {
      // 'any' - clear all date filters
      filters.delete('on');
      filters.delete('d1');
      filters.delete('d2');
      filters.delete('month');
      // Clear all date input fields
      document.getElementById('exact-date').value = '';
      document.getElementById('date-start').value = '';
      document.getElementById('date-end').value = '';
      document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   }
}

function updateMonthFilter() {
   const monthCheckboxes = document.querySelectorAll('#date-month input[type="checkbox"]');
   const selectedMonths = Array.from(monthCheckboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);
   
   if (selectedMonths.length > 0) {
      filters.set('month', selectedMonths.join(','));
   } else {
      filters.delete('month');
   }
}

function applyAllFilters() {
    let params = new URLSearchParams(window.location.search);
    
    // Clear existing filter params
    const currentView = filters.get('view') || params.get('view');
    ['captive', 'verifiable', 'quality_grade', 'on', 'd1', 'd2', 'month', 
     'iconic_taxa', 'view', 'compare_exclude_param', 'taxon_name', 'place_name', 'place_id', 'histogram_enabled'].forEach(p => params.delete(p));
    
    // Add current filters
    filters.forEach((value, key) => {
        params.set(key, value);
    });
    
    // Preserve view if it was previously set
    if (currentView && !filters.has('view')) {
        params.set('view', currentView);
    }
    
    // Add histogram state if enabled
    if (histogramSearchEnabled) {
        params.set('histogram_enabled', 'true');
    }
    
    // Add date filters if set
    const dateType = document.getElementById('date-type').value;
    if (dateType === 'exact') {
        const exactDate = document.getElementById('exact-date').value;
        if (exactDate) {
            params.set('on', exactDate);
            filters.set('on', exactDate);
        }
    } else if (dateType === 'range') {
        const startDate = document.getElementById('date-start').value;
        const endDate = document.getElementById('date-end').value;
        if (startDate) {
            params.set('d1', startDate);
            filters.set('d1', startDate);
        }
        if (endDate) {
            params.set('d2', endDate);
            filters.set('d2', endDate);
        }
    } else if (dateType === 'month') {
        updateMonthFilter();
    }
    
    // Add compare exclude param if in subsetratio view
    if (filters.get('view') === 'subsetratio' || currentView === 'subsetratio') {
        const compareParam = document.getElementById('compare-exclude-param').value;
        if (compareParam) {
            params.set('compare_exclude_param', compareParam);
            filters.set('compare_exclude_param', compareParam);
        }
    }
    
    // Add search inputs
    const taxonName = document.getElementById('taxon_name').value;
    const placeName = document.getElementById('place_name').value;
    const placeId = document.getElementById('place_id').value;
    
    if (taxonName) {
        params.set('taxon_name', taxonName);
    }
    
    if (placeName) {
        params.set('place_name', placeName);
        if (placeId) {
            params.set('place_id', placeId);
        }
    }
    
    // Reload with filters
    window.location.href = window.location.pathname + '?' + params.toString();
}

function resetAllFilters() {
   filters.clear();
   
   // Reset checkboxes
   document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
   document.querySelectorAll('input[type="radio"]').forEach(rb => rb.checked = false);
   document.querySelector('input[name="view"][value="default"]').checked = true;
   
   // Reset selects
   document.getElementById('date-type').selectedIndex = 0;
   handleDateTypeChange();
   
   // Reset subsetratio
   document.getElementById('subsetratio-params').style.display = 'none';
   document.getElementById('compare-exclude-param').value = '';
   
   // Reset date inputs
   document.getElementById('exact-date').value = '';
   document.getElementById('date-start').value = '';
   document.getElementById('date-end').value = '';
   
   // Reset month checkboxes
   document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => cb.checked = false);
   
   // Reset category buttons
   updateCategoryButtons();
}

function initializeFilterValues() {
    const params = new URLSearchParams(window.location.search);
    
    // First, clear the filters map completely
    filters.clear();
    
    // Set view radio
    const view = params.get('view') || 'default';
    document.querySelector(`input[name="view"][value="${view}"]`).checked = true;
    
    // Only add view to filters if it's not the default
    if (view !== 'default') {
        filters.set('view', view);
    }
    
    if (view === 'subsetratio') {
        document.getElementById('subsetratio-params').style.display = 'block';
        const compareParam = params.get('compare_exclude_param');
        if (compareParam) {
            document.getElementById('compare-exclude-param').value = compareParam;
            filters.set('compare_exclude_param', compareParam);
        }
    }
    
    // Set histogram state from URL - BUT DON'T START HISTOGRAM HERE
    // This function is called when opening filters, not just on page load
    const histogramEnabled = params.get('histogram_enabled') === 'true';
    if (histogramEnabled) {
        histogramSearchEnabled = true;
        elevationSearchConfirmed = true;
        const histogramCheckbox = document.getElementById('enable-histogram');
        if (histogramCheckbox) {
            histogramCheckbox.checked = true;
        }
        // DO NOT start histogram here - it's already running if enabled
    } else {
        histogramSearchEnabled = false;
        elevationSearchConfirmed = false;
        const histogramCheckbox = document.getElementById('enable-histogram');
        if (histogramCheckbox) {
            histogramCheckbox.checked = false;
        }
    }
   
   // Set checkboxes
   const checkboxes = {
      'captive=false': 'filter-wild',
      'captive=true': 'filter-captive',
      'verifiable=true': 'filter-verifiable',
      'quality_grade=research': 'filter-research',
      'quality_grade=needs_id': 'filter-needsid'
   };
   
   Object.entries(checkboxes).forEach(([paramValue, checkboxId]) => {
      const [param, value] = paramValue.split('=');
      const checkbox = document.getElementById(checkboxId);
      if (checkbox && params.get(param) === value) {
         checkbox.checked = true;
         filters.set(param, value);
      }
   });
   
   // Set date fields - ONLY ONE date type should be active at a time
   if (params.has('on')) {
      document.getElementById('date-type').value = 'exact';
      document.getElementById('exact-date').value = params.get('on');
      filters.set('on', params.get('on'));
   } else if (params.has('d1')) {
      document.getElementById('date-type').value = 'range';
      document.getElementById('date-start').value = params.get('d1');
      document.getElementById('date-end').value = params.get('d2') || '';
      filters.set('d1', params.get('d1'));
      if (params.get('d2')) {
         filters.set('d2', params.get('d2'));
      }
   } else if (params.has('month')) {
      document.getElementById('date-type').value = 'month';
      const months = params.get('month').split(',');
      const monthCheckboxes = document.querySelectorAll('#date-month input[type="checkbox"]');
      monthCheckboxes.forEach(cb => {
         if (months.includes(cb.value)) {
            cb.checked = true;
         }
      });
      filters.set('month', params.get('month'));
   } else {
      document.getElementById('date-type').value = 'any';
   }
   handleDateTypeChange();
   
   // Set iconic taxa
   const iconicTaxa = params.get('iconic_taxa');
   if (iconicTaxa) {
      filters.set('iconic_taxa', iconicTaxa);
   }
   
   // These are search parameters, not filter parameters
   const searchParams = ['taxon_name', 'place_name', 'place_id'];
   searchParams.forEach(param => {
      if (params.has(param)) {
         // These are search parameters, not filter parameters
         // We track them separately if needed
      }
   });
   
   // Don't count 'view=default' in filters since it's the default
   if (filters.has('view') && filters.get('view') === 'default') {
      filters.delete('view');
   }
   
   updateCategoryButtons();
}

// Autocomplete functions with place_id support
function handleTaxonSearch(event) {
   if (event.key === 'Enter') {
      applySearch();
   } else if (event.target.value.length > 2) {
      fetchTaxonAutocomplete(event.target.value);
   }
   updateClearButton('taxon_name');
}

function handlePlaceSearch(event) {
   if (event.key === 'Enter') {
      applySearch();
   } else if (event.target.value.length > 2) {
      fetchPlaceAutocomplete(event.target.value);
   }
   updateClearButton('place_name');
}

function clearTaxonSearch() {
   document.getElementById('taxon_name').value = '';
   hideAutocomplete('taxon');
   updateClearButton('taxon_name');
}

function clearPlaceSearch() {
   document.getElementById('place_name').value = '';
   document.getElementById('place_id').value = '';
   selectedPlaceId = null;
   hideAutocomplete('place');
   updateClearButton('place_name');
}

function updateClearButton(fieldId) {
   const field = document.getElementById(fieldId);
   const clearBtn = field.nextElementSibling;
   clearBtn.style.display = field.value ? 'inline' : 'none';
}

function fetchTaxonAutocomplete(query) {
   const url = `https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(query)}`;
   
   fetch(url)
      .then(response => response.json())
      .then(data => {
         showAutocomplete('taxon', data.results || []);
      })
      .catch(error => {
         console.error('Error fetching taxon autocomplete:', error);
      });
}

function fetchPlaceAutocomplete(query) {
   const url = `https://api.inaturalist.org/v1/places/autocomplete?q=${encodeURIComponent(query)}`;
   
   fetch(url)
      .then(response => response.json())
      .then(data => {
         showAutocomplete('place', data.results || []);
      })
      .catch(error => {
         console.error('Error fetching place autocomplete:', error);
      });
}

function showAutocomplete(type, results) {
   hideAutocomplete(type);
   
   if (results.length === 0) return;
   
   const input = document.getElementById(type === 'taxon' ? 'taxon_name' : 'place_name');
   const container = input.parentElement;
   
   const autocomplete = document.createElement('div');
   autocomplete.className = 'ui-autocomplete ui-front ui-widget ui-widget-content';
   autocomplete.id = type === 'taxon' ? 'taxon-autocomplete' : 'place-autocomplete';
   
   results.forEach(result => {
      const item = document.createElement('div');
      item.className = 'ui-menu-item ac-result';
      
      let html = '';
      if (type === 'taxon') {
         const thumb = result.default_photo?.square_url || 'https://static.inaturalist.org/sites/1-logo.svg';
         const title = result.preferred_common_name || result.name;
         const subtitle = result.preferred_common_name ? `<i>${result.name}</i>` : (result.rank || '');
         
         html = `
            <div class="ac" data-taxon-id="${result.id}">
               <div class="ac-thumb">
                  <img src="${thumb}" alt="${title}">
               </div>
               <div class="ac-label">
                  <div>
                     <span class="title">${title}</span>
                     <span class="subtitle">${subtitle}</span>
                  </div>
               </div>
               <a class="ac-view" target="_blank" href="https://www.inaturalist.org/taxa/${result.id}">View</a>
            </div>
         `;
         
         item.onclick = () => {
            input.value = result.preferred_common_name || result.name;
            hideAutocomplete(type);
         };
      } else {
         const title = result.display_name || result.name;
         
         html = `
            <div class="ac" data-place-id="${result.id}">
               <div class="ac-label">
                  <div>
                     <span class="title">${title}</span>
                  </div>
               </div>
               <a class="ac-view" target="_blank" href="https://www.inaturalist.org/places/${result.id}">View</a>
            </div>
         `;
         
         item.onclick = () => {
            input.value = result.display_name || result.name;
            storePlaceId(result.id);
            hideAutocomplete(type);
         };
      }
      
      item.innerHTML = html;
      autocomplete.appendChild(item);
   });
   
   container.appendChild(autocomplete);
   positionAutocomplete(input, autocomplete);
}

function hideAutocomplete(type) {
   const id = type === 'taxon' ? 'taxon-autocomplete' : 'place-autocomplete';
   const existing = document.getElementById(id);
   if (existing) {
      existing.remove();
   }
}

function positionAutocomplete(input, autocomplete) {
   const rect = input.getBoundingClientRect();
   autocomplete.style.position = 'absolute';
   autocomplete.style.top = `38.1px`;
   autocomplete.style.left = `0px`;
   autocomplete.style.width = `${rect.width}px`;
   autocomplete.style.display = 'block';
   autocomplete.style.zIndex = '1003';
}

document.addEventListener('click', function(event) {
   if (!event.target.closest('.ac-chooser')) {
      hideAutocomplete('taxon');
      hideAutocomplete('place');
   }
});

function applySearch() {
   const taxonName = document.getElementById('taxon_name').value;
   const placeName = document.getElementById('place_name').value;
   const placeId = document.getElementById('place_id').value;
   
   let params = new URLSearchParams(window.location.search);
   
   if (taxonName) {
      params.set('taxon_name', taxonName);
   } else {
      params.delete('taxon_name');
   }
   
   if (placeName) {
      params.set('place_name', placeName);
      if (placeId) {
         params.set('place_id', placeId);
      }
   } else {
      params.delete('place_name');
      params.delete('place_id');
   }
   
   window.location.href = window.location.pathname + '?' + params.toString();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
	// Initialize histogram state
	histogramSearchEnabled = false;
	elevationSearchConfirmed = false;

	// If we're in elevation view, don't auto-init histogram
	if (view === 'elevation') {
		const histogramToggle = document.getElementById('elevation-histogram-toggle');
		if (histogramToggle) {
			histogramToggle.style.display = 'block';
		}
		// Don't auto-show histogram - wait for user to enable it
		const histogram = document.getElementById('elevationHistogram');
		if (histogram) {
			histogram.style.display = 'none';
		}
	}

   const params = new URLSearchParams(window.location.search);
   const taxonName = params.get('taxon_name');
   const placeName = params.get('place_name');
   const placeId = params.get('place_id');
   
   if (taxonName) {
      document.getElementById('taxon_name').value = taxonName;
      updateClearButton('taxon_name');
   }
   
   if (placeName) {
      document.getElementById('place_name').value = placeName;
      updateClearButton('place_name');
   }
   
   if (placeId) {
      document.getElementById('place_id').value = placeId;
      selectedPlaceId = placeId;
   }
   
   // Initialize month checkbox events
   document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => {
      cb.addEventListener('change', updateMonthFilter);
   });
   
   
   // Hide filters initially
   hideFilters();
});

// Elevation Histogram Variables
let elevationHistogramVisible = true;
let elevationData = [];
let histogramContainer;
let isCollectingData = false;
let elevationRequestQueue = [];
let isCancellingElevation = false;
let nextRequestTime = 0;
let requestsRemaining = 1000; // OpenTopoData daily limit
let openTopoDataEnabled = true;
let delayTimer = null;
// Elevation histogram search toggle
let histogramSearchEnabled = false;
let elevationSearchConfirmed = false;

function toggleHistogramSearch() {
    const checkbox = document.getElementById('enable-histogram');
    
    if (checkbox.checked) {
        // Show warning with alert
        const warningMessage = `âš ï¸ Elevation Search Warning âš ï¸

Elevation data collection is resource-intensive:

Rate Limits:
â€¢ Open Topo Data: 100 locations per request, 1 request per second, 1000 requests per day
â€¢ Open-Elevation (fallback): Individual requests with delays between calls

Daily Limit: ~100,000 elevation lookups per day

Recommendation: Use elevation search only when necessary. For large datasets, consider filtering observations first.

Click OK to enable elevation histogram search, or Cancel to keep it disabled.`;
        
        const userConfirmed = confirm(warningMessage);
        
        if (userConfirmed) {
            // User clicked OK - enable the checkbox
            histogramSearchEnabled = true;
            elevationSearchConfirmed = true;
            checkbox.checked = true;
            
            // DO NOT start histogram here - wait for Update Search
            // Just update the filter state
            updateFilter('histogram_enabled', 'true', true);
        } else {
            // User clicked Cancel or closed the dialog
            histogramSearchEnabled = false;
            elevationSearchConfirmed = false;
            checkbox.checked = false;
            updateFilter('histogram_enabled', 'false', true);
        }
    } else {
        // User is disabling it
        histogramSearchEnabled = false;
        elevationSearchConfirmed = false;
        updateFilter('histogram_enabled', 'false', true);
        
        // Hide histogram if visible
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
    }
}

function checkLargeDatasetWarning(observationCount) {
    if (observationCount > 10000 && histogramSearchEnabled) {
        const warningMessage = `âš ï¸ Large Dataset Detected âš ï¸

Found ${observationCount.toLocaleString()} observations with coordinates.

This will use approximately:
â€¢ ${Math.ceil(observationCount / 100)} Open Topo Data API calls
â€¢ ${Math.ceil(observationCount / 100)} seconds minimum processing time
â€¢ May use ${Math.ceil(observationCount / 100000 * 100)}% of daily API limit

Consider filtering observations before elevation lookup.

Click OK to continue anyway, or Cancel to stop elevation lookup.`;
        
        const continueAnyway = confirm(warningMessage);
        
        if (!continueAnyway) {
            // User cancelled, disable histogram search
            histogramSearchEnabled = false;
            elevationSearchConfirmed = false;
            document.getElementById('enable-histogram').checked = false;
            return false;
        }
    }
    return true;
}

// Function to initialize elevation histogram
function initElevationHistogram() {
    // Don't create histogram if search is disabled
    if (!histogramSearchEnabled) {
        // If histogram exists, hide it
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
        histogramStarted = false;
        return;
    }
    
    // Check if histogram is already running
    if (histogramStarted && document.getElementById('elevationHistogram')) {
        // Histogram already exists and is running, just make sure it's visible
        const histogram = document.getElementById('elevationHistogram');
        histogram.style.display = 'block';
        return;
    }
    
    // Check if histogram already exists (but not started yet)
    if (document.getElementById('elevationHistogram')) {
        // Just show it and refresh data if it exists
        const histogram = document.getElementById('elevationHistogram');
        histogram.style.display = 'block';
        histogramStarted = true;
        
        // Refresh data if we don't have any
        if (elevationData.length === 0) {
            collectElevationData();
        }
        return;
    }
    
    // Mark as started
    histogramStarted = true;
    
    // Create histogram container
    const histogramDiv = document.createElement('div');
    histogramDiv.className = 'elevation-histogram';
    histogramDiv.id = 'elevationHistogram';
    histogramDiv.innerHTML = `
        <div class="histogram-header">
            <div class="histogram-controls">
                <h3 class="histogram-title">Elevation Distribution (ft)</h3>
            </div>
            <div class="histogram-controls">
                <button class="close-btn minimize" onclick="toggleElevationHistogram()" title="Minimize">âˆ’</button>
            </div>
        </div>
        <div class="histogram-content">
            <div class="loading-indicator" id="loadingIndicator">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading elevation data...</div>
                <div class="loading-progress">
                    <div class="loading-progress-bar" id="loadingProgressBar"></div>
                </div>
            </div>
            <div class="histogram-container" style="display: none;" id="histogramContainer">
                <div class="histogram-y-axis" id="histogramYAxis"></div>
                <div class="histogram-chart" id="histogramChart"></div>
            </div>
            <div class="histogram-x-axis" id="histogramXAxis">Number of Observations</div>
            <div class="histogram-stats" id="histogramStats"></div>
        </div>
    `;
    
    document.body.appendChild(histogramDiv);
    
    // Collect elevation data
    collectElevationData();
}

// Function to toggle histogram visibility
function toggleElevationHistogram() {
   const histogram = document.getElementById('elevationHistogram');
   const btn = histogram.querySelector('.close-btn.minimize');
   
   if (histogram.classList.contains('minimized')) {
      histogram.classList.remove('minimized');
      btn.innerHTML = 'âˆ’';
      btn.title = "Minimize";
      elevationHistogramVisible = true;
   } else {
      histogram.classList.add('minimized');
      btn.innerHTML = 'â†•';
      btn.title = "Restore";
      elevationHistogramVisible = false;
   }
}

// Function to update loading progress
function updateLoadingProgress(percentage, text) {
    const progressBar = document.getElementById('loadingProgressBar');
    const loadingText = document.getElementById('loadingStatusText');
    
    if (progressBar) {
        progressBar.style.width = `${percentage}%`;
    }
    if (loadingText && text) {
        loadingText.textContent = text;
    }
}

// Function to collect elevation data using bulk lookup
async function collectElevationData() {
    // Check if histogram search is enabled
    if (!histogramSearchEnabled) {
        // Show message and return
        const histogram = document.getElementById('elevationHistogram');
        if (histogram) {
            histogram.style.display = 'none';
        }
        return;
    }
    
    if (isCollectingData) return;
    isCollectingData = true;
    isCancellingElevation = false;
    
    // Reset daily limit at start of new collection
    requestsRemaining = 1000;
    openTopoDataEnabled = true;
    
    const loadingIndicator = document.getElementById('loadingIndicator');
    const histogramContainer = document.getElementById('histogramContainer');
    
    // Reset UI
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingStatusText">Fetching observations...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loadingProgressBar"></div>
            </div>
            <button id="cancelElevationBtn" class="btn" style="margin-top: 12px; padding: 6px 12px; font-size: 11px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Cancel Elevation Lookup
            </button>
        `;
        
        document.getElementById('cancelElevationBtn').addEventListener('click', cancelElevationLookup);
    }
    
    if (histogramContainer) histogramContainer.style.display = 'none';
    
    updateLoadingProgress(0, 'Fetching observations...');
    elevationData = [];
    
    try {
        // Get ALL observations (not limited to 500)
        let allObservations = [];
        let page = 1;
        const perPage = 200;
        let hasMore = true;
        let totalObservations = 0;
        
        // First, get total count to show accurate progress
        const countUrl = `${inat_urlbase}observations?per_page=1&${winurlparams}`;
        const countResponse = await fetch(countUrl);
        const countData = await countResponse.json();
        totalObservations = countData.total_results || 0;

		const shouldContinue = checkLargeDatasetWarning(totalObservations);
		if (!shouldContinue) {
			isCollectingData = false;
			
			// Update histogram to show disabled state
			const histogram = document.getElementById('elevationHistogram');
			if (histogram) {
				histogram.style.display = 'none';
			}
			return;
		}
        
        if (totalObservations === 0) {
            showNoObservationsMessage();
            return;
        }
        
        updateLoadingProgress(5, `Found ${totalObservations} total observations...`);
        
        // Fetch observations in batches
        while (hasMore && !isCancellingElevation) {
            const observationsUrl = `${inat_urlbase}observations?per_page=${perPage}&page=${page}&${winurlparams}`;
            const response = await fetch(observationsUrl);
            const data = await response.json();
            
            if (!data.results || data.results.length === 0) {
                hasMore = false;
                break;
            }
            
            allObservations = allObservations.concat(data.results);
            
            updateLoadingProgress(
                5 + (allObservations.length / totalObservations * 25),
                `Loaded ${allObservations.length} of ${totalObservations} observations...`
            );
            
            if (data.results.length < perPage) {
                hasMore = false;
            }
            page++;
            
            // Optional: limit for testing, remove in production
            // if (allObservations.length >= 2000) break; // Test with fewer
        }
        
        if (isCancellingElevation) {
            showCancellationMessage();
            return;
        }
        
        if (allObservations.length === 0) {
            showNoObservationsMessage();
            return;
        }
        
        // Filter to observations with coordinates
        const validObservations = allObservations.filter(obs => 
            obs.geojson && obs.geojson.coordinates
        );
        
        updateLoadingProgress(30, `Processing ${validObservations.length} observations with coordinates...`);
        
        if (validObservations.length === 0) {
            showNoObservationsMessage();
            return;
        }
        
        // Prepare ALL coordinates for bulk lookup
        const coordsToLookup = validObservations.map(obs => ({
            lat: obs.geojson.coordinates[1],
            lng: obs.geojson.coordinates[0],
            obs: obs
        }));
        
        updateLoadingProgress(35, `Getting elevations for ${coordsToLookup.length} locations...`);
        
        // Use bulk elevation lookup with Open Topo Data
        const elevations = await getBulkElevation(coordsToLookup);
        
        if (isCancellingElevation) {
            showCancellationMessage();
            return;
        }
        
        updateLoadingProgress(90, 'Processing data...');
        
        // Combine elevation data with observations
        coordsToLookup.forEach((coord, index) => {
            if (elevations[index] !== null) {
                elevationData.push({
                    id: coord.obs.id,
                    lat: coord.lat,
                    lng: coord.lng,
                    elevation: elevations[index],
                    observation: coord.obs
                });
            }
        });
        
        // Hide loading, show histogram
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        if (histogramContainer) histogramContainer.style.display = 'flex';
        
        // Create histogram if we have data
        if (elevationData.length > 0) {
            createHorizontalHistogram();
        } else {
            showNoElevationDataMessage();
        }
        
        updateLoadingProgress(100, 'Complete!');
        
    } catch (error) {
        console.error('Error collecting elevation data:', error);
        showErrorMessage('Error loading elevation data');
    } finally {
        isCollectingData = false;
        if (delayTimer) {
            clearTimeout(delayTimer);
            delayTimer = null;
        }
    }
}

// Function to cancel elevation lookup
function cancelElevationLookup() {
    isCancellingElevation = true;
    
    // Clear any pending delay timer
    if (delayTimer) {
        clearTimeout(delayTimer);
        delayTimer = null;
    }
    
    // Update UI to show cancellation
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">â¹ï¸</div>
                <div class="empty-state-title">Cancelled</div>
                <div class="empty-state-subtitle">Elevation lookup was cancelled</div>
                <button class="btn" onclick="refreshElevationHistogram()" style="margin-top: 12px; padding: 6px 12px; font-size: 11px;">
                    Try Again
                </button>
            </div>
        `;
    }
}

// Function to show cancellation message
function showCancellationMessage() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">â¹ï¸</div>
                <div class="empty-state-title">Cancelled</div>
                <div class="empty-state-subtitle">Elevation lookup was cancelled</div>
                <button class="btn" onclick="refreshElevationHistogram()" style="margin-top: 12px; padding: 6px 12px; font-size: 11px;">
                    Try Again
                </button>
            </div>
        `;
    }
}

// Function for bulk elevation lookup
async function getBulkElevation(coordinates) {
    if (coordinates.length === 0) return [];
    
    const elevations = new Array(coordinates.length).fill(null);
    
    // Reset cancellation flag
    isCancellingElevation = false;
    
    // Check if Open Topo Data is available (within daily limits)
    if (openTopoDataEnabled && requestsRemaining > 0) {
        try {
            // Split coordinates into chunks of 100 (OpenTopoData limit)
			const chunkSize = 100;
			const coordinateChunks = [];

			for (let i = 0; i < coordinates.length; i += chunkSize) {
				coordinateChunks.push(coordinates.slice(i, i + chunkSize));
			}

			// Track how many we can actually process
			let coordinatesToProcess = coordinates.length;
			if (coordinates.length > 10000) {
				coordinatesToProcess = 10000;
				console.warn(`Processing first 10,000 of ${coordinates.length} coordinates (daily limit)`);
			}

			const chunksToProcess = Math.ceil(coordinatesToProcess / chunkSize);

			// Process each chunk
			for (let chunkIndex = 0; chunkIndex < chunksToProcess; chunkIndex++) {
				if (isCancellingElevation) {
					console.log('Elevation lookup cancelled');
					break;
				}
				
				// Check daily limit
				if (requestsRemaining <= 0) {
					console.warn(`Open Topo Data daily limit reached. Processed ${chunkIndex * chunkSize} of ${coordinates.length} coordinates.`);
					openTopoDataEnabled = false;
					break;
				}
				
				const chunk = coordinateChunks[chunkIndex];
				const chunkStartIndex = chunkIndex * chunkSize;
				
				// Create locations string for Open Topo Data API
				const locations = chunk.map(coord => 
					`${coord.lat.toFixed(6)},${coord.lng.toFixed(6)}`
				).join('|');
				
				// Calculate delay based on rate limiting
				const now = Date.now();
				const delay = Math.max(0, nextRequestTime - now);
				
				if (delay > 0) {
					updateLoadingProgress(
						40 + (chunkIndex / chunksToProcess * 40),
						`Getting elevations: ${chunkIndex * chunkSize + 1}-${Math.min((chunkIndex + 1) * chunkSize, coordinates.length)} of ${coordinates.length} (Waiting ${(delay / 1000).toFixed(1)}s)`
					);
					
					await new Promise(resolve => {
						delayTimer = setTimeout(resolve, delay);
					});
					delayTimer = null;
				}
				
				updateLoadingProgress(
					40 + (chunkIndex / chunksToProcess * 40),
					`Getting elevations: ${chunkIndex * chunkSize + 1}-${Math.min((chunkIndex + 1) * chunkSize, coordinates.length)} of ${coordinates.length}`
				);
                
				// Make request to Open Topo Data through CORS proxy
				const openTopoDataUrl = `https://api.opentopodata.org/v1/aster30m?locations=${locations}`;
				const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(openTopoDataUrl)}`;

				try {
					const response = await fetch(proxyUrl, {
						method: 'GET',
						headers: {
							'Accept': 'application/json',
						}
					});
					
					if (response.ok) {
						const data = await response.json();
                        
                        if (data.results && data.results.length === chunk.length) {
                            data.results.forEach((result, resultIndex) => {
                                const globalIndex = chunkStartIndex + resultIndex;
                                if (result.elevation !== null && result.elevation !== undefined) {
                                    // Convert meters to feet (1 meter = 3.28084 feet)
                                    elevations[globalIndex] = result.elevation * 3.28084;
                                }
                            });
                            
                            // Update rate limiting
                            requestsRemaining--;
                            nextRequestTime = Date.now() + 1000; // 1 second delay between requests
                            
                            // Check daily limit
                            if (requestsRemaining <= 0) {
                                openTopoDataEnabled = false;
                                console.warn('Open Topo Data daily limit reached, switching to fallback');
                                break;
                            }
                        } else {
                            console.warn('Open Topo Data returned unexpected response format');
                        }
                    } else if (response.status === 429) {
                        // Rate limited
                        console.warn('Open Topo Data rate limited, switching to fallback');
                        openTopoDataEnabled = false;
                        break;
                    } else {
                        console.warn(`Open Topo Data error ${response.status}, switching to fallback`);
                        openTopoDataEnabled = false;
                        break;
                    }
                } catch (error) {
                    console.warn('Open Topo Data request failed:', error);
                    openTopoDataEnabled = false;
                    break;
                }
            }
        } catch (error) {
            console.warn('Open Topo Data bulk processing failed:', error);
            openTopoDataEnabled = false;
        }
    }
    
    // Fill in any missing elevations with fallback services
    if (!openTopoDataEnabled || elevations.some(e => e === null)) {
        updateLoadingProgress(80, 'Using fallback elevation services...');
        
        // Try Open-Elevation for remaining null values
        const remainingIndices = elevations.map((elev, index) => elev === null ? index : -1)
                                          .filter(i => i !== -1);
        
        if (remainingIndices.length > 0) {
            // Process remaining coordinates in smaller batches for fallback
            const fallbackBatchSize = 10; // Smaller batches for fallback
            let processedCount = 0;
            
            for (let i = 0; i < remainingIndices.length; i += fallbackBatchSize) {
                if (isCancellingElevation) break;
                
                const batchIndices = remainingIndices.slice(i, i + fallbackBatchSize);
                const batchPromises = batchIndices.map(async (index) => {
                    const coord = coordinates[index];
                    const elevation = await getElevationForCoordinate(coord.lat, coord.lng);
                    elevations[index] = elevation;
                    processedCount++;
                    
                    updateLoadingProgress(
                        80 + (processedCount / remainingIndices.length * 15),
                        `Fallback: ${processedCount}/${remainingIndices.length}...`
                    );
                });
                
                await Promise.all(batchPromises);
                
                // Small delay between fallback batches to avoid overwhelming APIs
                if (i + fallbackBatchSize < remainingIndices.length && !isCancellingElevation) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }
    }
    
    return elevations;
}

// Function to get elevation for a single coordinate (fallback)
async function getElevationForCoordinate(lat, lng) {
   // Try USGS API first (feet)
   const usgsUrl = `https://epqs.nationalmap.gov/v1/json?y=${lat}&x=${lng}&output=json&units=Feet`;
   
   try {
      const response = await fetch(usgsUrl);
      const data = await response.json();
      
      if (data && data.value !== undefined && data.value > -1000000) {
         return data.value;
      }
   } catch (error) {
      console.warn('USGS elevation API failed for coordinate:', lat, lng);
   }
   
   // Try Open-Elevation API (meters)
   try {
      const openElevationUrl = `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`;
      const response = await fetch(openElevationUrl);
      const data = await response.json();
      
      if (data.results && data.results[0] && data.results[0].elevation !== undefined) {
         // Convert meters to feet (1 meter = 3.28084 feet)
         return data.results[0].elevation * 3.28084;
      }
   } catch (error) {
      console.warn('Open-Elevation API failed for coordinate:', lat, lng);
   }
   
   return null;
}

// Function to create horizontal histogram with evenly spaced elevation intervals
function createHorizontalHistogram() {
   if (elevationData.length === 0) return;
   
   // Extract elevations
   const elevations = elevationData.map(d => d.elevation);
   
   // Calculate statistics
   const minElevation = Math.min(...elevations);
   const maxElevation = Math.max(...elevations);
   const avgElevation = elevations.reduce((a, b) => a + b, 0) / elevations.length;
   
   // Determine elevation range - default to 6000ft, extend if needed
   const DEFAULT_MAX_ELEVATION = 6000;
   const maxElevationForChart = Math.max(DEFAULT_MAX_ELEVATION, Math.ceil(maxElevation / 1000) * 1000);
   
   // Use 500ft intervals, with at least 12 bins (0-6000ft)
   const binWidth = 500;
   const numBins = Math.ceil(maxElevationForChart / binWidth);
   
   // Create bin ranges
   const binRanges = [];
   for (let i = 0; i < numBins; i++) {
      const start = i * binWidth;
      const end = (i + 1) * binWidth;
      binRanges.push({ 
         start: Math.round(start), 
         end: Math.round(end),
         label: `${Math.round(start)}-${Math.round(end)} ft`
      });
   }
   
   // Initialize bins with zeros
   const bins = new Array(numBins).fill(0);
   
   // Populate bins
   for (const elevation of elevations) {
      let binIndex = Math.floor(elevation / binWidth);
      
      // Clamp to valid range
      if (binIndex < 0) binIndex = 0;
      if (binIndex >= numBins) binIndex = numBins - 1;
      
      bins[binIndex]++;
   }
   
   // Find max count for scaling (ignore empty bins for scaling)
   const nonZeroBins = bins.filter(count => count > 0);
   const maxCount = nonZeroBins.length > 0 ? Math.max(...nonZeroBins) : 0;
   
   // Create Y-axis with labels every 1000ft
   const histogramYAxis = document.getElementById('histogramYAxis');
   histogramYAxis.innerHTML = '<div class="y-axis-line"></div>';
   
   // Add Y-axis labels (show every 1000ft)
   const labelsToShow = [];
   for (let elevation = 0; elevation <= maxElevationForChart; elevation += 1000) {
      labelsToShow.push(elevation);
   }
   
   // Reverse labels so highest is at top
   labelsToShow.reverse().forEach(elevation => {
      const labelDiv = document.createElement('div');
      labelDiv.className = 'histogram-y-label';
      labelDiv.textContent = elevation === 0 ? '0' : `${elevation / 1000}k`;
      
      // Calculate position percentage (0% at bottom, 100% at top)
      const positionPercent = (elevation / maxElevationForChart) * 100;
      labelDiv.style.position = 'absolute';
      labelDiv.style.top = `${100 - positionPercent}%`;
      labelDiv.style.transform = 'translateY(-50%)';
      
      histogramYAxis.appendChild(labelDiv);
   });
   
   // Create horizontal bars
   const histogramChart = document.getElementById('histogramChart');
   histogramChart.innerHTML = '';
   
   // Add grid lines
   const chartGrid = document.createElement('div');
   chartGrid.className = 'chart-grid';
   
   // Add grid lines for each 1000ft
   for (let elevation = 0; elevation <= maxElevationForChart; elevation += 1000) {
      const positionPercent = (elevation / maxElevationForChart) * 100;
      const gridLine = document.createElement('div');
      gridLine.className = 'grid-line';
      gridLine.style.top = `${100 - positionPercent}%`;
      chartGrid.appendChild(gridLine);
   }
   
   histogramChart.appendChild(chartGrid);
   
   // Create rows (one for each 500ft bin, reversed so highest elevation is at top)
   const reversedBins = [...bins].reverse();
   const reversedBinRanges = [...binRanges].reverse();
   
   reversedBins.forEach((count, index) => {
	   const row = document.createElement('div');
	   row.className = 'histogram-row';
	   
	   // Add elevation range label on the left side
	   const rangeLabel = document.createElement('div');
	   rangeLabel.className = 'elevation-range-label';
	   rangeLabel.textContent = `${reversedBinRanges[index].start}â€“${reversedBinRanges[index].end}`;
	   rangeLabel.style.cssText = `
		  position: absolute;
		  left: 0px;
		  top: 45%;
		  transform: translateY(-50%);
		  font-size: 8px;
		  font-weight: 600;
		  color: #FFFFFF;
		  opacity: 0;
		  transition: opacity 0.2s ease;
		  pointer-events: none;
		  white-space: nowrap;
		  padding: 2px 4px;
		  border-radius: 3px;
		  z-index: 1001;
	   `;
	   row.appendChild(rangeLabel);
	   
	   // Create the bar
	   const bar = document.createElement('div');
	   bar.className = count > 0 ? 'histogram-bar' : 'histogram-bar empty';
	   
	   // Calculate width based on count (percentage of max count)
	   const widthPercent = maxCount > 0 && count > 0 ? (count / maxCount) * 100 : 0;
	   bar.style.width = `${widthPercent}%`;
	   
	   if (count > 0) {
		  // Add color gradient based on elevation
		  const elevation = reversedBinRanges[index].start;
		  const elevationRatio = elevation / maxElevationForChart;
		  const hue = 210 - (elevationRatio * 60); // Blue to purple gradient
		  bar.style.background = `linear-gradient(90deg, 
			 hsl(${hue}, 75%, 60%) 0%, 
			 hsl(${hue + 10}, 80%, 50%) 100%)`;
		  
		  // Add hover effect
		  bar.onmouseenter = () => {
			 bar.style.filter = 'brightness(1.15)';
			 rangeLabel.style.opacity = '1';
		  };
		  bar.onmouseleave = () => {
			 bar.style.filter = 'brightness(1)';
			 rangeLabel.style.opacity = '0';
		  };
		  
		  // Add count label inside bar
		  const countLabel = document.createElement('div');
		  countLabel.className = 'bar-count';
		  countLabel.textContent = count;
		  bar.appendChild(countLabel);
		  
		  // Click to show observations in this elevation range
		  bar.onclick = () => {
			 showObservationsInRange(reversedBinRanges[index].start, reversedBinRanges[index].end);
		  };
	   }
	   
	   row.appendChild(bar);
	   histogramChart.appendChild(row);
	});
   
   // Create X-axis labels
   const xAxis = document.getElementById('histogramXAxis');
   if (maxCount <= 10) {
      // For small counts, show all values
      const xLabels = [];
      for (let i = 0; i <= maxCount; i++) {
         xLabels.push(i);
      }
      xAxis.innerHTML = `
         <div class="histogram-x-labels" style="justify-content: space-between;">
            ${xLabels.map(val => `<span>${val}</span>`).join('')}
         </div>
      `;
   } else {
      // For larger counts, show up to 5 evenly spaced values
      const numLabels = Math.min(5, maxCount);
      const xLabels = [];
      for (let i = 0; i <= numLabels; i++) {
         const value = Math.round((i / numLabels) * maxCount);
         xLabels.push(value);
      }
      
      // Remove duplicates
      const uniqueLabels = [...new Set(xLabels)];
      
      xAxis.innerHTML = `
         <div class="histogram-x-labels">
            ${uniqueLabels.map(val => `<span>${val}</span>`).join('')}
         </div>
      `;
   }
   
   // Update stats panel
   const stats = document.getElementById('histogramStats');
   stats.innerHTML = `
      <div class="stats-grid">
         <div class="stat-item">
            <div class="stat-label">Min Elevation</div>
            <div class="stat-value">${Math.round(minElevation)}<span class="stat-unit">ft</span></div>
         </div>
         <div class="stat-item">
            <div class="stat-label">Max Elevation</div>
            <div class="stat-value">${Math.round(maxElevation)}<span class="stat-unit">ft</span></div>
         </div>
         <div class="stat-item">
            <div class="stat-label">Average</div>
            <div class="stat-value">${Math.round(avgElevation)}<span class="stat-unit">ft</span></div>
         </div>
         <div class="stat-item">
            <div class="stat-label">Observations</div>
            <div class="stat-value">${elevationData.length}</div>
         </div>
      </div>
   `;
   
   // Update title to show elevation range
   const histogramTitle = document.querySelector('.histogram-title');
   if (histogramTitle) {
      if (maxElevation > DEFAULT_MAX_ELEVATION) {
         histogramTitle.textContent = `Elevation Distribution (ft)`;
      } else {
         histogramTitle.textContent = `Elevation Distribution (ft)`;
      }
   }
}

// Update the showObservationsInRange function to match
function showObservationsInRange(minElev, maxElev) {
   const observationsInRange = elevationData.filter(d => 
      d.elevation >= minElev && d.elevation < maxElev
   );
   
   // Create popup with observations in this range
   let popupContent = `<h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #2c3e50;">${minElev}-${maxElev} ft (${observationsInRange.length})</h4>`;
   popupContent += `<div style="max-height: 300px; overflow-y: auto; max-width: 320px;">`;
   
   if (observationsInRange.length === 0) {
      popupContent += `
         <div style="text-align: center; padding: 30px; color: #95a5a6;">
            <div style="font-size: 40px; margin-bottom: 12px; opacity: 0.3;">ðŸ”ï¸</div>
            <div style="font-size: 13px; margin-bottom: 6px;">No observations</div>
            <div style="font-size: 11px;">in this elevation range</div>
         </div>
      `;
   } else {
      observationsInRange.slice(0, 12).forEach((obsData, index) => {
         const obs = obsData.observation;
         const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
         const observer = obs.user?.login || 'Unknown';
         const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
         
         popupContent += `
            <div style="margin-bottom: 6px; padding: 10px; border-radius: 6px; display: flex; align-items: center; 
                       background: ${index % 2 === 0 ? '#f8f9fa' : 'white'}; border: 1px solid #e9ecef;">
               ${photoUrl ? 
                 `<img src="${photoUrl}" style="width: 42px; height: 42px; object-fit: cover; margin-right: 12px; border-radius: 4px; border: 1px solid #dee2e6;">` : 
                 `<div style="width: 42px; height: 42px; margin-right: 12px; background: linear-gradient(135deg, #e9ecef, #dee2e6); 
                      display: flex; align-items: center; justify-content: center; border-radius: 4px; color: #adb5bd; font-size: 12px; font-weight: 600;">ðŸ“·</div>`}
               <div style="flex: 1;">
                 <div style="font-size: 12px; font-weight: 600; color: #2c3e50; margin-bottom: 2px; line-height: 1.3;">${taxonName}</div>
                 <div style="font-size: 10px; color: #6c757d; margin-bottom: 3px;">
                    <span style="font-weight: 600; color: #3498db;">${Math.round(obsData.elevation)} ft</span> â€¢ By: ${observer}
                 </div>
                 <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" 
                    style="font-size: 11px; color: #3498db; text-decoration: none; font-weight: 500; display: inline-flex; align-items: center;">
                    View <span style="margin-left: 2px;">â†’</span>
                 </a>
               </div>
            </div>
         `;
      });
      
      if (observationsInRange.length > 12) {
         popupContent += `
            <div style="text-align: center; padding: 10px; font-size: 11px; color: #6c757d; background: #f8f9fa; border-radius: 4px; margin-top: 4px;">
               ... and ${observationsInRange.length - 12} more observations
            </div>
         `;
      }
   }
   
   popupContent += `</div>`;
   
   // Show popup at center of map
   L.popup()
      .setLatLng(mymap.getCenter())
      .setContent(popupContent)
      .openOn(mymap);
}

// Function to show observations in a specific elevation range
function showObservationsInRange(minElev, maxElev) {
   const observationsInRange = elevationData.filter(d => 
      d.elevation >= minElev && d.elevation < maxElev // Use < instead of <= for exclusive upper bound
   );
   
   // Create popup with observations in this range
   let popupContent = `<h4 style="margin: 0 0 10px 0; font-size: 14px;">${minElev}-${maxElev} ft (${observationsInRange.length})</h4>`;
   popupContent += `<div style="max-height: 300px; overflow-y: auto; max-width: 300px;">`;
   
   if (observationsInRange.length === 0) {
      popupContent += `<div style="text-align: center; padding: 20px; color: #666;">No observations in this elevation range</div>`;
   } else {
      observationsInRange.slice(0, 15).forEach((obsData, index) => {
         const obs = obsData.observation;
         const taxonName = obs.taxon?.preferred_common_name || obs.taxon?.name || 'Unknown';
         const observer = obs.user?.login || 'Unknown';
         const photoUrl = obs.photos?.[0]?.square_url || obs.photos?.[0]?.url || '';
         
         popupContent += `
            <div style="margin-bottom: 8px; padding: 8px; border-bottom: 1px solid #eee; display: flex; align-items: center; background: ${index % 2 === 0 ? '#f9f9f9' : 'white'};">
               ${photoUrl ? `<img src="${photoUrl}" style="width: 40px; height: 40px; object-fit: cover; margin-right: 10px; border-radius: 3px;">` : 
                 `<div style="width: 40px; height: 40px; margin-right: 10px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; border-radius: 3px; color: #999; font-size: 12px;">No photo</div>`}
               <div style="flex: 1;">
                 <strong style="font-size: 12px; display: block; margin-bottom: 2px;">${taxonName}</strong>
                 <div style="font-size: 10px; color: #666; margin-bottom: 2px;">${Math.round(obsData.elevation)} ft</div>
                 <div style="font-size: 10px; color: #666; margin-bottom: 3px;">By: ${observer}</div>
                 <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" 
                    style="font-size: 10px; color: #4caf50; text-decoration: none;">View observation â†’</a>
               </div>
            </div>
         `;
      });
      
      if (observationsInRange.length > 15) {
         popupContent += `<div style="text-align: center; padding: 10px; font-size: 11px; color: #666;">... and ${observationsInRange.length - 15} more observations</div>`;
      }
   }
   
   popupContent += `</div>`;
   
   // Show popup at center of map
   L.popup()
      .setLatLng(mymap.getCenter())
      .setContent(popupContent)
      .openOn(mymap);
}

// Function to show message when no elevation data is available
function showNoElevationDataMessage() {
   const loadingIndicator = document.getElementById('loadingIndicator');
   const histogramContainer = document.getElementById('histogramContainer');
   
   if (loadingIndicator) {
      loadingIndicator.innerHTML = `
         <div class="empty-state">
            <div class="empty-state-icon">ðŸ—ºï¸</div>
            <div style="font-size: 13px; margin-bottom: 5px;">No elevation data available</div>
            <div style="font-size: 11px; color: #888;">Elevation data is primarily available for locations in the USA.</div>
         </div>
      `;
   }
   if (histogramContainer) histogramContainer.style.display = 'none';
}

// Function to show message when no observations found
function showNoObservationsMessage() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const histogramContainer = document.getElementById('histogramContainer');
    
    if (loadingIndicator) {
        loadingIndicator.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">ðŸ”</div>
                <div style="font-size: 13px;">No observations found</div>
                <div style="font-size: 11px; color: #888; margin-top: 5px;">Try adjusting your search filters</div>
            </div>
        `;
    }
    if (histogramContainer) histogramContainer.style.display = 'none';
}

// Function to show error message
function showErrorMessage(message) {
   const loadingIndicator = document.getElementById('loadingIndicator');
   const histogramContainer = document.getElementById('histogramContainer');
   
   if (loadingIndicator) {
      loadingIndicator.innerHTML = `
         <div class="empty-state">
            <div class="empty-state-icon" style="color: #d32f2f;">âŒ</div>
            <div style="font-size: 13px; color: #d32f2f; margin-bottom: 5px;">Error</div>
            <div style="font-size: 11px; color: #888;">${message}</div>
         </div>
      `;
   }
   if (histogramContainer) histogramContainer.style.display = 'none';
}

// Function to update histogram when map view changes
function updateHistogramOnViewChange(newView) {
    const histogram = document.getElementById('elevationHistogram');
    
    if (newView === 'elevation') {
        // Show the histogram toggle
        const histogramToggle = document.getElementById('elevation-histogram-toggle');
        if (histogramToggle) {
            histogramToggle.style.display = 'block';
        }
        
        // Only show histogram if search is enabled AND we're reloading the page
        // (histogram will be started via initializeFilterValues on page reload)
        if (histogramSearchEnabled && histogram) {
            histogram.style.display = 'block';
        }
    } else {
        // Hide histogram toggle for other views
        const histogramToggle = document.getElementById('elevation-histogram-toggle');
        if (histogramToggle) {
            histogramToggle.style.display = 'none';
        }
        
        // Hide histogram if visible
        if (histogram) {
            histogram.style.display = 'none';
        }
    }
}

// Modify the existing toggleView function to handle histogram
const originalToggleView = window.toggleView;
window.toggleView = function(view) {
   originalToggleView.call(this, view);
   updateHistogramOnViewChange(view);
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    const params = new URLSearchParams(window.location.search);
    const taxonName = params.get('taxon_name');
    const placeName = params.get('place_name');
    const placeId = params.get('place_id');
    const view = params.get('view') || 'default';
    
    if (taxonName) {
        document.getElementById('taxon_name').value = taxonName;
        updateClearButton('taxon_name');
    }
    
    if (placeName) {
        document.getElementById('place_name').value = placeName;
        updateClearButton('place_name');
    }
    
    if (placeId) {
        document.getElementById('place_id').value = placeId;
        selectedPlaceId = placeId;
    }
    
    // Initialize month checkbox events
    document.querySelectorAll('#date-month input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('change', updateMonthFilter);
    });
    
    // Initialize histogram state
    histogramSearchEnabled = false;
    elevationSearchConfirmed = false;
    histogramStarted = false; // Reset flag
    
    // If we're in elevation view, show the toggle
    if (view === 'elevation') {
        const histogramToggle = document.getElementById('elevation-histogram-toggle');
        if (histogramToggle) {
            histogramToggle.style.display = 'block';
        }
        
        // Check if histogram was previously enabled via URL
        const histogramEnabled = params.get('histogram_enabled') === 'true';
        if (histogramEnabled) {
            histogramSearchEnabled = true;
            elevationSearchConfirmed = true;
            const histogramCheckbox = document.getElementById('enable-histogram');
            if (histogramCheckbox) {
                histogramCheckbox.checked = true;
            }
            
            // Start histogram after a short delay
            setTimeout(() => {
                initElevationHistogram();
            }, 1000);
        }
    }
    
    // Hide filters initially
    hideFilters();
});

// Refresh function
function refreshElevationHistogram() {
    if (view === 'elevation' && !isCollectingData) {
        histogramStarted = false; // Allow fresh start
        collectElevationData();
    }
}

// Expose refresh function globally
window.refreshElevationHistogram = refreshElevationHistogram;

// Add keyboard shortcut (Alt+H to toggle histogram)
document.addEventListener('keydown', function(e) {
   if (e.altKey && e.key === 'h') {
      const histogram = document.getElementById('elevationHistogram');
      if (histogram) {
         toggleElevationHistogram();
      }
   }
});

// Get parameters from the url
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));

// Check if this is a fresh load with no parameters
if (winurlparams.toString() === '' || 
    (winurlparams.toString() === 'view=default' && winurlparams.size === 1)) {
   // Redirect to default search
   const defaultParams = new URLSearchParams();
   defaultParams.set('taxon_name', 'King Bolete');
   defaultParams.set('place_name', 'Washington, US');
   defaultParams.set('place_id', '46');
   defaultParams.set('view', 'default');
   
   window.location.href = window.location.pathname + '?' + defaultParams.toString();
   // Page will reload with parameters, so stop here
   // Add a loading message or let it redirect
   document.body.innerHTML = '<div style="padding: 20px; text-align: center;">Loading default search: King Bolete in Washington, US...</div>';
   throw new Error("Redirecting to default search");
}
// Extract ALL parameters first
var taxon_name = winurlparams.get('taxon_name');
var place_name = winurlparams.get('place_name');
var taxon_id = winurlparams.get('taxon_id');
taxon_id = (taxon_id===null?null:taxon_id.split(',')[0]);
var place_id = winurlparams.get('place_id');
place_id = (place_id===null?null:place_id.split(',')[0]);
var centerlat = winurlparams.get('centerlat');
var centerlng = winurlparams.get('centerlng');
var defaultzoom = winurlparams.get('defaultzoom');
var showtaxonplace = winurlparams.get('showtaxonplace') || 'false';
var showtaxonrange = winurlparams.get('showtaxonrange') || 'false';
var showexpectednearby = winurlparams.get('showexpectednearby') || 'false';
var showplace = winurlparams.get('showplace') || 'false';
var view = winurlparams.get('view') || 'default';
var compexclparam = winurlparams.get('compare_exclude_param'); // Moved up
var thresholded = winurlparams.get('thresholded') || 'true';
winurlparams.delete('centerlat');
winurlparams.delete('centerlng');
winurlparams.delete('defaultzoom');
winurlparams.delete('showtaxonplace');
winurlparams.delete('showtaxonrange');
winurlparams.delete('showexpectednearby');
winurlparams.delete('showplace');
winurlparams.delete('view');
winurlparams.delete('compare_exclude_param');
winurlparams.delete('thresholded');
let compareurlparams = new URLSearchParams(winurlparams);
if (compexclparam) { for (p of compexclparam.split(',')) { compareurlparams.delete(p); }; };
function fdate(str) {
   str = str.replace(/t/i,' '); //replaces T (case insensitive) with a space
   str = str.replace(/([+-]\d{2}\:?\d{2})/,' ($1)'); //puts parenthesis around time zone offset
   str = str.replace(/z/i,' (+00:00)'); //replaces Z (case insensitve) with UTC
   str = str.replace('+00:00','Â±00:00');
   return str;
};
function fround(num,places) {
   var n = num*1;
   return n.toFixed(places); 
};
function furl(url,txt=url) { return '<a href="'+url+'">'+txt+'</a>'; };
function faddelem(etype,eparent=null,eclass=null,eid=null,ehtml=null,etext=null) {
   var eobj = document.createElement(etype);
   if (eclass!==null) { eobj.classList = eclass };
   if (eid!==null) { eobj.id = eid };
   if (ehtml!==null) { eobj.innerHTML = ehtml };
   if (etext!==null) { eobj.innerText = etext };
   if (eparent!==null) { eparent.appendChild(eobj); };
   return eobj;
};
function ffetch(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};
let inat_urlbase = 'https://api.inaturalist.org/v1/';
if (winurlparams=="") {
   var div = faddelem('div',document.body,null,'info');
   faddelem('h1',div,null,null,'Map of iNaturalist Observations');
   faddelem('p',div,null,null,'This page displays a map of iNaturalist observations. Clicking on any observation marker opens a pop-up window which provides basic details of the observation');
   faddelem('p',div,null,null,'This page requires that you input at least one filter parameter in the URL. For example, if the URL of this page is '+winurlexsearchstr +', and you want to see research grade ocotillo observations, then you would navigate to '+furl(winurlexsearchstr+'?taxon_id=49325&quality_grade=research')+' in your web browser. This page will accept most parameters documented for the '+ furl(inat_urlbase+'docs/#!/Observations/get_observations','iNaturalist API Get Observations Endpoint')+ '.');
   faddelem('p',div,null,null,'If place_id is included as a parameter, then the place polygon will be available as an optional layer in the map. If taxon_id is included as a parameter, then taxon places and taxon range will be available as optional layers in this map (if they have been defined in iNaturalist).');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=elevation", then the map will display with the USGS topo basemap (with contours in feet) by default, and the info pop-ups will include elevation (sourced from the '+furl('https://epqs.nationalmap.gov/','USGS elevation point query service')+'). USGS does not provide elevations outside of the United States. In cases where the USGS returns no data, the page will fall back to the '+furl('https://open-elevation.com/','Open-Elevation API')+'. As an example, if you want to see mountain goats in the United States, then you would navigate to '+furl(winurlexsearchstr+'?view=elevation&taxon_id=42414&place_id=1')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=heatmap", then the map will show a heatmap view of observations on a muted-color basemap. By default, clicking the heatmap will not open a info pop-up. As an example, to get an idea of where user kueda has made observations, you would navigate to '+furl(winurlexsearchstr+'?view=heatmap&user_id=kueda')+' in your web browser.');
   faddelem('p',div,null,null,'If a special "view" parameter is set to "=subsetratio", then the map will compare a gridded view of one set of observations (the subset, defined in the URL) to another set (the superset, defined by a required special "compare_exclude_param" parameter, which removes one or more parameters from the subset parameter list). The color of the markers will vary based on the ratio of subset to superset for each cell (red=1.0 and blue=0.0), and they will appear on top of a gray basemap. As an example, to compare research grade plant observations to verifiable plant observations, you would navigate to '+furl(winurlexsearchstr+'?view=subsetratio&verifiable=true&quality_grade=research&taxon_id=47126&compare_exclude_param=quality_grade')+' in your web browser. Note that if you use exclusion filter parameters (ex. not_user_id) in your subset and remove them from the superset, then you may get unexpected results (because the subset would no longer be a true subset).');    //faddelem('p',div,null,null,'If a special "view" parameter is set to "=ecolandunit", then the map will display with a USGS Ecological Land Unit overlay on a dark basemap by default, and the info pop-ups will include USGS ELU information (sourced from '+furl('https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems','USGS Global Ecosystems')+'). This should work on any point of land worldwide. As an example, if you want to see maples around the world, then you would navigate to '+furl(winurlexsearchstr+'?view=ecolandunit&taxon_id=47727&defaultzoom=2')+' in your web browser.');
   faddelem('p',div,null,null,'The map used to offer a USGS Ecological Land Unit overlay on a dark basemap, with pop-ups offering detailed USGS ELU information (sourced from '+furl('https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems','USGS Global Ecosystems')+'). However, USGS no longer provides this data as of early 2025. USGS offers similar, newer data in the form of '+furl('https://www.sciencebase.gov/catalog/item/6296791ed34ec53d276bb293','World Terrestrial Ecosystems') +'. However, WTEs do not appear to be as detailed / useful as ELUs. So this map does not offer WTEs as a replacement option.');
   faddelem('p',div,null,null,'There are 2 final sets of special parameters: centerlat, centerlng, and defaultzoom can be used to set the default map center and zoom level when the map is first opened; and showtaxonplace, showtaxonrange, showexpectednearby, and showplace can be set to true to display specific layers by default.');
}
else {
   var mapdiv = faddelem('div',document.body,null,'mapid');
   // iNat Observation Layer, using grid markers at lower zooms and points at higher zooms
//   let inat_circles = {url:inat_urlbase+'colored_heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Density Circles)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_colored_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
   let inat_heat = {url:inat_urlbase+'heatmap/{z}/{x}/{y}.png',description:'iNaturalist Observations (Heatmap)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_heatmap_zoom_x_y_png">iNaturalist observation data</a>'};
//   let gbif_density_point_py = {url:'https://api.gbif.org/v2/map/occurrence/density/{z}/{x}/{y}@1x.png?srs=EPSG:3857&style=purpleYellow.point&publishingOrg=28eb1a3f-1c15-4a95-931a-4af90ecb574d',description:'iNaturalist Observations in GBIF',attribution:'<a href="https://www.gbif.org/developer/maps">GBIF occurrence data</a>'};
//   var l_inat_circles = L.tileLayer(inat_circles.url+'?'+winurlparams,{minZoom:2, maxZoom:20, attribution:inat_circles.attribution});
   var l_inat_heat = L.tileLayer(inat_heat.url+'?'+winurlparams,{minZoom:0, maxZoom:20, attribution:inat_heat.attribution});
//   var l_gbif = L.tileLayer(gbif_density_point_py.url,{minZoom:2, maxZoom:20, attribution:gbif_density_point_py.attribution});
   let inat_points = {url:inat_urlbase+'points/{z}/{x}/{y}.png',description:'iNaturalist Observations (Points)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_points_zoom_x_y_png">iNaturalist observation data</a>'};
   let inat_grid = {url:inat_urlbase+'grid/{z}/{x}/{y}.png',description:'iNaturalist Observations (Grid)',attribution:'<a href="https://api.inaturalist.org/v1/docs/#!/Observation_Tiles/get_grid_zoom_x_y_png">iNaturalist observation data</a>'};
   var l_inat_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:0,maxZoom:20, attribution:inat_points.attribution});
   var l_inat_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:0,maxZoom:20,attribution:inat_grid.attribution});
   var l_inat_obs_points = L.tileLayer(inat_points.url+'?'+winurlparams,{minZoom:10,maxZoom:20, attribution:inat_points.attribution});
   var l_inat_obs_grid = L.tileLayer(inat_grid.url+'?'+winurlparams,{minZoom:2,maxZoom:9,attribution:inat_grid.attribution});
   var g_inat_obs = L.layerGroup([l_inat_obs_grid,l_inat_obs_points]);
   // iNat Observation Layer mods
   var l_inat_heat_mod_transparent = L.tileLayer.styleFilter(inat_heat.url+'?'+winurlparams,{minZoom:0, maxZoom:20, attribution:inat_heat.attribution, filter:'opacity(50%)'});
   // iNat UTFGrid Selection
   // (hover to see selected area, and click to view selected observation)
   async function fpopup(obs,count) {
      var s = (obs.photos.length==0) ? '[No Photo]' : '<img src="'+obs.photos[0].url+'" />';
      s += (obs.photos.length>1) ? ' ['+obs.photos.length+']' : '';
      s += '<br />observation #: <a target="_blank" href="'+obs.uri+'">'+obs.id+'</a> (grade: '+obs.quality_grade+')';
      s += '<br />taxon: ' + ((obs.taxon==null) ? '[Unknown]' : obs.taxon.preferred_common_name ? (obs.taxon.preferred_common_name+' ('+obs.taxon.name+')') : obs.taxon.name );
      s += '<br />observer: '+obs.user.login;
//      s += '<br />location: '+obs.place_guess;
      s += '<br />coordinates: '+fround(obs.geojson.coordinates[1],6)+', '+fround(obs.geojson.coordinates[0],6);
      s += (obs.positional_accuracy==null) ? '' : ' ('+fround(obs.positional_accuracy,1)+'m)';
      if (view==='elevation') {
         var elevationurl = 'https://epqs.nationalmap.gov/v1/json?y='+obs.geojson.coordinates[1]+'&x='+obs.geojson.coordinates[0]+'&output=json&units=Feet';
         var elevation = await ffetch(elevationurl)
            .then((data) => {
               return data;
            });
         if ((elevation?elevation.value:-1000000)>-1000000) { s += '<br />elevation: '+ (fround(elevation.value,1)+'ft, '+ fround(elevation.value*0.3048,1) + 'm'); }
         else {
            var elevationurl_fallback = 'https://api.open-elevation.com/api/v1/lookup?locations='+obs.geojson.coordinates[1]+','+obs.geojson.coordinates[0];
            var elevation_fallback = await ffetch(elevationurl_fallback)
               .then((data) => {
                  return data?.results[0];
               });
            s += '<br />elevation: '+ (elevation_fallback?(elevation_fallback.elevation+'m'):'[Unknown]');
         };
      };
      s += '<br />observed: '+((obs.time_observed_at==null) ? ((obs.observed_on==null) ? '[Unknown]': obs.observed_on) : fdate(obs.time_observed_at));
      s += '<br />created: '+((obs.created_at==null) ? obs.created_at_details.date : fdate(obs.created_at));
      s += '<br />last updated: '+fdate(obs.updated_at);
//      if (obs.description==null) {}
//      else if (obs.description.length < 200) {s += '<br />'+obs.description }
//      else {s += '<br />'+(obs.description.substring(0,191)+'... (more)')};
/*
      // ecological land units data is no longer provided as of early 2025 :(
      if (view==='ecolandunit') {
         function latlngtoxy(latlng) { return L.CRS.EPSG3857.project(latlng); };
         let mapExtent = mymap.getBounds();
         let pointXY = latlngtoxy(L.latLng(obs.geojson.coordinates[1],obs.geojson.coordinates[0]));
         var ecoluurl = `https://rmgsc.cr.usgs.gov/arcgis/rest/services/globalelus/MapServer/identify?geometry={"x":${pointXY.x},"y":${pointXY.y}}&geometryType=esriGeometryPoint&sr=102100&layers=all:4&tolerance=3&mapExtent=${latlngtoxy(mapExtent.getNorthWest()).x},${latlngtoxy(mapExtent.getNorthWest()).y},${latlngtoxy(mapExtent.getSouthEast()).x},${latlngtoxy(mapExtent.getSouthEast()).y}&imageDisplay=1,1,96&returnGeometry=false&returnZ=false&returnM=false&returnUnformattedValues=false&f=pjson`;
         var ecoludetails = await ffetch(ecoluurl)
            .then((data) => {
               return data.results[0].attributes;
            });
         s += '<hr /><details>'
         s += '<summary>Ecological Land Unit: ' + (ecoludetails ? (ecoludetails['Raster.ELU'] ?? 'N/A') : 'N/A') + '</summary>';
         s += '- Bioclimate: ' + (ecoludetails ? (ecoludetails['Raster.ELU_Bio_De'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Cover: ' + (ecoludetails ? (ecoludetails['Raster.ELU_GLC_De'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Form: ' + (ecoludetails ? (ecoludetails['Raster.ELU_LF_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Lithology: ' + (ecoludetails ? (ecoludetails['Raster.ELU_Lit_De'] ?? 'N/A') : 'N/A');
         s += '</details>';
         s += '<hr /><details>';
         s += '<summary>Ecological Facet: ' + (ecoludetails ? (ecoludetails['Raster.EF'] ?? 'N/A') : 'N/A') + '</summary>';
         s += '- Bioclimate: ' + (ecoludetails ? (ecoludetails['Raster.EF_Bio_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Cover: ' + (ecoludetails ? (ecoludetails['Raster.EF_GLC_Des'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Form: ' + (ecoludetails ? (ecoludetails['Raster.EF_LF_Desc'] ?? 'N/A') : 'N/A');
         s += '<br /> - Land Lithology: ' + (ecoludetails ? (ecoludetails['Raster.EF_Lit_Des'] ?? 'N/A') : 'N/A');
         s += '</details>';
         var ecosysdetails;
         let contSets = ['US','SA','AF'];
         for (let cont of contSets) {
            var ecosysurl = `https://rmgsc.cr.usgs.gov/arcgis/rest/services/cont${cont}/MapServer/identify?geometry={"x":${pointXY.x},"y":${pointXY.y}}&geometryType=esriGeometryPoint&sr=102100&layers=all:0,1,2,3,4&tolerance=3&mapExtent=${latlngtoxy(mapExtent.getNorthWest()).x},${latlngtoxy(mapExtent.getNorthWest()).y},${latlngtoxy(mapExtent.getSouthEast()).x},${latlngtoxy(mapExtent.getSouthEast()).y}&imageDisplay=1,1,96&returnGeometry=false&returnZ=false&returnM=false&returnUnformattedValues=false&f=pjson`;
            ecosysdetails = await ffetch(ecosysurl)
               .then((data) => {
                  return ((data.results?.length||0)===0) ? null : data.results;
               });
            if (ecosysdetails) { break; };
         };
         
         if (ecosysdetails) {
         s += '<hr /><details>';
            s += '<summary>Ecosystem: ' + (ecosysdetails[0]?.attributes ? (ecosysdetails[0]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A') + '</summary>';
            s += '- Bioclimate: ' + (ecosysdetails[1].attributes ? (ecosysdetails[1].attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            s += '<br /> - Land Form: ' + (ecosysdetails[2]?.attributes ? (ecosysdetails[2]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            s += '<br /> - Land Lithology: ' + (ecosysdetails[3]?.attributes ? (ecosysdetails[3]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A');
            if (ecosysdetails.length>4) {s += '<br /> - Topographic Position: ' + (ecosysdetails[4]?.attributes ? (ecosysdetails[4]?.attributes['Raster.code_desc'] ?? 'N/A') : 'N/A'); };
            s += '</details>';
         };
      };
*/
      if (count>1) {
         s += '<hr />'
         s += `This marker also denotes ${count-1} older observation${(count>2)?'s':''}.`
      };
      L.popup().setLatLng([obs.geojson.coordinates[1],obs.geojson.coordinates[0]])
         .setContent(s).openOn(mymap);
   };
   var u_inat_options = {
      resolution: 4,
      pointerCursor: true,
      mouseInterval: 66,  // Delay for mousemove events
      minZoom:0,
      maxZoom:20, 
   };
   var u_inat_points = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, { ...u_inat_options, minZoom:10 });
   u_inat_points.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_points_all = L.utfGrid(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, u_inat_options);
   u_inat_points_all.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_grid = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, { ...u_inat_options, minZoom:2, maxZoom:9 });
   u_inat_grid.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_grid_all = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, u_inat_options);
   u_inat_grid_all.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var u_inat_grid_superset = L.utfGrid(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+compareurlparams, u_inat_options);
   u_inat_grid_superset.on("click", function(e) { // "mouseover" and "mouseout" events not used here
      if (e.data) {
         Promise.all([
            ffetch(inat_urlbase+'observations/'+e.data.id),
            Promise.resolve(e.data.cellCount)
         ])
         .then ((data) => { fpopup(data[0].results[0],data[1]); });
      };
   });
   var v_inat_options = {
      idField: 'id',  // Expects UTFgrid to have a property 'ID' that indicates the feature ID
      buildIndex: true,  // requires above field to be set properly
      fillColor: 'black',
      shadowBlur: 0,  // Number of pixels for blur effect
      shadowColor: null,  // Color for shadow, if present.  Defaults to fillColor.
      debug: false,  // if true, show tile borders and tile keys
      minZoom:0,
      maxZoom:20, 
   };
   var v_inat_points = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, { ...v_inat_options, minZoom:10, });
   var v_inat_points_all = L.utfGridCanvas(inat_urlbase+'points/{z}/{x}/{y}.grid.json?'+winurlparams, v_inat_options);
   var v_inat_grid = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, { ...v_inat_options, minZoom:2, maxZoom:9 });
   var v_inat_grid_all = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+winurlparams, v_inat_options);
   var v_inat_grid_superset = L.utfGridCanvas(inat_urlbase+'grid/{z}/{x}/{y}.grid.json?'+compareurlparams, v_inat_options);
   var g_utfgdm_sel = L.layerGroup([u_inat_grid,u_inat_points,v_inat_grid,v_inat_points]);
   var g_utfgdm_sel_points = L.layerGroup([u_inat_points_all,v_inat_points_all]);
   var g_utfgdm_sel_grid = L.layerGroup([u_inat_grid_all,v_inat_grid_all]);
   var g_utfgdm_sel_superset = L.layerGroup([u_inat_grid_superset,v_inat_grid_superset]);
   // iNat UTFGrid Comparison Layer
   // note that iNat provides 4 UTFGrid endpoints. the grid and heatmap endpoints are interchangeable and the ones to use for this application.
   let utfgridapi = {url:'https://api.inaturalist.org/v1/grid/{z}/{x}/{y}.grid.json',attr:'<a href="https://api.inaturalist.org/v1/docs/#!/UTFGrid/get_grid_zoom_x_y_grid_json">iNaturalist</a>'};
   var l_utfgrid_compare = L.gridLayer.utfGridCompare({url:utfgridapi.url+'?'+winurlparams,attribution:utfgridapi.attr,marker:{size:0.75,opacity:0.5},urlcompare:utfgridapi.url+'?'+compareurlparams})
   // Other iNaturalist Layers
   var l_inat_place = L.tileLayer(inat_urlbase+'places/'+place_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_places_place_id_zoom_x_y_png">iNaturalist place polygon</a>'});
   // iNaturalist Taxon Places Checklist and Range Layers
   var l_inat_taxonplace = L.tileLayer(inat_urlbase+'taxon_places/'+taxon_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_places_taxon_id_zoom_x_y_png">iNaturalist taxon place checklist data</a>'});
   var l_inat_taxonrange = L.tileLayer(inat_urlbase+'taxon_ranges/'+taxon_id+'/{z}/{x}/{y}.png',{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'docs/#!/Polygon_Tiles/get_taxon_ranges_taxon_id_zoom_x_y_png">iNaturalist taxon range data</a>'});
   // Geomodel layers
   var l_inat_geomodel = L.tileLayer(inat_urlbase+'geomodel/'+taxon_id+'/{z}/{x}/{y}.png?thresholded='+thresholded,{minZoom:2, maxZoom:20, attribution:'<a href="'+inat_urlbase+'">iNaturalist geomodel</a>'});
   // Stamen layers
   // these are deprecated as Stamen tiles are now maintained by Stadia
   var s_stamen_copyright = 'Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://www.openstreetmap.org/copyright">ODbL</a>.'; // used for all sets except Watercolor
   var s_stamen_urlbase = 'https://stamen-tiles-{s}.a.ssl.fastly.net/';
   //var l_stamen_watercolor = L.tileLayer(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{minZoom:0, maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'});
   //var l_stamen_terrain = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainbg = L.tileLayer(s_stamen_urlbase+'terrain-background/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainlines = L.tileLayer(s_stamen_urlbase+'terrain-lines/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_terrainlabels = L.tileLayer(s_stamen_urlbase+'terrain-labels/{z}/{x}/{y}.jpg',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_toner = L.tileLayer(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlite = L.tileLayer(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerbg = L.tileLayer(s_stamen_urlbase+'toner-background/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerhybrid = L.tileLayer(s_stamen_urlbase+'toner-hybrid/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlines = L.tileLayer(s_stamen_urlbase+'toner-lines/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   //var l_stamen_tonerlabels = L.tileLayer(s_stamen_urlbase+'toner-labels/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright});
   // Stamen layer mods
   //var l_stamen_toner_mod_dark25 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(25%)'});
   //var l_stamen_toner_mod_dark70 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(70%)'});
   //var l_stamen_toner_mod_green_on_black = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(40%) sepia(40%) hue-rotate(60deg) saturate(400%) contrast(200%)'});
   //var l_stamen_toner_mod_black_on_blue = L.tileLayer.styleFilter(s_stamen_urlbase+'toner/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'invert(100%) brightness(60%) sepia(100%) hue-rotate(180deg) saturate(150%)'});
   //var l_stamen_tonerlite_mod_dark50 = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(50%) contrast(125%)'});
   //var l_stamen_tonerlite_mod_dark_with_purple = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'invert(100%) brightness(70%) sepia(100%) hue-rotate(205deg) saturate(160%)'});
   //var l_stamen_tonerlite_mod_olive = L.tileLayer.styleFilter(s_stamen_urlbase+'toner-lite/{z}/{x}/{y}.png',{minZoom:0, maxZoom:20, attribution:s_stamen_copyright, filter:'brightness(50%) sepia(100%) hue-rotate(15deg) saturate(160%)'});
   //var l_stamen_watercolor_mod_gray = L.tileLayer.styleFilter(s_stamen_urlbase+'watercolor/{z}/{x}/{y}.jpg',{minZoom:0, maxZoom:20, attribution:'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.', filter:'grayscale(85%)'});
   // Stamen Watercolor (now housed at Smithsonian)
   let s_watercolor = {url:'https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', attribution:'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'};
   var l_stamen_watercolor = L.tileLayer(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution});
   var l_stamen_watercolor_mod_muted = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(85%)'});
   var l_stamen_watercolor_mod_gray = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(100%)'});
   var l_stamen_watercolor_mod_darkgray = L.tileLayer.styleFilter(s_watercolor.url,{minZoom:0, maxZoom:20, attribution:s_watercolor.attribution, filter:'grayscale(100%) brightness(50%)'});
   // OpenStreetMaps & OpenTopoMap
   let s_osm_std = {url:'https://tile.openstreetmap.org/{z}/{x}/{y}.png', attribution:'&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'};
   var l_osm_std = L.tileLayer(s_osm_std.url, {minZoom:0, maxNativeZoom:19, maxZoom:20, attribution:s_osm_std.attribution});
   var l_osm_de = L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', {minZoom:0, maxZoom:20, attribution:'&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles <a href="https://openstreetmap.de/">OpenStreetMap Deutschland</a>'});
   var l_osm_fr = L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {minZoom:0, maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - rendu <a href="https://openstreetmap.fr">OSM France</a>'});
   var l_osm_hot = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {minZoom:0, maxNativeZoom:19, maxZoom:20, attribution:'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - Tiles courtesy of <a href="https://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'});
   let s_otm = {url:'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attribution:'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org/">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'};
   var l_otm = L.tileLayer(s_otm.url,{minZoom:0, maxNativeZoom:17, maxZoom:20, attribution:s_otm.attribution});
   // mods
   var l_otm_mod_muted = L.tileLayer.styleFilter(s_otm.url,{minZoom:0, maxNativeZoom:17, maxZoom:20, attribution:s_otm.attribution, filter:'grayscale(60%)'});
   var l_osm_std_mod_lightgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%)'});
   var l_osm_std_mod_medgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) brightness(50%) contrast(150%)'});
   var l_osm_std_mod_medgray2 = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) brightness(50%) contrast(150%) invert(100%) contrast(125%)'});
   var l_osm_std_mod_darkgray = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) invert(100%)'});
   var l_osm_std_mod_darkest = L.tileLayer.styleFilter(s_osm_std.url, {minZoom:0, maxZoom:20, attribution:s_osm_std.attribution, filter:'grayscale(100%) invert(100%) brightness(80%) contrast(125%)'});
   // EOX -- http://maps.eox.at/
   // capabilities (including attribution) -- https://tiles.maps.eox.at/wmts/1.0.0/WMTSCapabilities.xml
   function f_eox_url(tileset,format) { return `https://tiles.maps.eox.at/wmts/1.0.0/${tileset}/default/g/{z}/{y}/{x}.${format}`; }; 
   // basemaps
   var l_eox_osm = L.tileLayer(f_eox_url('osm_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">OpenStreetMap</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_blackmarble = L.tileLayer(f_eox_url('blackmarble_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Black Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'});
   var l_eox_bluemarble = L.tileLayer(f_eox_url('bluemarble_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Blue Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'});
   var l_eox_terrain = L.tileLayer(f_eox_url('terrain_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var l_eox_terrain_light = L.tileLayer(f_eox_url('terrain-light_3857','jpg'),{minZoom:0, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var l_eox_sentinel2_2024 = L.tileLayer(f_eox_url('s2cloudless-2024_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2024) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2023 = L.tileLayer(f_eox_url('s2cloudless-2023_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2023) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2022 = L.tileLayer(f_eox_url('s2cloudless-2022_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2022) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2021 = L.tileLayer(f_eox_url('s2cloudless-2021_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2021) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2020 = L.tileLayer(f_eox_url('s2cloudless-2020_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2020) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2019 = L.tileLayer(f_eox_url('s2cloudless-2019_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2019) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   var l_eox_sentinel2_2018 = L.tileLayer(f_eox_url('s2cloudless-2018_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2019) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'});
   //var l_eox_sentinel2_2017 = L.tileLayer(f_eox_url('s2cloudless-2017_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2017) released under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.'});
   //var l_eox_sentinel2_2016 = L.tileLayer(f_eox_url('s2cloudless-2016_3857','jpg'),{minZoom:0, maxZoom:20, attribution:'<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2016 &amp; 2017) released under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.'});
   // overlays
   var l_eox_hydrography = L.tileLayer(f_eox_url('hydrography_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Hydrography overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_coastline = L.tileLayer(f_eox_url('coastline_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Coastline overlay</a> { Rendering &copy; <a href="https://eox.at">EOX</a> }'}); 
   var l_eox_streets = L.tileLayer(f_eox_url('streets_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Streets overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_overlay = L.tileLayer(f_eox_url('overlay_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Overlay</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   var l_eox_overlay_bright = L.tileLayer(f_eox_url('overlay_bright_3857','png'),{minZoom:0, maxZoom:20, attribution:'<a href="https://maps.eox.at">Overlay bright</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'});
   // USGS maps (US primarily)
   var s_usgs_urlbase = 'https://basemap.nationalmap.gov/arcgis/rest/services/'
   //var l_usgs_topo = L.tileLayer(s_usgs_urlbase+'USGSTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, attribution:'<a href="'+s_usgs_urlbase+'USGSTopo/MapServer">USGS The National Map</a>: National Boundaries Dataset, 3DEP Elevation Program, Geographic Names Information System, National Hydrography Dataset, National Land Cover Database, National Structures Dataset, and National Transportation Dataset; USGS Global Ecosystems; U.S. Census Bureau TIGER/Line data; USFS Road Data; Natural Earth Data; U.S. Department of State Humanitarian Information Unit; and NOAA National Centers for Environmental Information, U.S. Coastal Relief Model'});
   var l_usgs_topo = L.tileLayer(s_usgs_urlbase+'USGSTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, attribution:'<a href="'+s_usgs_urlbase+'USGSTopo/MapServer">USGS The National Map</a>'});
   // var l_stamen_terrain_fallback = L.tileLayer(s_stamen_urlbase+'terrain/{z}/{x}/{y}.jpg',{minZoom:9, maxNativeZoom:16, attribution:s_stamen_copyright});
   var l_eox_terrain_light_fallback = L.tileLayer(f_eox_url('terrain-light_3857','jpg'),{minZoom:9, maxNativeZoom:18, maxZoom:20, attribution:'<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'});
   var g_usgs_topo = L.layerGroup([l_eox_terrain_light_fallback, l_usgs_topo]);
   var l_usgs_img = L.tileLayer(s_usgs_urlbase+'USGSImageryOnly/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSImageryOnly/MapServer">USGS The National Map</a>: Orthoimagery'});
   var l_usgs_imgtopo = L.tileLayer(s_usgs_urlbase+'USGSImageryTopo/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSImageryTopo/MapServer">USGS The National Map</a>: Orthoimagery and US Topo'});
   //var l_usgs_relief = L.tileLayer(s_usgs_urlbase+'USGSShadedReliefOnly/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSShadedReliefOnly/MapServer">USGS The National Map</a>: 3D Elevation Program'});
   var l_usgs_hydro = L.tileLayer(s_usgs_urlbase+'USGSHydroCached/MapServer/tile/{z}/{y}/{x}',{minZoom:0, maxNativeZoom:16, maxZoom:20, attribution:'<a href="'+s_usgs_urlbase+'USGSHydroCached/MapServer">USGS The National Map</a>: National Hydrography Dataset'});
   // USGS Ecological Land Units (Worldwide coverage) -- no longer available as of early 2025
   // (Note: The WMS Server doesn't respond very well when requesting many tiled images. So we'll request images from the /export route instead using a custom tileLayer extension.)
   //var l_usgs_ecolandunit = L.tileLayer.wms('https://rmgsc.cr.usgs.gov/arcgis/services/globalelus/MapServer/WMSServer?',{minZoom:0, maxZoom:20, attribution:'<a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">USGS Global Ecosystems</a>', format:'image/png32', transparent:true, layers:'4'});
   //var l_usgs_ecolandunit = L.tileLayer.usgs('https://rmgsc.cr.usgs.gov/ArcGIS/rest/services/globalelus/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:0',{minZoom:0, maxZoom:20, attribution:'<a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">USGS Global Ecosystems</a>', filter:'opacity(100%)'});
   // USGS Elevation (US, Mexico, Canada)
   // (Note: The WMS Server seems to be gone as of 2024. So we'll go with /exportImage route to get tiled images.)
   //var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer';
   var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage?';
   var s_usgs_3dep_attribution = '<a href="https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer">USGS 3D Elevation Program</a>';
   //var l_usgs_3dep_hillshade = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Hillshade Gray'}); //possible values: 'Hillshade Gray', 'Hillshade Multidirectional' , 'Hillshade Elevation Tinted', 'GreyHillshade_elevationFill'
   //var l_usgs_3dep_aspect = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Aspect Map'}); //possible values: 'Aspect Map', 'Aspect Degrees'
   //var l_usgs_3dep_slope = L.tileLayer.wms(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, format:'image/png32', transparent:false, layers:'Slope Map'}); //possible values: 'Slope Map', 'Slope Degrees'
   var l_usgs_3dep_hillshade = L.tileLayer.usgs(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, renderingRule:'Hillshade Gray'}); //possible values: 'Hillshade Gray', 'Hillshade Multidirectional' , 'Hillshade Elevation Tinted', 'GreyHillshade_elevationFill'
   var l_usgs_3dep_aspect = L.tileLayer.usgs(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, renderingRule:'Aspect Map'}); //possible values: 'Aspect Map', 'Aspect Degrees'
   var l_usgs_3dep_slope = L.tileLayer.usgs(s_usgs_3dep_urlbase,{minZoom:0, maxZoom:20, attribution:s_usgs_3dep_attribution, renderingRule:'Slope Map'}); //possible values: 'Slope Map', 'Slope Degrees'
   // USGS other overlays (US only)
   // (Note: The WMS Server doesn't respond very well when requesting many tiled images. So we'll request images from the /export route instead using a custom tileLayer extension.)
   var s_usgs_overlay_attribution = '<a href="https://carto.nationalmap.gov/">USGS the National Map</a>'
   //var l_usgs_3dep_contours = L.tileLayer.wms('https://carto.nationalmap.gov/arcgis/services/contours/MapServer/WMSServer?',{minZoom:8, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35', format:'image/png32', transparent:true});
   //var l_usgs_3dep_transport = L.tileLayer.wms('https://carto.nationalmap.gov/arcgis/services/transportation/MapServer/WMSServer?',{minZoom:4, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38', format:'image/png32', transparent:true});
   var l_usgs_3dep_contours = L.tileLayer.usgs('https://carto.nationalmap.gov/arcgis/rest/services/contours/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:1,2,3,4,5,6,7,8,10,11,12,13,15,16,17,18,21,22,25,26',{minZoom:8, maxZoom:20, attribution:s_usgs_overlay_attribution, filter:'opacity(100%)'});
   // var l_usgs_3dep_transport = L.tileLayer.usgs('https://carto.nationalmap.gov/arcgis/rest/services/transportation/MapServer/export?format=png32&dpi=120&transparent=true&layers=show:0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38',{minZoom:4, maxZoom:20, attribution:s_usgs_overlay_attribution, filter:'opacity(100%)'});
   var l_graticule = L.tileLayer.wms('https://gis.ngdc.noaa.gov/arcgis/services/web_mercator/graticule/MapServer/WMSServer?',{minZoom:0, maxZoom:20, attribution:s_usgs_overlay_attribution, layers:'0,1,2,3,4,5,6', format:'image/png32', transparent:true});
   //debug layer
   var l_debug = L.gridLayer.debugCoords();
   var defaultlayers = (view==='elevation') ? [g_usgs_topo]
      //: (view==='ecolandunit') ? [l_eox_terrain,l_usgs_ecolandunit,l_eox_overlay]
      : (view==='heatmap') ? [l_stamen_watercolor_mod_muted,l_eox_overlay]
      : (view==='subsetratio') ? [l_osm_std_mod_medgray2]
      : [l_osm_std];
   if (taxon_id!==null) {
      if (showtaxonplace==='true') {defaultlayers.push(l_inat_taxonplace)};
      if (showtaxonrange==='true') {defaultlayers.push(l_inat_taxonrange)};
      if (showexpectednearby==='true') {defaultlayers.push(l_inat_geomodel)};
   };
   if (place_id!==null) { 
      if (showplace==='true') {defaultlayers.push(l_inat_place)};
   };
   if (view==='heatmap') {
      defaultlayers.push(l_inat_heat);
   }
   else if (view==='subsetratio' && compexclparam) {
      defaultlayers.push(l_utfgrid_compare);
      defaultlayers.push(g_utfgdm_sel_grid);
   } 
   else {
      defaultlayers.push(g_inat_obs);
      defaultlayers.push(g_utfgdm_sel);
   };
   // define available basemaps (can view only one at a time)
   var basemaps = {
      "Stamen Watercolor": l_stamen_watercolor,
      "Stamen Watercolor Mod (Muted)": l_stamen_watercolor_mod_muted,
      "Stamen Watercolor Mod (Gray)": l_stamen_watercolor_mod_gray,
      "Stamen Watercolor Mod (Dark Gray)": l_stamen_watercolor_mod_darkgray,
      //"Stamen Terrain": l_stamen_terrain,
      //"Stamen Terrain Background": l_stamen_terrainbg,
      //"Stamen Toner": l_stamen_toner,
      //"Stamen Toner Background": l_stamen_tonerbg,
      //"Stamen Toner Lite": l_stamen_tonerlite,
      //"Stamen Toner Mod (Med Dark)": l_stamen_toner_mod_dark70,
      //"Stamen Toner Mod (Dark)": l_stamen_toner_mod_dark25,
      //"Stamen Toner Mod (Green on Black)": l_stamen_toner_mod_green_on_black,
      //"Stamen Toner Mod (Black on Blue)": l_stamen_toner_mod_black_on_blue,
      //"Stamen Toner Lite Mod (Med Dark)": l_stamen_tonerlite_mod_dark50,
      //"Stamen Toner Lite Mod (Dark with Purple)": l_stamen_tonerlite_mod_dark_with_purple,
      //"Stamen Toner Lite Mod (Olive)": l_stamen_tonerlite_mod_olive,
      "OpenTopoMap": l_otm,
      "OpenTopoMap Mod (Muted)": l_otm_mod_muted,
      "OpenStreetMap Standard": l_osm_std,
      "OpenStreetMap Std Mod (Light Gray)": l_osm_std_mod_lightgray,
      "OpenStreetMap Std Mod (Gray 1)": l_osm_std_mod_medgray,
      "OpenStreetMap Std Mod (Gray 2)": l_osm_std_mod_medgray2,
      "OpenStreetMap Std Mod (Dark Gray)": l_osm_std_mod_darkgray,
      "OpenStreetMap Std Mod (Near Black)": l_osm_std_mod_darkest,
      "OpenStreetMap Deutschland": l_osm_de,
      "OpenStreetMap France": l_osm_fr,
      "OpenStreetMap Humanitarian": l_osm_hot,
      "EOX OSM": l_eox_osm,
      "EOX Black Marble": l_eox_blackmarble,
      "EOX Blue Marble": l_eox_bluemarble,
      "EOX Sentinel-2 2024": l_eox_sentinel2_2024,
      "EOX Sentinel-2 2023": l_eox_sentinel2_2023,
      "EOX Sentinel-2 2022": l_eox_sentinel2_2022,
      "EOX Sentinel-2 2021": l_eox_sentinel2_2021,
      "EOX Sentinel-2 2020": l_eox_sentinel2_2020,
      "EOX Sentinel-2 2019": l_eox_sentinel2_2019,
      "EOX Sentinel-2 2018": l_eox_sentinel2_2018,
      //"EOX Sentinel-2 2017": l_eox_sentinel2_2017,
      //"EOX Sentinel-2 2016": l_eox_sentinel2_2016,
      "EOX Terrain": l_eox_terrain,
      "EOX Terrain (Light)": l_eox_terrain_light,
      "USGS Imagery": l_usgs_img,
      "USGS Topo": g_usgs_topo,
      "USGS Imagery + Topo": l_usgs_imgtopo,
      //"USGS Relief": l_usgs_relief,
      "USGS Hillshade (US, CA, MX)": l_usgs_3dep_hillshade,
      "USGS Aspect (US, CA, MX)": l_usgs_3dep_aspect,
      "USGS Slope (US, CA, MX)": l_usgs_3dep_slope,
   };
   // define available overlay maps (can view more than one at a time, arranged in order from lowest to highest)
   var overlaymaps = {
      //"USGS Ecological Land Units": l_usgs_ecolandunit,
      "USGS Hydro": l_usgs_hydro,
      "EOX Hydrography": l_eox_hydrography,
      "USGS Contours (US only)": l_usgs_3dep_contours,
      //"USGS Trasnportation": l_usgs_3dep_transport,
      //"Stamen Terrain Lines": l_stamen_terrainlines,
      //"Stamen Toner Lines": l_stamen_tonerlines,
      //"Stamen Toner Hybrid": l_stamen_tonerhybrid,
      //"Stamen Terrain Labels": l_stamen_terrainlabels,
      //"Stamen Toner Labels": l_stamen_tonerlabels,
      "EOX Streets": l_eox_streets,
      "EOX Coastline": l_eox_coastline,
      "EOX Overlay": l_eox_overlay,
      "EOX Overlay (Bright)": l_eox_overlay_bright,
      ...((taxon_id==null) ? {} : {"iNaturalist Taxon Range": l_inat_taxonrange}),
      ...((taxon_id==null) ? {} : {"iNaturalist Taxon Places": l_inat_taxonplace}),
      ...((taxon_id==null) ? {} : (thresholded? {"iNaturalist Expected Nearby": l_inat_geomodel} : {"iNaturalist Unthresholded Geomodel": l_inat_geomodel})),
      ...((place_id==null) ? {} : {"iNaturalist Place": l_inat_place}),
      ...((compexclparam==null) ? {} : {"iNaturalist Subset Ratio (Red=1.0, Blue=0.0)": l_utfgrid_compare}),
      //"iNaturalist Observations Density in GBIF (no filters)": l_gbif,
      "iNaturalist Observations Heatmap": l_inat_heat,
      "iNaturalist Observations Heatmap Mod (Transparent)": l_inat_heat_mod_transparent,
      //"iNaturalist Observations Circles": l_inat_circles,
      "iNaturalist Observations Grid": l_inat_grid,
      "iNaturalist Observations Points": l_inat_points,
      "iNaturalist Observations":g_inat_obs,
      "iNaturalist Observation Info":g_utfgdm_sel,
      "iNaturalist Observation Info for Grid":g_utfgdm_sel_grid,
      ...((compexclparam==null) ? {} : {"iNaturalist Observation Info for Superset Grid": g_utfgdm_sel_superset}),
      "iNaturalist Observation Info for Points":g_utfgdm_sel_points,
      "Graticule":l_graticule,
      "Debug Grid":l_debug,
   };
   var mymap;
   // if centerlat, centerlng, or defaultzoom are specified, then use that user-specified value
   // otherwise, set map extent based on coverage of observations
   let prom = (centerlat===null && centerlng===null && defaultzoom===null) ? ffetch(inat_urlbase+'observations?return_bounds=true&per_page=0&'+winurlparams) : Promise.resolve(null);
   prom.then((data) => {
      return data?.total_bounds;
   })
   .then((bbox) => {
      // create map, and set default center coordinates, zoom level, and layers
      mymap = L.map('mapid', {
         center: [centerlat||0,centerlng||0], // default to lat 0, long 0
         zoom: defaultzoom??2, // iNat defaults to zoom level 2
         layers: defaultlayers,
         doubleClickZoom: false
      });
      if (bbox) {
         var bounds = [[bbox.nelat,(bbox.swlng<bbox.nelng?bbox.nelng:bbox.nelng+360)],[bbox.swlat,bbox.swlng]];
         var padding = {padding:[5,5]};
         mymap.fitBounds(bounds,padding);
      };
      // add a layer selector control and scale bar
      L.control.layers(basemaps, overlaymaps).addTo(mymap);
      L.control.scale().addTo(mymap);
   });
};
</script>
</body>
</html>